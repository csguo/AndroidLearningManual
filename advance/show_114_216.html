
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>Android SQLite的查询优化（三）_Android学习手册</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<META name=GENERATOR content="MSHTML 8.00.6001.18702">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">

</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li ><A href="../component/index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li ><A href="../device/index.html">设备功能</A> </li><li ><A href="../datastorage/index.html">数据存储</A> </li><li ><A href="../network/index.html">网络应用</A> </li><li ><A href="../game/index.html">游戏开发</A> </li><li ><A href="../multimedia/index.html">多媒体</A> </li><li ><A href="../source/index.html">源码开发</A> </li><li class="navcurrentLink"><A href="index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">课 程 表</div>


  <h2><A title="Android基础之运行原理和机制" href="index_215.html">Android基础之运行原理和机制</A></h2>

  <h2><A title="Android高级篇之Android优化" href="index_216.html">Android高级篇之Android优化</A></h2>
<UL><li ><A title=Android中View绘制优化之一 优化布局层次 href="show_101_216.html">Android中View绘制优化之一 优化布局层次</A> </li><li ><A title=Android中View绘制优化二 使用include 标签复用布局文件 href="show_102_216.html">Android中View绘制优化二 使用include 标签复用布局文件</A> </li><li ><A title=Android中View绘制优化之三 优化View href="show_103_216.html">Android中View绘制优化之三 优化View</A> </li><li ><A title=Android FrameLayou和布局优化（一） href="show_104_216.html">Android FrameLayou和布局优化（一）</A> </li><li ><A title=Android FrameLayou和布局优化（二） href="show_105_216.html">Android FrameLayou和布局优化（二）</A> </li><li ><A title=Android GridView视图缓存优化（一） href="show_106_216.html">Android GridView视图缓存优化（一）</A> </li><li ><A title=Android GridView视图缓存优化（二） href="show_107_216.html">Android GridView视图缓存优化（二）</A> </li><li ><A title=Android布局优化的要点 href="show_108_216.html">Android布局优化的要点</A> </li><li ><A title=Android 适配器（Adapter）优化 href="show_109_216.html">Android 适配器（Adapter）优化</A> </li><li ><A title=Android UI 优化 href="show_110_216.html">Android UI 优化</A> </li><li ><A title=Android 你的OnTouchEvent() 触屏事件的优化了吗 href="show_111_216.html">Android 你的OnTouchEvent() 触屏事件的优化了吗</A> </li><li ><A title=Android SQLite的查询优化（一） href="show_112_216.html">Android SQLite的查询优化（一）</A> </li><li ><A title=Android SQLite的查询优化（二） href="show_113_216.html">Android SQLite的查询优化（二）</A> </li><li class="currentLink"><A title=Android SQLite的查询优化（三） href="show_114_216.html">Android SQLite的查询优化（三）</A> </li><li ><A title=Android程序运行性能优化 href="show_115_216.html">Android程序运行性能优化</A> </li><li ><A title=Android代码性能优化技巧 href="show_116_216.html">Android代码性能优化技巧</A> </li><li ><A title=Android进程管理机制及优化 href="show_117_216.html">Android进程管理机制及优化</A> </li><li ><A title=Android应用开发者指南：性能优化 href="show_118_216.html">Android应用开发者指南：性能优化</A> </li><li ><A title=如何优化java代码 href="show_119_216.html">如何优化java代码</A> </li><li ><A title=Android Dalvik检查和优化.apk.jar的流程introduce href="show_120_216.html">Android Dalvik检查和优化.apk.jar的流程introduce</A> </li><li ><A title=ProGuard支持哪些种类的优化 href="show_121_216.html">ProGuard支持哪些种类的优化</A> </li><li ><A title=Android和大家分享几个重要的代码（一） href="show_122_216.html">Android和大家分享几个重要的代码（一）</A> </li><li ><A title=Android和大家分享几个重要的代码（二） href="show_123_216.html">Android和大家分享几个重要的代码（二）</A> </li></UL>
  <h2><A title="Android高级篇之编译及反编译" href="index_217.html">Android高级篇之编译及反编译</A></h2>

  <h2><A title="Android高级篇之加密解密" href="index_218.html">Android高级篇之加密解密</A></h2>

  <h2><A title="Android高级篇之Android 安全" href="index_219.html">Android高级篇之Android 安全</A></h2>

  <h2><A title="Android高级篇之算法" href="index_220.html">Android高级篇之算法</A></h2>

  <h2><A title="Android高级篇之解锁教程" href="index_221.html">Android高级篇之解锁教程</A></h2>

</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1></H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>Android SQLite的查询优化（三）</H2>
<div style="line-height:20px; font-size:14px;"><p style="color:#3333FF;">五、连接查询</p><p>在返回查询结果之前，相关表的每行必须都已经连接起来，在SQLite中，这是用嵌套循环实现的，在早期版本中，最左边的是最外层循环，最右边的是最内层循环，连接两个或者更多的表时，如果有索引则放到内层循环中，也就是放到FROM最后面，因为对于前面选中的每行，找后面与之对应的行时，如果有索引则会很快，如果没有则要遍历整个表，这样效率就很低，但在新版本中，这个优化已经实现。</p><p>优化的方法如下：</p><p>对要查询的每个表，统计这个表上的索引信息，首先将代价赋值为SQLITE_BIG_DBL（一个系统已经定义的常量）：</p><p style="color:#3333FF;">1、如果没有索引，则找有没有在这个表上对rowid的查询条件：</p><p>如果有Rowid=EXPR，如果有的话则返回对这个表代价估计，代价计为零，查询得到的记录数为1，并完成对这个表的代价估计。</p><p>如果没有Rowid=EXPR 但有rowid IN (...)，而IN是一个列表，那么记录返回记录数为IN列表中元素的个数，估计代价为NlogN。</p><p>如果IN不是一个列表而是一个子查询结果，那么由于具体这个子查询不能确定，所以只能估计一个值，返回记录数为100，代价为200。</p><p>如果对rowid是范围的查询，那么就估计所有符合条件的记录是总记录的三分之一，总记录估计为1000000，并且估计代价也为记录数。</p><p>如果这个查询还要求排序，则再另外加上排序的代价NlogN。</p><p>如果此时得到的代价小于总代价，那么就更新总代价，否则不更新。</p><p style="color:#3333FF;">2、如果WHERE子句中存在OR操作符，那么要把这些OR连接的所有子句分开再进行分析。</p><p>如果有子句是由AND连接符构成，那么再把由AND连接的子句再分别分析。</p><p>如果连接的子句的形式是X&lt;op&gt;&lt;expr&gt;，那么就再分析这个子句。</p><p>接下来就是把整个对OR操作的总代价计算出来。</p><p>如果这个查询要求排序，则再在上面总代价上再乘上排序代价NlogN。</p><p>如果此时得到的代价小于总代价，那么就更新总代价，否则不更新。</p><p style="color:#3333FF;">3、如果有索引，则统计每个表的索引信息，对于每个索引：</p><p>先找到这个索引对应的列号，再找到对应的能用到（操作符必须为=或者是IN（…））这个索引的WHERE子句，如果没有找到，则退出对每个索引的循环，如果找到，则判断这个子句的操作符是什么，如果是=，那么没有附加的代价，如果是IN（sub-select），那么估计它附加代价inMultiplier为25，如果是IN（list），那么附加代价就是N（N为list的列数）。</p><p>再计算总的代价和总的查询结果记录数和代价。</p><p><pre>nRow = pProbe-&gt;aiRowEst * inMultiplier;/*计算行数*/</p><p>cost = nRow * estLog(inMultiplier);/*统计代价*/</p><p></pre></p><p>如果找不到操作符为=或者是IN（…）的子句，而是范围的查询，那么同样只好估计查询结果记录数为nRow/3，估计代价为cost/3。</p><p>同样，如果此查询要求排序的话，再在上面的总代价上加上NlogN。</p><p>如果此时得到的代价小于总代价，那么就更新总代价，否则不更新。</p><p style="color:#3333FF;">4、通过上面的优化过程，可以得到对一个表查询的总代价</p><p>再对第二个表进行同样的操作，这样如此直到把FROM子句中所有的表都计算出各自的代价，最后取最小的，这将作为嵌套循环的最内层，依次可以得到整个嵌套循环的嵌套顺序，此时正是最优的，达到了优化的目的。</p><p style="color:#3333FF;">5、所以循环的嵌套顺序不一定是与FROM子句中的顺序一致，因为在执行过程中会用索引优化来重新排列顺序。</p><p style="color:#3333FF;">六、索引</p><p>在SQLite中，有以下几种索引：</p><p>1)单列索引</p><p>2)多列索引</p><p>3)唯一性索引</p><p>4)对于声明为：INTEGER PRIMARY KEY的主键来说，这列会按默认方式排序，所以虽然在数据字典中没有对它生成索引，但它的功能就像个索引。所以如果在这个主键上在单独建立索引的话，这样既浪费空间也没有任何好处。</p><p style="color:#3333FF;">运用索引的注意事项：</p><p>1)对于一个很小的表来说没必要建立索引。</p><p>2)在一个表上如果经常做的是插入更新操作，那么就要节制使用索引。</p><p>3)也不要在一个表上建立太多的索引，如果建立太多的话那么在查询的时候SQLite可能不会选择最好的来执行查询，一个解决办法就是建立聚蔟索引。</p><p style="color:#3333FF;">索引的运用时机：</p><p>1) 操作符：=、&gt;、&lt;、IN等。</p><p>2) 操作符BETWEEN、LIKE、OR不能用索引，如：</p><p><pre>BETWEEN：SELECT * FROM mytable WHERE myfield BETWEEN 10 and 20;</p><p></pre></p><p>这时就应该将其转换成：		</p><p><pre>SELECT * FROM mytable WHERE myfield &gt;= 10 AND myfield &lt;= 20;</p><p></pre></p><p>此时如果在myfield上有索引的话就可以用了，大大提高速度。</p><p>再如LIKE：</p><p><pre>SELECT * FROM mytable WHERE myfield LIKE 'sql%';</p><p></pre></p><p>此时应该将它转换成：</p><p><pre>SELECT * FROM mytable WHERE myfield &gt;= 'sql' AND myfield &lt; 'sqm';</p><p></pre></p><p>此时如果在myfield上有索引的话就可以用了，大大提高速度。</p><p>再如OR：</p><p><pre>SELECT * FROM mytable WHERE myfield = 'abc' OR myfield = 'xyz';</p><p></pre></p><p>此时应该将它转换成：</p><p><pre>SELECT * FROM mytable WHERE myfield IN ('abc', 'xyz');</p><p></pre></p><p>此时如果在myfield上有索引的话就可以用了，大大提高速度。</p><p>3)有些时候索引都是不能用的，这时就应该遍历全表（程序演示）。</p><p><pre>SELECT * FROM mytable WHERE myfield % 2 = 1;</p><p>SELECT * FROM mytable WHERE substr(myfield, 0, 1) = 'w';</p><p>SELECT * FROM mytable WHERE length(myfield) &lt; 5;</p><p></pre></p><p></p></div>

</DIV></DIV>

<DIV id=footer style="display:none">
<P align="center">  
 
 
 
    </P>
</DIV></BODY></HTML>

