
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>Android应用开发者指南：性能优化_Android学习手册</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<META name=GENERATOR content="MSHTML 8.00.6001.18702">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">

</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li ><A href="../component/index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li ><A href="../device/index.html">设备功能</A> </li><li ><A href="../datastorage/index.html">数据存储</A> </li><li ><A href="../network/index.html">网络应用</A> </li><li ><A href="../game/index.html">游戏开发</A> </li><li ><A href="../multimedia/index.html">多媒体</A> </li><li ><A href="../source/index.html">源码开发</A> </li><li class="navcurrentLink"><A href="index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">课 程 表</div>


  <h2><A title="Android基础之运行原理和机制" href="index_215.html">Android基础之运行原理和机制</A></h2>

  <h2><A title="Android高级篇之Android优化" href="index_216.html">Android高级篇之Android优化</A></h2>
<UL><li ><A title=Android中View绘制优化之一 优化布局层次 href="show_101_216.html">Android中View绘制优化之一 优化布局层次</A> </li><li ><A title=Android中View绘制优化二 使用include 标签复用布局文件 href="show_102_216.html">Android中View绘制优化二 使用include 标签复用布局文件</A> </li><li ><A title=Android中View绘制优化之三 优化View href="show_103_216.html">Android中View绘制优化之三 优化View</A> </li><li ><A title=Android FrameLayou和布局优化（一） href="show_104_216.html">Android FrameLayou和布局优化（一）</A> </li><li ><A title=Android FrameLayou和布局优化（二） href="show_105_216.html">Android FrameLayou和布局优化（二）</A> </li><li ><A title=Android GridView视图缓存优化（一） href="show_106_216.html">Android GridView视图缓存优化（一）</A> </li><li ><A title=Android GridView视图缓存优化（二） href="show_107_216.html">Android GridView视图缓存优化（二）</A> </li><li ><A title=Android布局优化的要点 href="show_108_216.html">Android布局优化的要点</A> </li><li ><A title=Android 适配器（Adapter）优化 href="show_109_216.html">Android 适配器（Adapter）优化</A> </li><li ><A title=Android UI 优化 href="show_110_216.html">Android UI 优化</A> </li><li ><A title=Android 你的OnTouchEvent() 触屏事件的优化了吗 href="show_111_216.html">Android 你的OnTouchEvent() 触屏事件的优化了吗</A> </li><li ><A title=Android SQLite的查询优化（一） href="show_112_216.html">Android SQLite的查询优化（一）</A> </li><li ><A title=Android SQLite的查询优化（二） href="show_113_216.html">Android SQLite的查询优化（二）</A> </li><li ><A title=Android SQLite的查询优化（三） href="show_114_216.html">Android SQLite的查询优化（三）</A> </li><li ><A title=Android程序运行性能优化 href="show_115_216.html">Android程序运行性能优化</A> </li><li ><A title=Android代码性能优化技巧 href="show_116_216.html">Android代码性能优化技巧</A> </li><li ><A title=Android进程管理机制及优化 href="show_117_216.html">Android进程管理机制及优化</A> </li><li class="currentLink"><A title=Android应用开发者指南：性能优化 href="show_118_216.html">Android应用开发者指南：性能优化</A> </li><li ><A title=如何优化java代码 href="show_119_216.html">如何优化java代码</A> </li><li ><A title=Android Dalvik检查和优化.apk.jar的流程introduce href="show_120_216.html">Android Dalvik检查和优化.apk.jar的流程introduce</A> </li><li ><A title=ProGuard支持哪些种类的优化 href="show_121_216.html">ProGuard支持哪些种类的优化</A> </li><li ><A title=Android和大家分享几个重要的代码（一） href="show_122_216.html">Android和大家分享几个重要的代码（一）</A> </li><li ><A title=Android和大家分享几个重要的代码（二） href="show_123_216.html">Android和大家分享几个重要的代码（二）</A> </li></UL>
  <h2><A title="Android高级篇之编译及反编译" href="index_217.html">Android高级篇之编译及反编译</A></h2>

  <h2><A title="Android高级篇之加密解密" href="index_218.html">Android高级篇之加密解密</A></h2>

  <h2><A title="Android高级篇之Android 安全" href="index_219.html">Android高级篇之Android 安全</A></h2>

  <h2><A title="Android高级篇之算法" href="index_220.html">Android高级篇之算法</A></h2>

  <h2><A title="Android高级篇之解锁教程" href="index_221.html">Android高级篇之解锁教程</A></h2>

</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1></H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>Android应用开发者指南：性能优化</H2>
<div style="line-height:20px; font-size:14px;"><p style="color:#3333FF;">性能优化</p><p>Android应用程序运行的移动设备受限于其运算能力，存储空间，及电池续航。由此，它必须是高效的。电池续航可能是一个促使你优化程序的原因，即使他看起来已经运行的足够快了。由于续航对用户的重要性，当电量耗损陡增时，意味这用户迟早会发现是由于你的程序。</p><p>虽然这份文档主要包含着细微的优化，但这些绝不能成为你软件成败的关键。选择合适的算法和数据结构永远是你最先应该考虑的事情，但这超出这份文档之外。</p><p style="color:#3333FF;">简介</p><p>写出高效的代码有两条基本的原则：</p><p>◆不作没有必要的工作。</p><p>◆尽量避免内存分配。</p><p style="color:#3333FF;">明智的优化</p><p>这份文档是关于Android规范的细微优化，所以先确保你已经了解哪些代码需要优化，并且知道如何去衡量你所做修改所带来的效果(好或坏)。开发投入的时间是有限的，所以明智的时间规划很重要。</p><p>这份文档同时确保你在算法和数据结构上作出最佳选择的同时，考虑API选择所带来的潜在影响。使用合适的数据结构和算法比这里的任何建议都更有价值，优先考虑API版本带来的影响有助于你找到更好的实现。(这在类库代码中更为重要，相比应用代码)</p><p>在优化Android程序时，会遇到的一个棘手问题是，保证你的程序能在不同的硬件平台上运行。虚拟机版本和处理器各部相同，因此运行在之上的速度也大不一样。但这并且不是简单的A比B快或慢，并能在设备间做出排列。特别的，模拟器上只能评测出一小部分设备上体现的东西。有无JIT的设备间也存在着巨大差异，在JIT设备上好的代码有时候会在无JIT的设备上表现的并不好。</p><p>如果你想知道一个程序在设备上的具体表现，就必须在上面进行测试。</p><p style="color:#3333FF;">避免创建不必要的对象</p><p>对象创建永远不会是免费的。每个线程的分代GC给零时对象分配一个地址池以降低分配开销，但往往内存分配比不分配需要的代价大。</p><p>如果在用户界面周期内分配对象，就会强制一个周期性的垃圾回收，给用户体验增加小小的停顿间隙。Gingerbread中提到的并发回收也许有用，但不必要的工作应当被避免的。</p><p>因此，应该避免不必要的对象创建。下面是几个例子：</p><p>◆如果有一个返回String的方法，并且他的返回值常常附加在一个StringBuffer上，改变声明和实现，让函数直接在其后面附加，而非创建一个短暂存在的零时变量。</p><p>◆当从输入的数据集合中读取数据时，考虑返回原始数据的子串，而非新建一个拷贝.这样你虽然创建一个新的对象，但是他们共享该数据的char数组。(结果是即使仅仅使用原始输入的一部分，你也需要保证它的整体一直存在于内存中。)</p><p>一个更彻底的方案是将多维数组切割成平行一维数组。</p><p>◆Int类型的数组常有余Integer类型的。推而广之，两个平行的int数组要比一个(int,int)型的对象数组高效。这对于其他任何基本数据类型的组合都通用。</p><p>◆如果需要实现一个容器来存放元组(Foo,Bar)，两个平行数组Foo[],Bar[]会优于一个(Foo,Bar)对象的数组。(例外情况是：当你设计API给其他代码调用时，应用好的API设计来换取小的速度提升。但在自己的内部代码中，尽量尝试高效的实现。)</p><p>通常来讲，尽量避免创建短时零时对象.少的对象创建意味着低频的垃圾回收。而这对于用户体验产生直接的影响。</p><p style="color:#3333FF;">性能之谜</p><p>前一个版本的文档给出了好多误导人的主张，这里做一些澄清：</p><p>在没有JIT的设备上，调用方法所传递的对象采用具体的类型而非接口类型会更高效(比如，传递HashMap map比Map map调用一个方法的开销小，尽管两个map都是HashMap).但这并不是两倍慢的情形，事实上，他们只相差6%，而有JIT时这两种调用的效率不相上下。</p><p>在没有JIT的设备上，缓存后的字段访问比直接访问快大概20%。而在有JIT的情况下，字段访问的代价等同于局部访问，因此这里不值得优化，除非你觉得他会让你的代码更易读(对于final ,static，及static final 变量同样适用)。</p><p style="color:#3333FF;">用静态代替虚拟</p><p>如果不需要访问某对象的字段，将方法设置为静态，调用会加速15%到20%。这也是一种好的做法，因为你可以从方法声明中看出调用该方法不需要更新此对象的状态。</p><p style="color:#3333FF;">避免内部的Getters/Setters</p><p>在源生语言像C++中，通常做法是用Getters(i=getCount())代替直接字段访问(i=mCount)。这是C++中一个好的习惯，因为编译器会内联这些访问，并且如果需要约束或者调试这些域的访问，你可以在任何时间添加代码。</p><p>而在Android中，这不是一个好的做法。虚方法调用的代价比直接字段访问高昂许多。通常根据面向对象语言的实践，在公共接口中使用Getters和Setters是有道理的，但在一个字段经常被访问的类中宜采用直接访问。</p><p>无JIT时，直接字段访问大约比调用getter访问快3倍。有JIT时(直接访问字段开销等同于局部变量访问)，要快7倍。在Froyo版本中确实如此，但以后版本可能会在JIT中改进Getter方法的内联。</p><p style="color:#3333FF;">对常量使用Static Final修饰符</p><p>考虑下面类首的声明：</p><p><img src="../img/adv_optimize/18_Final01.jpg"></p><p>编译器会生成一个类初始化方法,当该类初次被使用时执行，这个方法将42存入intVal中，并得到类文件字符串常量strVal的一个引用。当这些值在后面被引用时，他们通过字段查找进行访问。</p><p>我们改进实现，采用 final关键字：</p><p><img src="../img/adv_optimize/18_Final02.jpg"></p><p>类不再需要方法，因为常量通过静态字段初始化器进入dex文件中。引用intVal的代码，将直接调用整形值42;而访问strVal，也会采用相对开销较小的“字符串常量”(原文：“sring constant”)指令替代字段查找。(这种优化仅仅是针对基本数据类型和String类型常量的，而非任意的引用类型。但尽可能的将常量声明为static final是一种好的做法。</p><p style="color:#3333FF;">使用改进的For循环语法</p><p>改进for循环(有时被称为“for-each”循环)能够用于实现了iterable接口的集合类及数组中。在集合类中，迭代器让接口调用hasNext()和next()方法。在ArrayList中，手写的计数循环迭代要快3倍(无论有没有JIT)，但其他集合类中，改进的for循环语法和迭代器具有相同的效率。</p><p>这里有一些迭代数组的实现：</p><p><img src="../img/adv_optimize/18_for01.jpg"></p><p>zero()是当中最慢的，因为对于这个遍历中的历次迭代，JIT并不能优化获取数组长度的开销。</p><p>One()稍快，将所有东西都放进局部变量中，避免了查找。但仅只有声明数组长度对性能改善有益。</p><p>Two()是在无JIT的设备上运行最快的，对于有JIT的设备则和one()不分上下。他采用了JDK1.5中的改进for循环语法。</p><p>结论：优先采用改进for循环，但在性能要求苛刻的ArrayList迭代中，考虑采用手写计数循环。</p><p>在私有内部内中，考虑用包访问权限替代私有访问权限。</p><p>考虑下面的定义：</p><p><img src="../img/adv_optimize/18_for02.jpg"></p><p>需要注意的关键是：我们定义的一个私有内部类(Foo$Inner)，直接访问外部类中的一个私有方法和私有变量。这是合法的，代码也会打印出预期的“Value is 27”。</p><p>但问题是，虚拟机认为从Foo$Inner中直接访问Foo的私有成员是非法的，因为他们是两个不同的类，尽管Java语言允许内部类访问外部类的私有成员，但是通过编译器生成几个综合方法来桥接这些间隙的。</p><p><img src="../img/adv_optimize/18_Foo01.jpg"></p><p>内部类会在外部类中任何需要访问mValue字段或调用doStuff方法的地方调用这些静态方法。这意味着这些代码将直接存取成员变量表现为通过存取器方法访问。之前提到过存取器访问如何比直接访问慢，这例子说明，某些语言约会定导致不可见的性能问题。</p><p>如果你在高性能的Hotspot中使用这些代码，可以通过声明被内部类访问的字段和成员为包访问权限，而非私有。但这也意味着这些字段会被其他处于同一个包中的类访问，因此在公共API中不宜采用。</p><p style="color:#3333FF;">合理利用浮点数</p><p>通常的经验是，在Android设备中，浮点数会比整型慢两倍，在缺少FPU和JIT的G1上对比有FPU和JIT的Nexus One中确实如此(两种设备间算术运算的绝对速度差大约是10倍)。</p><p>从速度方面说，在现代硬件上，float和double之间没有任何不同。更广泛的讲，double大2倍。在台式机上，由于不存在空间问题，double的优先级高于float。</p><p>但即使是整型，有的芯片拥有硬件乘法，却缺少除法。这种情况下，整型除法和求模运算是通过软件实现的，就像当你设计Hash表，或是做大量的算术那样。</p><p style="color:#3333FF;">了解并使用类库</p><p>选择Library中的代码而非自己重写，除了通常的那些原因外，考虑到系统空闲时会用汇编代码调用来替代library方法，这可能比JIT中生成的等价的最好的Java代码还要好。典型的例子就是String.indexOf，Dalvik用内部内联来替代。同样的，System.arraycopy方法在有JIT的Nexus One上，自行编码的循环快9倍。</p><p style="color:#3333FF;">合理利用本地方法</p><p>本地方法并不是一定比Java高效。最起码，Java和native之间过渡的关联是有消耗的，而JIT并不能对此进行优化。当你分配本地资源时(本地堆上的内存，文件说明符等)，往往很难实时的回收这些资源。同时你也需要在各种结构中编译你的代码(而非依赖JIT)。甚至可能需要针对相同的架构来编译出不同的版本：针对ARM处理器的GI编译的本地代码，并不能充分利用Nexus One上的ARM，而针对Nexus One上ARM编译的本地代码不能在G1的ARM上运行。</p><p>当你想部署程序到存在本地代码库的Android平台上时，本地代码才显得尤为有用，而并非为了Java应用程序的提速。</p><p style="color:#3333FF;">结语</p><p>最后：通常考虑的是：先确定存在问题，再进行优化。并且你知道当前系统的性能，否则无法衡量你进行尝试所得到的提升。</p><p>这份文档中的每个主张都有标准基准测试作为支持。你可以在code.google.com“dalvik”项目中找到基准测试的代码。</p><p>这个标准基准测试是建立在Caliper Java标准微基准测试框架之上的。标准微基准测试很难找到正确的路，所以Caliper帮你完成了其中的困难部分工作。并且当你会察觉到某些情况的测试结果并想象中的那样(虚拟机总是在优化你的代码的)。我们强烈推荐你用Caliper来运行你自己的标准微基准测试。</p><p>同时你也会发现Traceview对分析很有用，但必须了解，他目前是不不支持JIT的，这可能导致那些在JIT上可以胜出的代码运行超时。特别重要的，根据Taceview的数据作出更改后，请确保代码在没有Traceview时，确实跑的快了。</p><p></p></div>

</DIV></DIV>

<DIV id=footer style="display:none">
<P align="center">  
 
 
 
    </P>
</DIV></BODY></HTML>

