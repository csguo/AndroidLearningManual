
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>Android Dalvik检查和优化.apk.jar的流程introduce_Android学习手册</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<META name=GENERATOR content="MSHTML 8.00.6001.18702">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">

</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li ><A href="../component/index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li ><A href="../device/index.html">设备功能</A> </li><li ><A href="../datastorage/index.html">数据存储</A> </li><li ><A href="../network/index.html">网络应用</A> </li><li ><A href="../game/index.html">游戏开发</A> </li><li ><A href="../multimedia/index.html">多媒体</A> </li><li ><A href="../source/index.html">源码开发</A> </li><li class="navcurrentLink"><A href="index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">课 程 表</div>


  <h2><A title="Android基础之运行原理和机制" href="index_215.html">Android基础之运行原理和机制</A></h2>

  <h2><A title="Android高级篇之Android优化" href="index_216.html">Android高级篇之Android优化</A></h2>
<UL><li ><A title=Android中View绘制优化之一 优化布局层次 href="show_101_216.html">Android中View绘制优化之一 优化布局层次</A> </li><li ><A title=Android中View绘制优化二 使用include 标签复用布局文件 href="show_102_216.html">Android中View绘制优化二 使用include 标签复用布局文件</A> </li><li ><A title=Android中View绘制优化之三 优化View href="show_103_216.html">Android中View绘制优化之三 优化View</A> </li><li ><A title=Android FrameLayou和布局优化（一） href="show_104_216.html">Android FrameLayou和布局优化（一）</A> </li><li ><A title=Android FrameLayou和布局优化（二） href="show_105_216.html">Android FrameLayou和布局优化（二）</A> </li><li ><A title=Android GridView视图缓存优化（一） href="show_106_216.html">Android GridView视图缓存优化（一）</A> </li><li ><A title=Android GridView视图缓存优化（二） href="show_107_216.html">Android GridView视图缓存优化（二）</A> </li><li ><A title=Android布局优化的要点 href="show_108_216.html">Android布局优化的要点</A> </li><li ><A title=Android 适配器（Adapter）优化 href="show_109_216.html">Android 适配器（Adapter）优化</A> </li><li ><A title=Android UI 优化 href="show_110_216.html">Android UI 优化</A> </li><li ><A title=Android 你的OnTouchEvent() 触屏事件的优化了吗 href="show_111_216.html">Android 你的OnTouchEvent() 触屏事件的优化了吗</A> </li><li ><A title=Android SQLite的查询优化（一） href="show_112_216.html">Android SQLite的查询优化（一）</A> </li><li ><A title=Android SQLite的查询优化（二） href="show_113_216.html">Android SQLite的查询优化（二）</A> </li><li ><A title=Android SQLite的查询优化（三） href="show_114_216.html">Android SQLite的查询优化（三）</A> </li><li ><A title=Android程序运行性能优化 href="show_115_216.html">Android程序运行性能优化</A> </li><li ><A title=Android代码性能优化技巧 href="show_116_216.html">Android代码性能优化技巧</A> </li><li ><A title=Android进程管理机制及优化 href="show_117_216.html">Android进程管理机制及优化</A> </li><li ><A title=Android应用开发者指南：性能优化 href="show_118_216.html">Android应用开发者指南：性能优化</A> </li><li ><A title=如何优化java代码 href="show_119_216.html">如何优化java代码</A> </li><li class="currentLink"><A title=Android Dalvik检查和优化.apk.jar的流程introduce href="show_120_216.html">Android Dalvik检查和优化.apk.jar的流程introduce</A> </li><li ><A title=ProGuard支持哪些种类的优化 href="show_121_216.html">ProGuard支持哪些种类的优化</A> </li><li ><A title=Android和大家分享几个重要的代码（一） href="show_122_216.html">Android和大家分享几个重要的代码（一）</A> </li><li ><A title=Android和大家分享几个重要的代码（二） href="show_123_216.html">Android和大家分享几个重要的代码（二）</A> </li></UL>
  <h2><A title="Android高级篇之编译及反编译" href="index_217.html">Android高级篇之编译及反编译</A></h2>

  <h2><A title="Android高级篇之加密解密" href="index_218.html">Android高级篇之加密解密</A></h2>

  <h2><A title="Android高级篇之Android 安全" href="index_219.html">Android高级篇之Android 安全</A></h2>

  <h2><A title="Android高级篇之算法" href="index_220.html">Android高级篇之算法</A></h2>

  <h2><A title="Android高级篇之解锁教程" href="index_221.html">Android高级篇之解锁教程</A></h2>

</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1></H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>Android Dalvik检查和优化.apk.jar的流程introduce</H2>
<div style="line-height:20px; font-size:14px;"><p>dalvik的目标平台是Android这样的小RAM，低速度flash memory，运行标准Linux系统的设备。针对这样的平台特性，要想做到更好，我们需要考虑以下几点：</p><p>1、为了减少系统的内存使用，字节码可以多进程共享。但出于安全性考虑，这样的字节码不可以编辑。</p><p>2、为了保证响应速度，加载一个新的APP所需时间尽量少。</p><p>3、标准Java中把多个类文件分别存放导致了大量的冗余，为了节省APP的占用空间，这个问题要解决。</p><p>4、加载类的时候解析类的字段成员会导致额外的消耗，如果改成像C一样直接访问会比较好。</p><p>5、字节码verification很有必要，但很慢，我们需要把验证与APP执行分开。</p><p>6、字节码optimization(比如指令优化、方法pruning)可以在很大程度上影响执行速度和电池消耗。</p><p>标准VM都是程序启动时把每单个的类文件解压放入heap，每个进程都有一份copy。这样的做法在内存占用和时间上面都有损失，但方便了对指令的优化。</p><p>现在看看dalvik是怎么做的：</p><p>1、多个类被集成进单一的DEX文件。</p><p>2、DEX文件在进程间以只读方式共享。</p><p>3、byte ordering和word alignment根据local system来做调整。</p><p>4、字节码verification尽可能提前。</p><p>5、需要修改字节码的optimization必须提前进行。</p><p>这样做的好处在下面一一介绍。</p><p style="color:#3333FF;">VM Operation</p><p>系统中的应用程序代码以.jar或.apk文件存在。其实它们都是.zip的文档，只不过多了一些文件头信息。DEX文件也就是解压.apk后的classes.dex文件。classes.dex中的字节码是经过压缩处理的，而且文件头部不一定是word aligned，所以不能直接mmap到内存直接执行，而是先解压，然后做一些realignment,optimization,verification操作。下面详细介绍一下这个过程。</p><p style="color:#3333FF;">Preparation</p><p>做到DEX文件的执行前优化（优化后的DEX叫做ODEX，Optimization DEX），至少有三种方式:</p><p>1、VM的JIT技术。优化后的文件放在/data/dalvik-cache目录下。这种方式在模拟器和eng模式下编译的系统中有效，只有这两种情况下操作dalvik-cache目录才不会有权限问题。</p><p>2、安装应用程序时，system installer做优化。这需要dalvik-cache目录的写权限。</p><p>3、编译系统源码时进行优化。这样优化不会修改jar/apk文件，但会对classes.dex进行优化，优化后的DEX与原文件放在同一个目录下一起写入system image。</p><p>系统中的/data/dalvik-cache目录属于system/system，权限是0771。存储在这个目录下的ODEX文件被system和应用程序所属的group拥有，权限是0644。DRM-locked的应用程序使用640权限。底线是你可以读你自己的DEX文件和其它的大多数应用程序，但不能创建、修改或删除它们。</p><p>使用JIT和system installer做DEX文件的Preparation要分成三步：</p><p>1、由system installer创建dalvik-cache文件夹，这个程序运行在有root权限的installd进程中。</p><p>2、classes.dex被解压出来，并在文件头部预留一些空间存放ODEX头信息。</p><p>3、为了方便使用和做一些针对特定系统的微调，把它mmap。比如byte-swapping，structure realigning等。我们还会做一些像文件偏移量和数据索引是否越界等方面的基本检查。</p><p>编译系统使用一个很复杂的流程来做这些事：启动模拟器，强制对所有相关DEX文件执行JIT优化，最后把优化后的结果从dalvik-cache中提取出来。之所以这样做而不是在PC上面使用一个工具来完成，在后面解释Optimization时可以看到原因。</p><p>当代码的byte-swapping和align完成时，我们的preparation就完成了。再做完verification和optimization，最后，我们就会把一些相关计算出来的信息添加到ODEX文件的头部然后开始执行。</p><p style="color:#3333FF;">dexopt</p><p>其实，如果我们想优化DEX中的类文件的话，最简单最安全的办法就是把所有类加载到VM中然后运行一遍，运行失败的就是没有verification和optimization的。但是，这样会分配一些很难释放的资源。比如，加载本地库时。所以，不能使用运行程序的那个VM来做。</p><p>我们的解决方案就是使用dexopt这个程序，它会初始化一个VM，加载DEX文件并执行verification和optimization过程。完成后，进程退出，释放所有资源。这个过程中，也可以多个VM使用同一个DEX。file lock会让dexopt只运行一次。</p><p style="color:#3333FF;">verification</p><p>字节码的verification过程涉及到每个DEX文件中的所有类和类中的所有方法中的指令。目标就是检查非法指令序列，这样做完以后，运行的时候就不必管了。这个过程中涉及到的许多计算也存在于GC过程中。</p><p>出于效率上的考虑，下一节提到的optimization会假设verification已经成功运行通过。默认情况下，dalvik会对所有类进行verification，而只对verification成功的类执行optimization。在进行verification过程中出现失败时，我们不一定会报告（比如在不同的包中调用一个作用范围为包内的类），我们会在执行时抛出一个异常。因为检查每个方法的访问权限很慢。</p><p>执行verification成功的类在ODEX文件中有一个flag set，当它们被加载时，就不会再进行verification。linux系统的安全机制会防止这个文件被破坏，但如果你能绕过去，还是能去破坏它的。ODEX文件有一个32-bit的checksum，但只能做一个快速检查。</p><p style="color:#3333FF;">Optimization</p><p>VM解释器在第一次运行一段代码时会做一些optimization。比如，把常量池引用替换成指向内部数据结构的指针，一些永远成功的操作或固定的代码被替换成更简单的形式。做这些optimization需要的信息有的只能在运行时得到，有的可以推断出来。</p><p>dalvik做的optimization包含下面这些：</p><p>1、对于虚方法的调用，把方法索引修改成vtable索引。</p><p>2、把field的get/put修改成字节偏移量。把boolean/byte/char/short等类型的变量合并到一个32-bit的形式，更少的代码可以更有效地利用CPU的I-cache。</p><p>3、把一些大量使用的简单方法进行inline，比如String.length()。这样能减少方法调用的开销。</p><p>4、删除空方法。</p><p>5、加入一些计算好的数据。比如，VM需要一个hash table来查找类名字，我们就可以在Optimization阶段进行计算，不用放到DEX加载的时候了。</p><p>所有的指令修改都是使用一个Dalvik标准没有定义的指令去替换原有指令。这样，我们就可以让优化和没有优化的指令自由搭配。具体的操作与VM版本有关。</p><p>Optimization过程有两个地方需要我们注意：</p><p>1、VM如果更新的话，vtable索引和字节偏移量可能会更新。</p><p>2、如果两个DEX互相信赖，而其中一个DEX更新的话，确保优化后的索引和偏移量有效。</p><p style="color:#3333FF;">Dependencies and Limitations</p><p>优化后的DEX会包含一个它信赖的DEX文件列表，并添加了CRC-32和修改时间。文件列表中包含了dalvik-cache目录下的文件的路径和相应的SHA-1签名。而文件在设备上的timestamp不可信也不能用。另外还有VM版本号。</p><p>如果当前DEX所依赖的DEX有更新，我们也需要更新当前DEX。如果我们可以做一个JIT的dexopt调用，更新过程很easy。但如果只能依赖installer daemon，或者这个DEX被装到ODEX中的话，VM只能拒绝它了。</p><p>dexopt的输出与平台版本，VM版本有关，想编写一个运行在PC上，而优化后的输出在其它设备使用的dexopt很难。因此，dexopt是在目标设备上或者目标设备的模拟器上运行。</p><p></p></div>

</DIV></DIV>

<DIV id=footer style="display:none">
<P align="center">  
 
 
 
    </P>
</DIV></BODY></HTML>

