
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>Android和大家分享几个重要的代码（一）_Android学习手册</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<META name=GENERATOR content="MSHTML 8.00.6001.18702">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">

</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li ><A href="../component/index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li ><A href="../device/index.html">设备功能</A> </li><li ><A href="../datastorage/index.html">数据存储</A> </li><li ><A href="../network/index.html">网络应用</A> </li><li ><A href="../game/index.html">游戏开发</A> </li><li ><A href="../multimedia/index.html">多媒体</A> </li><li ><A href="../source/index.html">源码开发</A> </li><li class="navcurrentLink"><A href="index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">课 程 表</div>


  <h2><A title="Android基础之运行原理和机制" href="index_215.html">Android基础之运行原理和机制</A></h2>

  <h2><A title="Android高级篇之Android优化" href="index_216.html">Android高级篇之Android优化</A></h2>
<UL><li ><A title=Android中View绘制优化之一 优化布局层次 href="show_101_216.html">Android中View绘制优化之一 优化布局层次</A> </li><li ><A title=Android中View绘制优化二 使用include 标签复用布局文件 href="show_102_216.html">Android中View绘制优化二 使用include 标签复用布局文件</A> </li><li ><A title=Android中View绘制优化之三 优化View href="show_103_216.html">Android中View绘制优化之三 优化View</A> </li><li ><A title=Android FrameLayou和布局优化（一） href="show_104_216.html">Android FrameLayou和布局优化（一）</A> </li><li ><A title=Android FrameLayou和布局优化（二） href="show_105_216.html">Android FrameLayou和布局优化（二）</A> </li><li ><A title=Android GridView视图缓存优化（一） href="show_106_216.html">Android GridView视图缓存优化（一）</A> </li><li ><A title=Android GridView视图缓存优化（二） href="show_107_216.html">Android GridView视图缓存优化（二）</A> </li><li ><A title=Android布局优化的要点 href="show_108_216.html">Android布局优化的要点</A> </li><li ><A title=Android 适配器（Adapter）优化 href="show_109_216.html">Android 适配器（Adapter）优化</A> </li><li ><A title=Android UI 优化 href="show_110_216.html">Android UI 优化</A> </li><li ><A title=Android 你的OnTouchEvent() 触屏事件的优化了吗 href="show_111_216.html">Android 你的OnTouchEvent() 触屏事件的优化了吗</A> </li><li ><A title=Android SQLite的查询优化（一） href="show_112_216.html">Android SQLite的查询优化（一）</A> </li><li ><A title=Android SQLite的查询优化（二） href="show_113_216.html">Android SQLite的查询优化（二）</A> </li><li ><A title=Android SQLite的查询优化（三） href="show_114_216.html">Android SQLite的查询优化（三）</A> </li><li ><A title=Android程序运行性能优化 href="show_115_216.html">Android程序运行性能优化</A> </li><li ><A title=Android代码性能优化技巧 href="show_116_216.html">Android代码性能优化技巧</A> </li><li ><A title=Android进程管理机制及优化 href="show_117_216.html">Android进程管理机制及优化</A> </li><li ><A title=Android应用开发者指南：性能优化 href="show_118_216.html">Android应用开发者指南：性能优化</A> </li><li ><A title=如何优化java代码 href="show_119_216.html">如何优化java代码</A> </li><li ><A title=Android Dalvik检查和优化.apk.jar的流程introduce href="show_120_216.html">Android Dalvik检查和优化.apk.jar的流程introduce</A> </li><li ><A title=ProGuard支持哪些种类的优化 href="show_121_216.html">ProGuard支持哪些种类的优化</A> </li><li class="currentLink"><A title=Android和大家分享几个重要的代码（一） href="show_122_216.html">Android和大家分享几个重要的代码（一）</A> </li><li ><A title=Android和大家分享几个重要的代码（二） href="show_123_216.html">Android和大家分享几个重要的代码（二）</A> </li></UL>
  <h2><A title="Android高级篇之编译及反编译" href="index_217.html">Android高级篇之编译及反编译</A></h2>

  <h2><A title="Android高级篇之加密解密" href="index_218.html">Android高级篇之加密解密</A></h2>

  <h2><A title="Android高级篇之Android 安全" href="index_219.html">Android高级篇之Android 安全</A></h2>

  <h2><A title="Android高级篇之算法" href="index_220.html">Android高级篇之算法</A></h2>

  <h2><A title="Android高级篇之解锁教程" href="index_221.html">Android高级篇之解锁教程</A></h2>

</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1></H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>Android和大家分享几个重要的代码（一）</H2>
<div style="line-height:20px; font-size:14px;"><p style="color:#3333FF;"> 1，设置静音和振动</p><p>静音和振动都属于来电后的动作.所以在设置静音和振动时都只是设置一些标识，并往数据库写入相应标识。</p><p>文件：packages/apps/settings/src/com/android/settings/SoundAndDisplaySettings.java</p><p><pre><font class="keyword">private </font>CheckBoxPreference mSilent;</p><p><font class="keyword">private </font>CheckBoxPreference mVibrate;</p><p><font class="keyword">private </font><font class="keyword">void </font>setRingerMode(</font><font class="keyword">boolean </font>silent, </font><font class="keyword">boolean </font>vibrate) {</p><p>	<font class="keyword">if </font>(silent) {</p><p>		mAudioManager</p><p>				.setRingerMode(vibrate ? AudioManager.RINGER_MODE_VIBRATE</p><p>						: AudioManager.RINGER_MODE_SILENT);</p><p>	</font>} <font class="keyword">else </font>{</p><p>		mAudioManager.setRingerMode(AudioManager.RINGER_MODE_NORMAL);</p><p>		mAudioManager.setVibrateSetting(AudioManager.VIBRATE_TYPE_RINGER,</p><p>				vibrate ? AudioManager.VIBRATE_SETTING_ON</p><p>						: AudioManager.VIBRATE_SETTING_OFF);</p><p>	}</p><p>}</p><p><font class="keyword">public </font><font class="keyword">boolean </font>onPreferenceTreeClick(PreferenceScreen preferenceScreen,</p><p>		Preference preference) {</p><p>	<font class="keyword">if </font>(preference == mSilent || preference == mVibrate) {</p><p>		setRingerMode(mSilent.isChecked(), mVibrate.isChecked());</p><p>		<font class="keyword">if </font>(preference == mSilent)</p><p>			</font>updateState(<font class="keyword">false</font>);</p><p>	}</p><p>}</p><p></pre></p><p>静音和振动是复选框按钮，两个中有一个发生变化时调用setRingerMode对状态进行设置；如下状态描术：</p><p>RINGER_MODE_SILENT 静音，且无振动。</p><p>RINGER_MODE_VIBRATE 静音，但有振动。</p><p>RINGER_MODE_NORMAL 正常声音，振动开关由setVibrateSetting决定。</p><p>铃响模式的设置是通过mAudioManager（音频管理器）来实现的。</p><p style="color:#3333FF;">2 音频管理器服务</p><p>mAudioManager所在服务如下：</p><p>文件：frameworks/base/media/java/android/media/AudioManager.java</p><p><pre><font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>RINGER_MODE_SILENT = 0;</p><p><font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>RINGER_MODE_VIBRATE = 1;</p><p><font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>RINGER_MODE_NORMAL = 2;</p><p><font class="keyword">public </font><font class="keyword">void </font>setRingerMode(</font><font class="keyword">int </font>ringerMode) {</p><p>	IAudioService service = getService();</p><p>	<font class="keyword">try </font>{</p><p>		service.setRingerMode(ringerMode);</p><p>	</font>} <font class="keyword">catch </font>(RemoteException e) {</p><p>		</font>Log.e(TAG, <font class="Fields">"Dead object in setRingerMode"</font>, e);</p><p>	}</p><p>}</p><p></pre></p><p>将铃响模式值传给音频接口服务IaudioService</p><p><pre><font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>VIBRATE_TYPE_RINGER = 0;</p><p><font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>VIBRATE_TYPE_NOTIFICATION = 1;</p><p><font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>VIBRATE_SETTING_OFF = 0;</p><p><font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>VIBRATE_SETTING_ON = 1;</p><p><font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>VIBRATE_SETTING_ONLY_SILENT = 2;</p><p><font class="keyword">public </font><font class="keyword">void </font>setVibrateSetting(</font><font class="keyword">int </font>vibrateTyp, </font><font class="keyword">int </font>vibrateSetting) {</p><p>	IAudioService service = getService();</p><p>	<font class="keyword">try </font>{</p><p>		service.setVibrateSetting(vibrateType, vibrateSetting);</p><p>	</font>} <font class="keyword">catch </font>(RemoteException e) {</p><p>		</font>Log.e(TAG, <font class="Fields">"Dead object in setVibrateSetting"</font>, e);</p><p>	}</p><p>}</p><p></pre></p><p>将振动类型和振动设置传给音频接口服务IaudioService,IaudioService的定义如下:</p><p>frameworks/base/media/java/android/media/IAudioService.aidl</p><p>frameworks/base/media/java/android/media/AudioService.java</p><p>文件: frameworks/base/media/java/android/media/AudioService.java</p><p>文件: frameworks/base/core/java/android/provider/Settings.java</p><p><pre><font class="keyword">public </font><font class="keyword">void </font>setRingerMode(</font><font class="keyword">int </font>ringerMode) {</p><p>	<font class="keyword">synchronized </font>(mSettingsLock) {</p><p>		<font class="keyword">if </font>(ringerMode != mRingerMode) {</p><p>			</font>setRingerModeInt(ringerMode, <font class="keyword">true</font>);</p><p>			<font class="Comments">// Send sticky broadcast</font></p><p>			broadcastRingerMode();</p><p>		}</p><p>	}</p><p>}</p><p></pre></p><p>将对应模式下的音量写入数据库,并将该模式广播。</p><p><pre><font class="keyword">public </font><font class="keyword">void </font>setVibrateSetting(</font><font class="keyword">int </font>vibrateType, </font><font class="keyword">int </font>vibrateSetting) {</p><p>	mVibrateSetting = getValueForVibrateSetting(mVibrateSetting,</p><p>			vibrateType, vibrateSetting);</p><p>	<font class="Comments">// Broadcast change</font></p><p>	broadcastVibrateSetting(vibrateType);</p><p>	<font class="Comments">// Post message to set ringer mode (it in turn will post a message</font></p><p>	<font class="Comments">// to persist)</font></p><p>	sendMsg(mAudioHandler, MSG_PERSIST_VIBRATE_SETTING, SHARED_MSG,</p><p>			</font>SENDMSG_NOOP, 0, 0, <font class="keyword">null</font>, 0);</p><p>}</p><p></pre></p><p>同样将振动模式写入数据库，并广播该模式。</p><p style="color:#3333FF;">3 硬件服务</p><p>文件：frameworks/base/services/java/com/android/server/HardwareService.java</p><p>开始振动：</p><p><pre><font class="keyword">public </font><font class="keyword">void </font>vibrate(</font><font class="keyword">long </font>milliseconds, IBinder token) {</p><p>	<font class="keyword">if </font>(mContext</p><p>			.checkCallingOrSelfPermission(android.Manifest.permission.VIBRATE) != PackageManager.PERMISSION_GRANTED) {</p><p>		<font class="keyword">throw </font><font class="keyword">new </font>SecurityException(<font class="Fields">"Requires VIBRATE permission"</font>);</p><p>	}</p><p>	<font class="Comments">// We're running in the system server so we cannot crash. Check for a</font></p><p>	<font class="Comments">// timeout of 0 or negative. This will ensure that a vibration has</font></p><p>	<font class="Comments">// either a timeout of &gt; 0 or a non-null pattern.</font></p><p>	<font class="keyword">if </font>(milliseconds &lt;= 0</p><p>			</font>|| (mCurrentVibration != <font class="keyword">null</font> && mCurrentVibration</p><p>					.hasLongerTimeout(milliseconds))) {</p><p>		<font class="Comments">// Ignore this vibration since the current vibration will play for</font></p><p>		<font class="Comments">// longer than milliseconds.</font></p><p>		<font class="keyword">return</font>;</font></p><p>	}</p><p>	</font>Vibration vib = <font class="keyword">new </font>Vibration(token, milliseconds);</p><p>	<font class="keyword">synchronized </font>(mVibrations) {</p><p>		removeVibrationLocked(token);</p><p>		doCancelVibrateLocked();</p><p>		mCurrentVibration = vib;</p><p>		startVibrationLocked(vib);</p><p>	}</p><p>}</p><p><font class="keyword">private </font><font class="keyword">void </font>startVibrationLocked(</font><font class="keyword">final </font>Vibration vib) {</p><p>	<font class="keyword">if </font>(vib.mTimeout != 0) {</p><p>		vibratorOn(vib.mTimeout);</p><p>		mH.postDelayed(mVibrationRunnable, vib.mTimeout);</p><p>	</font>} <font class="keyword">else </font>{</p><p>		<font class="Comments">// mThread better be null here. doCancelVibrate should always be</font></p><p>		<font class="Comments">// called before startNextVibrationLocked or startVibrationLocked.</font></p><p>		</font>mThread = <font class="keyword">new </font>VibrateThread(vib);</p><p>		mThread.start();</p><p>	}</p><p>}</p><p></pre></p><p>该接口允许设置振动的时间长度，通过调用vibratorOn(vib.mTimeout);实现对底层硬件的操作。</p><p>取消振动：</p><p><pre><font class="keyword">public </font><font class="keyword">void </font>cancelVibrate(IBinder token) {</p><p>	mContext.enforceCallingOrSelfPermission(</p><p>			</font>android.Manifest.permission.VIBRATE, <font class="Fields">"cancelVibrate"</font>);</p><p>	<font class="Comments">// so wakelock calls will succeed</font></p><p>	<font class="keyword">long </font>identity = Binder.clearCallingIdentity();</p><p>	<font class="keyword">try </font>{</p><p>		<font class="keyword">synchronized </font>(mVibrations) {</p><p>			<font class="keyword">final </font>Vibration vib = removeVibrationLocked(token);</p><p>			<font class="keyword">if </font>(vib == mCurrentVibration) {</p><p>				doCancelVibrateLocked();</p><p>				startNextVibrationLocked();</p><p>			}</p><p>		}</p><p>	} finally {</p><p>		Binder.restoreCallingIdentity(identity);</p><p>	}</p><p>}</p><p><font class="keyword">private </font><font class="keyword">void </font>doCancelVibrateLocked() {</p><p>	<font class="keyword">if </font>(mThread != </font><font class="keyword">null</font>) {</p><p>		<font class="keyword">synchronized </font>(mThread) {</p><p>			</font>mThread.mDone = <font class="keyword">true</font>;</p><p>			mThread.notify();</p><p>		}</p><p>		</font>mThread = <font class="keyword">null</font>;</p><p>	}</p><p>	vibratorOff();</p><p>	mH.removeCallbacks(mVibrationRunnable);</p><p>}</p><p></pre></p><p></p></div>

</DIV></DIV>

<DIV id=footer style="display:none">
<P align="center">  
 
 
 
    </P>
</DIV></BODY></HTML>

