
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>Android应用程序基本原理_Android学习手册</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<META name=GENERATOR content="MSHTML 8.00.6001.18702">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">

</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li ><A href="../component/index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li ><A href="../device/index.html">设备功能</A> </li><li ><A href="../datastorage/index.html">数据存储</A> </li><li ><A href="../network/index.html">网络应用</A> </li><li ><A href="../game/index.html">游戏开发</A> </li><li ><A href="../multimedia/index.html">多媒体</A> </li><li ><A href="../source/index.html">源码开发</A> </li><li class="navcurrentLink"><A href="index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">课 程 表</div>


  <h2><A title="Android基础之运行原理和机制" href="index_215.html">Android基础之运行原理和机制</A></h2>
<UL><li ><A title=Android设计平台原理 href="show_1_215.html">Android设计平台原理</A> </li><li class="currentLink"><A title=Android应用程序基本原理 href="show_2_215.html">Android应用程序基本原理</A> </li><li ><A title=图解Android应用程序构建原理 href="show_3_215.html">图解Android应用程序构建原理</A> </li><li ><A title=Android手机内存的运行机制 href="show_4_215.html">Android手机内存的运行机制</A> </li><li ><A title=Android开发之虚拟机原理与内存分配 href="show_5_215.html">Android开发之虚拟机原理与内存分配</A> </li><li ><A title=Android进程管理机制及优化 href="show_6_215.html">Android进程管理机制及优化</A> </li><li ><A title=Android消息处理系统原理 href="show_7_215.html">Android消息处理系统原理</A> </li><li ><A title=Android 调试原理 href="show_8_215.html">Android 调试原理</A> </li><li ><A title=Andoird GDI之基本原理及其总体框架 href="show_9_215.html">Andoird GDI之基本原理及其总体框架</A> </li></UL>
  <h2><A title="Android高级篇之Android优化" href="index_216.html">Android高级篇之Android优化</A></h2>

  <h2><A title="Android高级篇之编译及反编译" href="index_217.html">Android高级篇之编译及反编译</A></h2>

  <h2><A title="Android高级篇之加密解密" href="index_218.html">Android高级篇之加密解密</A></h2>

  <h2><A title="Android高级篇之Android 安全" href="index_219.html">Android高级篇之Android 安全</A></h2>

  <h2><A title="Android高级篇之算法" href="index_220.html">Android高级篇之算法</A></h2>

  <h2><A title="Android高级篇之解锁教程" href="index_221.html">Android高级篇之解锁教程</A></h2>

</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1></H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>Android应用程序基本原理</H2>
<div style="line-height:20px; font-size:14px;"><p>Android应用程序是用Java语言编写的。编译过后的字节码，以及应用程序要求的其他数据和资源文件，通过aapt工具被绑定在一起，称为 Android包，这是一个带.apk后缀的档案文件。这个文件也是用户下载到他们设备上的文件。所有的代码在一个单一的.apk文件中，组成一个“应用程序”。</p><p>从许多方面来说，每个Android应用程序存活在它们自己的世界中：</p><p>默认地，每一个应用程序运行在它自己的Linux进程中。当应用程序的任何代码需要被执行时，Android启动进程；当不再需要时，或者系统资源被其他应用程序所要求时，关闭进程。</p><p>每一个进程有它自己的Java虚拟机（JVM），因此应用程序代码独立与所有其他应用程序代码而运行。</p><p>默认地，每一个应用程序被分配一个唯一的Linux用户ID。通过设置权限许可，应用程序的文件只对该用户可见，只对应用程序本身可见，虽然有办法将其导出到其他应用程序。</p><p>有可能安排两个应用程序共享同一用户ID，在这种情况下，它们可以彼此看见对方的文件。要保全系统资源，具有相同ID的应用程序也可以被组织起来运行在同一Linux进程中，共享同一VM。</p><p style="color:#3333FF;">激活组件：intents</p><p>当一个请求来自一个ContentResolver时，内容提供器被激活。其他三个组件----activities，services和 broadcast receivers----被名为intents的异步消息所激活。一个intent是一个Intent对象，持有消息的内容。对于activities 和services来说，它意味着位于其他事物中被请求的动作和指定要操作的数据的URI。例如，它可能会为一个activity传送一个请求以代表给用户的一个图片，或者让用户编辑一些文本。对于broadcast receivers，Intent对象意味着被公告/通知的动作。例如，它可能会通告有兴趣的相关方，相机的按钮被按下了。</p><p style="color:#3333FF;">有各自的方法来用于激活每一类组件：</p><p>通过传递一个Intent对象到Context.startActivity()或Activity.startActivityForResult()，来启动一个activity（或者让做一些新的东西）。进行响应的activity可以通过调用其getIntent()方法来查看引起它被启动的原始内容（intent）。Android调用该activity的onNewIntent()方法来向其传递任何后续的intent。</p><p>一个activity经常启动下一个activity。如果它期望从它所启动的activity获得一个返回的结果，那么它就要调用startActivityForResult()而不是startActivity()。例如，如果它启动一个让用户挑选照片的activity，那么它可能期望返回被选中的照片。结果在一个Intent对象中被返回，而该Intent对象被传递给进行调用的activity的 onActivityResult()方法中。</p><p>通过传递一个Intent对象给Context.startService()，一个service被启动（或者一个新的指令传达给正在运行的service）。Android调用该service的onStart()方法并将Intent对象传递给它。相似地，将一个intent传递给Context.bindService()，能够在进行调用的组件和目标service之间建立一个持续的连接。该service在一个onBind()调用中接收该Intent对象。(如果该service还没有运行，bindService()能有选择地启动它。)例如，一个activity可能会与音乐播放服务建立一个连接，这样它就能向用户提供控制播放的方式（一个用户接口）。该activity将调用bindService()来建立这个连接，然后调用service所定义的方法来影响播放。</p><p>应用程序能通过传递一个Intent对象到诸如Context.sendBroadcast()，Context.sendOrderedBroadcast()，和Context.sendStickyBroadcast()这些方法中来创建一个广播。Android通过调用它们的onReceive()方法发布该 Intent到所有感兴趣的broadcast receivers。（更多有关Intent的信息，在稍后一节“Intents and Intent Filters”中会专门讲述）</p><p style="color:#3333FF;">停止组件</p><p>一个内容提供器只有当它在响应来自一个ContentResolver的请求时是活动的。一个广播接收器只有当它在响应一个广播消息时是活动的。因此没有必要显式地关闭这些组件。</p><p>另一方面，activities提供用户接口。它们与用户处于一个长时间运行的会话中，并且可能保存有active，甚至在空闲时，只要会话在继续。相似地，services也可能持续运行很长时间。因此Android有方法以一种有序的方式来关闭activities和services。</p><p>通过调用其finish()方法来关闭一个activity。一个activity可以通过调用finishActivity()来关闭另一个activity(它使用startActivityForResult()方法启动的activity)。</p><p>通过调用其stopSelf()方法来停止一个service，或者通过调用Context.stopService()。</p><p>当组件不再被使用时，或者当Android必须为更多活动的组件而收回内存时，它们有可能被系统所关闭。在后面“组件的生命周期”一节中，将讨论这种可能性及更多地细节。</p><p style="color:#3333FF;">manifest文件</p><p>在Android能启动一个应用程序组件之前，它必须知道组件的存在。因此，应用程序在一个manifest文件中声明它们的组件。manifest文件被绑定在一个Android包中。Android包是一个.apk文件，它还持有应用程序的代码、文件和资源。</p><p>manifest是结构化的XML文件，并且对所有的应用程序来说，它总是被命名为AndroidManifest.xml。除了声明应用程序的组件之外，它还做很多事情，如命名应用程序需要链接到的库（除了默认的Android库之外），以及应用程序所期望被授权的任何权限验证。</p><p>但是manifest的首要任务是告知Android关于应用程序的组件。例如，一个activity可能被声明如下的内容：</p><p><pre>&lt;?xml version=<font class="Fields">"1.0"</font> encoding=</font><font class="Fields">"utf-8"</font>?&gt;</p><p>&lt;manifest&gt;</p><p>    &lt;application&gt;</p><p>        &lt;activity</p><p>            </font>android:name=<font class="Fields">"com.example.project.FreneticActivity</p><p>            </font>android:icon=<font class="Fields">"@drawable/small_pic.png</p><p>            </font>android:label=<font class="Fields">"@string/freneticLabel"</font> &gt;</p><p>        &lt;/activity&gt;</p><p>    &lt;/application&gt;</p><p>&lt;/manifest&gt;</p><p></pre></p><p>在这个manifest文件中，元素&lt;activity&gt;的name属性命名实现了activity的Activity类的子类。而icon和label属性则指向包含有一个图标和标签的资源文件，这些图标和标签可以被显示给用户以代表这个activity。</p><p>另一个组件以相似的方式被声明--&lt;service&gt;元素声明services，&lt;receiver&gt;元素声明 broadcast receivers，以及&lt;provider&gt;元素声明内容提供器（content providers）。不在manifest文件中声明的activities，services和content providers对系统是不可见的，相应地永远不会运行。然而，broadcast receivers既可以在manifest文件中声明，也可以在代码中（如BroadcastReceiver对象）动态地创建并通过调用Context.registerReceiver()向系统注册。</p><p style="color:#3333FF;">Intent过滤器（Intent filters）</p><p>一个Intent对象能显式地命名一个目标组件。如果这样的话，Android会查找那个组件（基于在manifest文件中的声明）并激活它。但是如果一个目标组件没有被显式地命名，Android必须定位最合适的组件来响应该Intent。它通过对Intent对象和潜在目标的intent filters的比较来完成这种定位。一个组件的intent过滤器告知Android该组件能够处理的intent种类。象其他组件的基本信息一样，它们是在manifest文件中声明的。下面是前面示例代码的一个扩展，为activity添加了两个intent过滤器。</p><p><pre>&lt;?xml version=<font class="Fields">"1.0"</font> encoding=</font><font class="Fields">"utf-8"</font>?&gt;</p><p>&lt;manifest&gt;</p><p>    &lt;application&gt;</p><p>        &lt;activity</p><p>            </font>android:name=<font class="Fields">"com.example.project.FreneticActivity</p><p>            </font>android:icon=<font class="Fields">"@drawable/small_pic.png</p><p>            </font>android:label=<font class="Fields">"@string/freneticLabel"</font> &gt;</p><p>            &lt;intent-filter&gt;</p><p>                </font>&lt;action android:name=<font class="Fields">"android.intent.action.MAIN"</font> /&gt;</p><p>                </font>&lt;category android:name=<font class="Fields">"android.intent.category.LAUNCHER"</font> /&gt;</p><p>            &lt;/intent-filter&gt;</p><p>            &lt;intent-filter&gt;</p><p>                </font>&lt;action android:name=<font class="Fields">"com.example.project.BOUNCE"</font> /&gt;</p><p>                </font>&lt;data android:mimeType=<font class="Fields">"image/jpeg"</font> /&gt;</p><p>                </font>&lt;category android:name=<font class="Fields">"android.intent.category.DEFAULT"</font> /&gt;</p><p>            &lt;/intent-filter&gt;</p><p>        &lt;/activity&gt;</p><p>    &lt;/application&gt;</p><p>&lt;/manifest&gt;</p><p></pre></p><p>上面示例代码中的第一个过滤器—action“android.intent.action.MAIN”和category“android.intent.category.LAUNCHER”—是一个通用的过滤器。它使得activity成为在应用程序启动器中显示出来的应用程序之一。应用程序启动器指的是显示（列出）用户可以在设备上启动的应用程序的屏幕。换句话说，这个activity是应用程序的入口，是用户在启动器中选择应用程序时看得见的最初的一个。</p><p>第二个过滤器声明一个该activity可以在一个特定类型的数据上执行的动作。</p><p>一个组件可以拥有任何数量的intent过滤器，每一个都声明一套不同的功能。如果没有任何过滤器，那么它只能被组件作为目标显式命名的intents所激活。</p><p>对于在代码中创建和注册的一个broadcst receiver，intent过滤器是直接作为一个IntentFilter对象创建的。所有其他过滤器都是在manifest中建立的。</p><p></p></div>

</DIV></DIV>

<DIV id=footer style="display:none">
<P align="center">  
 
 
 
    </P>
</DIV></BODY></HTML>

