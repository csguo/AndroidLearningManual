
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>实例讲解Android中如何实现图片的异步加载功能_Android学习手册</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<META name=GENERATOR content="MSHTML 8.00.6001.18702">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">

</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li class="navcurrentLink"><A href="index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li ><A href="../device/index.html">设备功能</A> </li><li ><A href="../datastorage/index.html">数据存储</A> </li><li ><A href="../network/index.html">网络应用</A> </li><li ><A href="../game/index.html">游戏开发</A> </li><li ><A href="../multimedia/index.html">多媒体</A> </li><li ><A href="../source/index.html">源码开发</A> </li><li ><A href="../advance/index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">课 程 表</div>


  <h2><A title="Activity" href="index_112.html">Activity</A></h2>

  <h2><A title="Intent" href="index_113.html">Intent</A></h2>

  <h2><A title="Service" href="index_114.html">Service</A></h2>

  <h2><A title="Content Provider" href="index_115.html">Content Provider</A></h2>

  <h2><A title="BroadcastReceiver" href="index_116.html">BroadcastReceiver</A></h2>

  <h2><A title="AsyncTask" href="index_117.html">AsyncTask</A></h2>
<UL><li ><A title=Android 浅谈AsyncTask href="show_501_117.html">Android 浅谈AsyncTask</A> </li><li ><A title=AsyncTask在Android中的实现 href="show_502_117.html">AsyncTask在Android中的实现</A> </li><li ><A title=AsyncTask几点要注意的地方 href="show_503_117.html">AsyncTask几点要注意的地方</A> </li><li ><A title=AsyncTask代替Handler更改主线程UI显示 href="show_504_117.html">AsyncTask代替Handler更改主线程UI显示</A> </li><li class="currentLink"><A title=实例讲解Android中如何实现图片的异步加载功能 href="show_505_117.html">实例讲解Android中如何实现图片的异步加载功能</A> </li><li ><A title=一个异步任务AsyncTask的例子 href="show_506_117.html">一个异步任务AsyncTask的例子</A> </li></UL>
  <h2><A title="Handler" href="index_118.html">Handler</A></h2>

  <h2><A title="Thread" href="index_119.html">Thread</A></h2>

  <h2><A title="Permission" href="index_120.html">Permission</A></h2>

  <h2><A title="AIDL" href="index_121.html">AIDL</A></h2>

  <h2><A title="Json" href="index_122.html">Json</A></h2>

</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1></H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>实例讲解Android中如何实现图片的异步加载功能</H2>
<div style="line-height:20px; font-size:14px;"><p>Android开发当中，经常会碰到图片的异步加载问题（也叫延时加载，英文叫Lazyload）。图片的读取工作是个比较耗时的工作，如果还是从互联网读取图片资源就更加耗时。如果在主线程里处理的时间过长，就会引发着名的应用程序无响应的系统提示（ANR：Application Not Responding）。</p><p>本文通过一个名为Demo4FileManager的项目实例来讲解如何实现图片的异步加载功能。该应用的主要功能是列出SD卡下的所有目录和图片文件，用户也可以在此之上修改为读取网络图片的功能。异步加载的实现是通过AsyncTask类来实现的，首先通过一个叫FileLoadTask的类来加载当前目录下的目录或图片文件，在加载完目录或文件数据后，再去执行一个名为ImageLoadTask的类把当前目录下的图片资源解码并通知UI更新这些图片。下面我们一步一步来看看是怎么实现的。</p><p>1. 新建一个名为 FileItem.java 的类，封装了基本的目录、文件信息，并且实现Comparable接口，用于目录文件的排序。</p><p><pre><font class="keyword">public </font><font class="keyword">class </font>FileItem </font><font class="keyword">implements </font>Comparable&lt;FileItem&gt;{ </p><p>    <font class="keyword">private </font>String name;</p><p>    <font class="keyword">private </font>String path;</p><p>    <font class="keyword">private </font><font class="keyword">int </font>fileType;  <font class="Comments">//  0：文件，1：目录，2：上级目录</font></p><p>    <font class="keyword">private </font>Bitmap image;</p><p>     <font class="Comments">// 下面是get和set方法</font></p><p>    .......</p><p>    <font class="Comments">// 和其他文件比较</font></p><p>    <font class="keyword">public </font><font class="keyword">int </font>compareTo(FileItem another) {</p><p>        <font class="keyword">return </font><font class="keyword">this</font>.name.compareTo(another.getName()); </p><p>    }</p><p>}</p><p></pre></p><p>2. 新建一个名为 FileListActivity.java 的类。在该类里实现一个名为listFile的方法，功能就是列出指定目录下的文件。我们可以看到在检查SD卡的状态为插入后，就启动一个文件加载任务。</p><p><pre><font class="keyword">private </font><font class="keyword">void </font>listFile(String path){</p><p>	</font>Log.i(TAG, <font class="Fields">"listFile()"</font>);</p><p>	</font>Log.d(TAG, <font class="Fields">"path:"</font> + path);</p><p>	<font class="Comments">//  SD卡状态</font></p><p>	String status = Environment.getExternalStorageState();</p><p>	</font>Log.d(TAG, <font class="Fields">"status of sdcard:"</font> + status);</p><p>	<font class="keyword">if </font>(status.equals(Environment.MEDIA_MOUNTED)) {<font class="Comments">//mounted</font></p><p>		</font>task = <font class="keyword">new </font>FileLoadTask(</font><font class="keyword">this</font>, adapter);</p><p>		task.execute(path);</p><p>	}</p><p>}</p><p></pre></p><p>在onCreate方法里，加入listFile那个方法，缺省路径为 /sdcard。FileListAdapter为adapter类，这里就不详细介绍了，在附件里有。</p><p><pre><font class="keyword">private </font>FileLoadTask task;</p><p>@Override</p><p><font class="keyword">public </font><font class="keyword">void </font>onCreate(Bundle savedInstanceState) {</p><p>	<font class="keyword">super</font>.onCreate(savedInstanceState);</p><p>	setContentView(R.layout.file_list);</p><p>	</font>adapter = <font class="keyword">new </font>FileListAdapter(</font><font class="keyword">this</font>);</p><p>	fileList = (ListView) findViewById(R.id.fileList);</p><p>	</font>fileList.setOnItemClickListener(<font class="keyword">this</font>); <font class="Comments">//  点击item事件</font></p><p>	fileList.setAdapter(adapter);</p><p>	listFile(FileItem.ROOT_PATH);</p><p>}</p><p></pre></p><p>3. 新建一个名为 FileLoadTask.java 的类，用来异步加载指定目录下的文件或图片。</p><p><pre><font class="keyword">public </font><font class="keyword">class </font>FileLoadTask </font><font class="keyword">extends </font>AsyncTask&lt;String, FileItem, Void&gt; {</p><p>	<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">final </font>String TAG = FileLoadTask.</font><font class="keyword">class</font>.getSimpleName();</p><p>	<font class="keyword">private </font><font class="keyword">final </font><font class="keyword">static </font>FolderFilter folderFilter = </font><font class="keyword">new </font>FolderFilter();</p><p>	<font class="keyword">private </font><font class="keyword">final </font><font class="keyword">static </font>ImageFilter imageFilter = </font><font class="keyword">new </font>ImageFilter();</p><p>	<font class="keyword">private </font>Context context;</p><p>	<font class="keyword">private </font>FileListAdapter adapter;</p><p>	<font class="keyword">private </font>Bitmap folderIcon;</p><p>	<font class="keyword">private </font>Bitmap fileIcon;</p><p>	<font class="keyword">private </font>ImageLoadTask task;</p><p>	<font class="Comments">// 初始化</font></p><p>	<font class="keyword">public </font>FileLoadTask(Context context, FileListAdapter adapter) {</p><p>		</font>Log.i(TAG, <font class="Fields">"FileLoadTask()"</font>);</p><p></p><p>		<font class="keyword">this</font>.context = context;</p><p>		<font class="keyword">this</font>.adapter = adapter;</p><p>		folderIcon = BitmapFactory.decodeResource(context.getResources(),</p><p>				R.drawable.folder);</p><p>		fileIcon = BitmapFactory.decodeResource(context.getResources(),</p><p>				R.drawable.file);</p><p>	}</p><p>	@Override</p><p>	<font class="keyword">protected </font><font class="keyword">void </font>onPreExecute() {</p><p>		</font>Log.i(TAG, <font class="Fields">"onPreExecute()"</font>);</p><p>		<font class="Comments">// 在执行任务前，先把adapter里的数据清空</font></p><p>		adapter.clear();</p><p>	}</p><p>	@Override</p><p>	<font class="keyword">protected </font>Void doInBackground(String... path) {</p><p>		</font>Log.i(TAG, <font class="Fields">"doInBackground()"</font>);</p><p>		</font>File parent = <font class="keyword">new </font>File(path[0]);</p><p>		<font class="keyword">if </font>(parent.isDirectory()) {</p><p>			<font class="Comments">// 设置返回按钮</font></p><p>			<font class="keyword">if </font>(!path[0].equals(FileItem.ROOT_PATH)) {</p><p>				</font>FileItem root = <font class="keyword">new </font>FileItem();</p><p>				root.setName(FileItem.ROOT_NAME);</p><p>				root.setFileType(FileItem.FILE_ROOT);</p><p>				publishProgress(root);</p><p>			}</p><p>			<font class="Comments">// 获取当前目录下的子目录</font></p><p>			File[] files = parent.listFiles(folderFilter);</p><p>			Arrays.sort(files);</p><p>			<font class="keyword">for </font>(</font><font class="keyword">int </font>i = 0; i &lt; files.length; i++) {</p><p>				<font class="keyword">if </font>(isCancelled())</p><p>					<font class="keyword">return </font><font class="keyword">null</font>;</p><p></p><p>				File file = files;</p><p>				</font>FileItem bean = <font class="keyword">new </font>FileItem();</p><p>				bean.setName(file.getName());</p><p>				bean.setPath(file.getAbsolutePath());</p><p>				bean.setFileType(FileItem.FILE_DIR);</p><p>				publishProgress(bean); <font class="Comments">// 处理好一个目录，通知任务去更新UI</font></p><p>			}</p><p>			<font class="Comments">// 获取当前目录下的图片文件</font></p><p>			files = parent.listFiles(imageFilter);</p><p>			Arrays.sort(files);</p><p>			<font class="keyword">for </font>(</font><font class="keyword">int </font>i = 0; i &lt; files.length; i++) {</p><p>				<font class="keyword">if </font>(isCancelled())</p><p>					<font class="keyword">return </font><font class="keyword">null</font>;</p><p></p><p>				File file = files;</p><p>				</font>FileItem bean = <font class="keyword">new </font>FileItem();</p><p>				bean.setName(file.getName());</p><p>				bean.setPath(file.getAbsolutePath());</p><p>				bean.setFileType(FileItem.FILE_IMAGE);</p><p>				publishProgress(bean); <font class="Comments">// 处理好一个文件，通知任务去更新UI</font></p><p>			}</p><p>		}</p><p>		<font class="keyword">return </font><font class="keyword">null</font>;</p><p>	}</p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">void </font>onProgressUpdate(FileItem... files) {</p><p>		</font>Log.i(TAG, <font class="Fields">"onProgressUpdate()"</font>);</p><p>		<font class="keyword">if </font>(isCancelled())</p><p>			<font class="keyword">return</font>;</font></p><p></p><p>		<font class="Comments">// 收到要处理的类，根据目录或文件先设置缺省的图片</font></p><p>		FileItem bean = files[0];</p><p>		<font class="keyword">if </font>(bean.getFileType() == FileItem.FILE_IMAGE) {</p><p>			bean.setImage(fileIcon);</p><p>		</font>} <font class="keyword">else </font>{</p><p>			bean.setImage(folderIcon);</p><p>		}</p><p>		<font class="Comments">// 更新数据，列表会显示对应数据</font></p><p>		adapter.add(bean);</p><p>		adapter.notifyDataSetChanged();</p><p>	}</p><p>	@Override</p><p>	<font class="keyword">protected </font><font class="keyword">void </font>onPostExecute(Void result) {</p><p>		</font>Log.i(TAG, <font class="Fields">"onPostExecute()"</font>);</p><p></p><p>		<font class="Comments">// 启动图片加载任务</font></p><p>		<font class="keyword">if </font>(task != </font><font class="keyword">null</font> && task.getStatus() == AsyncTask.Status.RUNNING) {</p><p>			</font>task.cancel(<font class="keyword">true</font>);</p><p>		}</p><p>		</font>task = <font class="keyword">new </font>ImageLoadTask(context, adapter);</p><p>		task.execute();</p><p>	}</p><p>}</p><p></pre></p><p>4. 新建一个名为 ImageLoadTask.java 的类，用来加载图片资源。</p><p><pre><font class="keyword">public </font><font class="keyword">class </font>ImageLoadTask </font><font class="keyword">extends </font>AsyncTask&lt;Void, Void, Void&gt; {</p><p>	<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">final </font>String TAG = ImageLoadTask.</font><font class="keyword">class</font>.getSimpleName();</p><p>	<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">int </font>thumbnailWidth = 70;</p><p>	<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">int </font>thumbnailHeight = 100;</p><p>	<font class="keyword">private </font>FileListAdapter adapter;</p><p>	<font class="Comments">// 初始化</font></p><p>	<font class="keyword">public </font>ImageLoadTask(Context context, FileListAdapter adapter) {</p><p>		</font>Log.i(TAG, <font class="Fields">"ImageLoadTask()"</font>);</p><p>		<font class="keyword">this</font>.adapter = adapter;</p><p>	}</p><p>	@Override</p><p>	<font class="keyword">protected </font>Void doInBackground(Void... voids) {</p><p>		</font>Log.i(TAG, <font class="Fields">"doInBackground()"</font>);</p><p>		</font>BitmapFactory.Options ptions = <font class="keyword">new </font>BitmapFactory.Options();</p><p>		options.inSampleSize = 16;</p><p>		<font class="Comments">// 要处理的文件</font></p><p>		<font class="keyword">for </font>(</font><font class="keyword">int </font>i = 0; i &lt; adapter.getCount(); i++) {</p><p>			FileItem bean = adapter.getItem(i);</p><p>			<font class="keyword">if </font>(bean.getFileType() == FileItem.FILE_DIR) {</p><p>				<font class="keyword">continue</font>; <font class="Comments">// 非图片文件</font></p><p>			}</p><p>			<font class="keyword">try </font>{</p><p>				<font class="Comments">// 生成缩略图</font></p><p>				</font>options.inJustDecodeBounds = <font class="keyword">true</font>;</p><p>				options.outWidth = 0;</p><p>				options.outHeight = 0;</p><p>				options.inSampleSize = 1;</p><p>				BitmapFactory.decodeFile(bean.getPath(), options);</p><p>				<font class="keyword">if </font>(options.outWidth &gt; 0 && options.outHeight &gt; 0) {</p><p>					<font class="Comments">// Now see how much we need to scale it down.</font></p><p>					<font class="keyword">int </font>widthFactor = (options.outWidth + thumbnailWidth - 1)</p><p>							/ thumbnailWidth;</p><p>					<font class="keyword">int </font>heightFactor = (options.outHeight + thumbnailHeight - 1)</p><p>							/ thumbnailHeight;</p><p>					widthFactor = Math.max(widthFactor, heightFactor);</p><p>					widthFactor = Math.max(widthFactor, 1);</p><p></p><p>					<font class="Comments">// Now turn it into a power of two.</font></p><p>					<font class="keyword">if </font>(widthFactor &gt; 1) {</p><p>						<font class="keyword">if </font>((widthFactor & (widthFactor - 1)) != 0) {</p><p>							<font class="keyword">while </font>((widthFactor & (widthFactor - 1)) != 0) {</p><p>								widthFactor &= widthFactor - 1;</p><p>							}</p><p>							widthFactor &lt;&lt;= 1;</p><p>						}</p><p>					}</p><p>					options.inSampleSize = widthFactor;</p><p>					</font>options.inJustDecodeBounds = <font class="keyword">false</font>;</p><p>					Bitmap bitmap = BitmapFactory.decodeFile(bean.getPath(),</p><p>							options);</p><p>					<font class="keyword">if </font>(bitmap != </font><font class="keyword">null</font>) {</p><p>						bean.setImage(bitmap); <font class="Comments">// 读取到图片资源，加入到FileItem对象中</font></p><p>						publishProgress(); <font class="Comments">// 通知去更新UI</font></p><p>					}</p><p>				}</p><p>			</font>} <font class="keyword">catch </font>(Exception e) {</p><p>				<font class="Comments">// That's okay, guess it just wasn't a bitmap.</font></p><p>			}</p><p>		}</p><p>		<font class="keyword">return </font><font class="keyword">null</font>;</p><p>	}</p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">void </font>onProgressUpdate(Void... voids) {</p><p>		</font>Log.i(TAG, <font class="Fields">"onProgressUpdate()"</font>);</p><p>		<font class="keyword">if </font>(isCancelled())</p><p>			<font class="keyword">return</font>;</font></p><p>		<font class="Comments">// 更新UI</font></p><p>		adapter.notifyDataSetChanged();</p><p>	}</p><p>}</p><p></pre></p><p></p></div>

</DIV></DIV>

<DIV id=footer style="display:none">
<P align="center">  
 
 
 
    </P>
</DIV></BODY></HTML>

