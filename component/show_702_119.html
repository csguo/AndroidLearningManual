
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>Android 线程学习_Android学习手册</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<META name=GENERATOR content="MSHTML 8.00.6001.18702">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">

</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li class="navcurrentLink"><A href="index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li ><A href="../device/index.html">设备功能</A> </li><li ><A href="../datastorage/index.html">数据存储</A> </li><li ><A href="../network/index.html">网络应用</A> </li><li ><A href="../game/index.html">游戏开发</A> </li><li ><A href="../multimedia/index.html">多媒体</A> </li><li ><A href="../source/index.html">源码开发</A> </li><li ><A href="../advance/index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">课 程 表</div>


  <h2><A title="Activity" href="index_112.html">Activity</A></h2>

  <h2><A title="Intent" href="index_113.html">Intent</A></h2>

  <h2><A title="Service" href="index_114.html">Service</A></h2>

  <h2><A title="Content Provider" href="index_115.html">Content Provider</A></h2>

  <h2><A title="BroadcastReceiver" href="index_116.html">BroadcastReceiver</A></h2>

  <h2><A title="AsyncTask" href="index_117.html">AsyncTask</A></h2>

  <h2><A title="Handler" href="index_118.html">Handler</A></h2>

  <h2><A title="Thread" href="index_119.html">Thread</A></h2>
<UL><li ><A title=线程的基础知识 href="show_701_119.html">线程的基础知识</A> </li><li class="currentLink"><A title=Android 线程学习 href="show_702_119.html">Android 线程学习</A> </li><li ><A title=Android开发之旅：进程与线程 href="show_703_119.html">Android开发之旅：进程与线程</A> </li><li ><A title=线程和进程的区别 href="show_704_119.html">线程和进程的区别</A> </li><li ><A title=创建线程的两种方式 href="show_705_119.html">创建线程的两种方式</A> </li><li ><A title=Android 线程间的通信 href="show_706_119.html">Android 线程间的通信</A> </li><li ><A title=Android线程间通信的Message机制 href="show_707_119.html">Android线程间通信的Message机制</A> </li><li ><A title=Activity与Thread之间的通讯 href="show_708_119.html">Activity与Thread之间的通讯</A> </li><li ><A title=Android 线程交互+修改Button样式（一） href="show_709_119.html">Android 线程交互+修改Button样式（一）</A> </li><li ><A title=Android 线程交互+修改Button样式（二） href="show_710_119.html">Android 线程交互+修改Button样式（二）</A> </li><li ><A title=Android 多线程下载 href="show_711_119.html">Android 多线程下载</A> </li></UL>
  <h2><A title="Permission" href="index_120.html">Permission</A></h2>

  <h2><A title="AIDL" href="index_121.html">AIDL</A></h2>

  <h2><A title="Json" href="index_122.html">Json</A></h2>

</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1></H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>Android 线程学习</H2>
<div style="line-height:20px; font-size:14px;"><p style="color:#3333FF;">1. 单线程模型</p><p>当一个程序第一次启动时，Android会同时启动一个对应的主线程（Main Thread），主线程主要负责处理与UI相关的事件，如用户的按键事件，用户接触屏幕的事件以及屏幕绘图事件，并把相关的事件分发到对应的组件进行处理。所以主线程通常又被叫做UI线程。在开发Android应用时必须遵守单线程模型的原则： Android UI操作并不是线程安全的并且这些操作必须在UI线程中执行。</p><p style="color:#3333FF;">1.1 子线程更新UI</p><p>Android的UI是单线程(Single-threaded)的。为了避免拖住GUI，一些较费时的对象应该交给独立的线程去执行。如果幕后的线程来执行UI对象，Android就会发出错误讯息CalledFromWrongThreadException。以后遇到这样的异常抛出时就要知道怎么回事了！</p><p style="color:#3333FF;">1.2 Message Queue</p><p>在单线程模型下，为了解决类似的问题，Android设计了一个Message Queue(消息队列)， 线程间可以通过该Message Queue并结合Handler和Looper组件进行信息交换。下面将对它们进行分别介绍：</p><p style="color:#3333FF;">1. Message</p><p>Message消息，理解为线程间交流的信息，处理数据后台线程需要更新UI，则发送Message内含一些数据给UI线程。</p><p style="color:#3333FF;">2. Handler</p><p>Handler处理者，是Message的主要处理者，负责Message的发送，Message内容的执行处理。后台线程就是通过传进来的Handler对象引用来sendMessage(Message)。而使用Handler，需要implement 该类的 handleMessage(Message)方法，它是处理这些Message的操作内容，例如Update UI。通常需要子类化Handler来实现handleMessage方法。</p><p style="color:#3333FF;">3. Message Queue</p><p>Message Queue消息队列，用来存放通过Handler发布的消息，按照先进先出执行。</p><p>每个message queue都会有一个对应的Handler。Handler会向message queue通过两种方法发送消息：sendMessage或post。这两种消息都会插在message queue队尾并按先进先出执行。但通过这两种方法发送的消息执行的方式略有不同：通过sendMessage发送的是一个message对象,会被Handler的handleMessage()函数处理；而通过post方法发送的是一个runnable对象，则会自己执行。</p><p style="color:#3333FF;">4. Looper</p><p>Looper是每条线程里的Message Queue的管家。Android没有Global的Message Queue，而Android会自动替主线程(UI线程)建立Message Queue，但在子线程里并没有建立Message Queue。所以调用Looper.getMainLooper()得到的主线程的Looper不为NULL，但调用Looper.myLooper()得到当前线程的Looper就有可能为NULL。</p><p>对于子线程使用Looper，API Doc提供了正确的使用方法：</p><p><pre><font class="keyword">class </font>LooperThread </font><font class="keyword">extends </font>Thread {</p><p>	<font class="keyword">public </font>Handler mHandler;</p><p>	<font class="keyword">public </font><font class="keyword">void </font>run() {</p><p>		Looper.prepare(); <font class="Comments">// 创建本线程的Looper并创建一个MessageQueue</font></p><p>		</font>mHandler = <font class="keyword">new </font>Handler() {</p><p>			<font class="keyword">public </font><font class="keyword">void </font>handleMessage(Message msg) {</p><p>				<font class="Comments">// process incoming messages here</font></p><p>			}</p><p>		};</p><p>		Looper.loop(); <font class="Comments">// 开始运行Looper,监听Message Queue</font></p><p>	}</p><p>}</p><p></pre></p><p>这个Message机制的大概流程：</p><p>1. 在Looper.loop()方法运行开始后，循环地按照接收顺序取出Message Queue里面的非NULL的Message。</p><p>2. 一开始Message Queue里面的Message都是NULL的。当Handler.sendMessage(Message)到Message Queue，该函数里面设置了那个Message对象的target属性是当前的Handler对象。随后Looper取出了那个Message，则调用该Message的target指向的Hander的dispatchMessage函数对Message进行处理。</p><p>在dispatchMessage方法里，如何处理Message则由用户指定，三个判断，优先级从高到低：</p><p>1) Message里面的Callback，一个实现了Runnable接口的对象，其中run函数做处理工作；</p><p>2) Handler里面的mCallback指向的一个实现了Callback接口的对象，由其handleMessage进行处理；</p><p>3) 处理消息Handler对象对应的类继承并实现了其中handleMessage函数，通过这个实现的handleMessage函数处理消息。</p><p>由此可见，我们实现的handleMessage方法是优先级最低的！</p><p>3. Handler处理完该Message (update UI) 后，Looper则设置该Message为NULL，以便回收！</p><p>在网上有很多文章讲述主线程和其他子线程如何交互，传送信息，最终谁来执行处理信息之类的，个人理解是最简单的方法——判断Handler对象里面的Looper对象是属于哪条线程的，则由该线程来执行！</p><p>1. 当Handler对象的构造函数的参数为空，则为当前所在线程的Looper；</p><p>2. Looper.getMainLooper()得到的是主线程的Looper对象，Looper.myLooper()得到的是当前线程的Looper对象。</p><p>1.3 AsyncTask版：</p><p><pre><font class="keyword">import </font>java.util.ArrayList;</p><p><font class="keyword">import </font>android.R;</p><p><font class="keyword">import </font>android.app.Dialog;</p><p><font class="keyword">import </font>android.app.ListActivity;</p><p><font class="keyword">import </font>android.app.ProgressDialog;</p><p><font class="keyword">import </font>android.os.Bundle;</p><p><font class="keyword">import </font>android.os.Handler;</p><p><font class="keyword">import </font>android.os.Message;</p><p><font class="keyword">import </font>android.view.View;</p><p><font class="keyword">import </font>android.widget.ArrayAdapter;</p><p><font class="keyword">import </font>android.widget.Button;</p><p><font class="keyword">public </font><font class="keyword">class </font>ListProgressDemo </font><font class="keyword">extends </font>ListActivity {</p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">void </font>onCreate(Bundle savedInstanceState) {</p><p>		<font class="keyword">super</font>.onCreate(savedInstanceState);</p><p>		setContentView(R.layout.listprogress);</p><p>		((Button) findViewById(R.id.load_Handler))</p><p>				</font>.setOnClickListener(<font class="keyword">new </font>View.OnClickListener() {</p><p>					<font class="keyword">public </font><font class="keyword">void </font>onClick(View view) {</p><p>						</font>data = <font class="keyword">null</font>;</p><p>						</font>data = <font class="keyword">new </font>ArrayList&lt;String&gt;();</p><p>						</font>adapter = <font class="keyword">null</font>;</p><p>						showDialog(PROGRESS_DIALOG);</p><p>						<font class="keyword">new </font>ProgressThread(handler, data).start();</p><p>					}</p><p>				});</p><p>	}</p><p>	@Override</p><p>	<font class="keyword">protected </font>Dialog onCreateDialog(</font><font class="keyword">int </font>id) {</p><p>		<font class="keyword">switch </font>(id) {</p><p>		<font class="keyword">case </font>PROGRESS_DIALOG:</p><p>			<font class="keyword">return </font>ProgressDialog.show(</font><font class="keyword">this</font>, <font class="Fields">""</font>, </font><font class="Fields">"Loading. Please wait..."</font>,</p><p>					<font class="keyword">true</font>);</p><p>		<font class="keyword">default</font>:</p><p>			<font class="keyword">return </font><font class="keyword">null</font>;</p><p>		}</p><p>	}</p><p>}</p><p><font class="keyword">private </font><font class="keyword">class </font>ProgressThread </font><font class="keyword">extends </font>Thread {</p><p>	<font class="keyword">private </font>Handler handler;</p><p>	<font class="keyword">private </font>ArrayList&lt;String&gt; data;</p><p>	<font class="keyword">public </font>ProgressThread(Handler handler, ArrayList&lt;String&gt; data) {</p><p>		<font class="keyword">this</font>.handler = handler;</p><p>		<font class="keyword">this</font>.data = data;</p><p>	}</p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">void </font>run() {</p><p>		<font class="keyword">for </font>(</font><font class="keyword">int </font>i = 0; i &lt; 8; i++) {</p><p>			</font>data.add(<font class="Fields">"ListItem"</font>); <font class="Comments">// 后台数据处理</font></p><p>			<font class="keyword">try </font>{</p><p>				Thread.sleep(100);</p><p>			</font>} <font class="keyword">catch </font>(InterruptedException e) {</p><p>				Message msg = handler.obtainMessage();</p><p>				</font>Bundle b = <font class="keyword">new </font>Bundle();</p><p>				</font>b.putInt(<font class="Fields">"state"</font>, STATE_ERROR);</p><p>				msg.setData(b);</p><p>				handler.sendMessage(msg);</p><p>			}</p><p>			Message msg = handler.obtainMessage();</p><p>			</font>Bundle b = <font class="keyword">new </font>Bundle();</p><p>			</font>b.putInt(<font class="Fields">"state"</font>, STATE_FINISH);</p><p>			msg.setData(b);</p><p>			handler.sendMessage(msg);</p><p>		}</p><p>	} <font class="Comments">// 此处甚至可以不需要设置Looper，因为Handler默认就使用当前线程的Looper</font></p><p>	<font class="keyword">private </font><font class="keyword">final </font>Handler handler = </font><font class="keyword">new </font>Handler(Looper.getMainLooper()) {</p><p>		<font class="keyword">public </font><font class="keyword">void </font>handleMessage(Message msg) { <font class="Comments">// 处理Message，更新ListView</font></p><p>			<font class="keyword">int </font>state = msg.getData().getInt(<font class="Fields">"state"</font>);</p><p>			<font class="keyword">switch </font>(state) {</p><p>			<font class="keyword">case </font>STATE_FINISH:</p><p>				dismissDialog(PROGRESS_DIALOG);</p><p>				</font>Toast.makeText(getApplicationContext(), <font class="Fields">"加载完成!"</font>,</p><p>						Toast.LENGTH_LONG).show();</p><p>				</font>adapter = <font class="keyword">new </font>ArrayAdapter&lt;String&gt;(getApplicationContext(),</p><p>						android.R.layout.simple_list_item_1, data);</p><p>				setListAdapter(adapter);</p><p>				<font class="keyword">break</font>;</p><p>			<font class="keyword">case </font>STATE_ERROR:</p><p>				dismissDialog(PROGRESS_DIALOG);</p><p>				</font>Toast.makeText(getApplicationContext(), <font class="Fields">"处理过程发生错误!"</font>,</p><p>						Toast.LENGTH_LONG).show();</p><p>				</font>adapter = <font class="keyword">new </font>ArrayAdapter&lt;String&gt;(getApplicationContext(),</p><p>						android.R.layout.simple_list_item_1, data);</p><p>				setListAdapter(adapter);</p><p>				<font class="keyword">break</font>;</p><p>			<font class="keyword">default</font>:</p><p>			}</p><p>		}</p><p>	};</p><p>	<font class="keyword">private </font>ArrayAdapter&lt;String&gt; adapter;</p><p>	<font class="keyword">private </font>ArrayList&lt;String&gt; data;</p><p>	<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>PROGRESS_DIALOG = 1;</p><p>	<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>STATE_FINISH = 1;</p><p>	<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>STATE_ERROR = -1;</p><p>}</p><p></pre></p><p>Android另外提供了一个工具类：AsyncTask。它使得UI thread的使用变得异常简单。它使创建需要与用户界面交互的长时间运行的任务变得更简单，不需要借助线程和Handler即可实现。</p><p>1) 子类化AsyncTask。</p><p>2) 实现AsyncTask中定义的下面一个或几个方法。</p><p>onPreExecute() 开始执行前的准备工作；</p><p>doInBackground(Params...) 开始执行后台处理，可以调用publishProgress方法来更新实时的任务进度；</p><p>onProgressUpdate(Progress...)  在publishProgress方法被调用后，UI thread将调用这个方法从而在界面上展示任务的进展情况，例如通过一个进度条进行展示。</p><p>onPostExecute(Result) 执行完成后的操作，传送结果给UI 线程。</p><p>这4个方法都不能手动调用。而且除了doInBackground(Params...)方法，其余3个方法都是被UI线程所调用的，所以要求：</p><p>1) AsyncTask的实例必须在UI thread中创建；</p><p>2) AsyncTask.execute方法必须在UI thread中调用；</p><p>同时要注意：该task只能被执行一次，否则多次调用时将会出现异常。而且是不能手动停止的，这一点要注意，看是否符合你的需求！</p><p>在使用过程中，发现AsyncTask的构造函数的参数设置需要看明白：AsyncTask&lt;Params, Progress, Result&gt;</p><p>Params对应doInBackground(Params...)的参数类型。而new AsyncTask().execute(Params... params)，就是传进来的Params数据，你可以execute(data)来传送一个数据，或者execute(data1, data2, data3)这样多个数据。</p><p>Progress对应onProgressUpdate(Progress...)的参数类型；</p><p>Result对应onPostExecute(Result)的参数类型。</p><p>当以上的参数类型都不需要指明某个时，则使用Void，注意不是void。不明白的可以参考上面的例子，或者API Doc里面的例子。</p><p></p></div>

</DIV></DIV>

<DIV id=footer style="display:none">
<P align="center">  
 
 
 
    </P>
</DIV></BODY></HTML>

