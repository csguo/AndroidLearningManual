
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>Android线程间通信的Message机制_Android学习手册</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<META name=GENERATOR content="MSHTML 8.00.6001.18702">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">

</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li class="navcurrentLink"><A href="index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li ><A href="../device/index.html">设备功能</A> </li><li ><A href="../datastorage/index.html">数据存储</A> </li><li ><A href="../network/index.html">网络应用</A> </li><li ><A href="../game/index.html">游戏开发</A> </li><li ><A href="../multimedia/index.html">多媒体</A> </li><li ><A href="../source/index.html">源码开发</A> </li><li ><A href="../advance/index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">课 程 表</div>


  <h2><A title="Activity" href="index_112.html">Activity</A></h2>

  <h2><A title="Intent" href="index_113.html">Intent</A></h2>

  <h2><A title="Service" href="index_114.html">Service</A></h2>

  <h2><A title="Content Provider" href="index_115.html">Content Provider</A></h2>

  <h2><A title="BroadcastReceiver" href="index_116.html">BroadcastReceiver</A></h2>

  <h2><A title="AsyncTask" href="index_117.html">AsyncTask</A></h2>

  <h2><A title="Handler" href="index_118.html">Handler</A></h2>

  <h2><A title="Thread" href="index_119.html">Thread</A></h2>
<UL><li ><A title=线程的基础知识 href="show_701_119.html">线程的基础知识</A> </li><li ><A title=Android 线程学习 href="show_702_119.html">Android 线程学习</A> </li><li ><A title=Android开发之旅：进程与线程 href="show_703_119.html">Android开发之旅：进程与线程</A> </li><li ><A title=线程和进程的区别 href="show_704_119.html">线程和进程的区别</A> </li><li ><A title=创建线程的两种方式 href="show_705_119.html">创建线程的两种方式</A> </li><li ><A title=Android 线程间的通信 href="show_706_119.html">Android 线程间的通信</A> </li><li class="currentLink"><A title=Android线程间通信的Message机制 href="show_707_119.html">Android线程间通信的Message机制</A> </li><li ><A title=Activity与Thread之间的通讯 href="show_708_119.html">Activity与Thread之间的通讯</A> </li><li ><A title=Android 线程交互+修改Button样式（一） href="show_709_119.html">Android 线程交互+修改Button样式（一）</A> </li><li ><A title=Android 线程交互+修改Button样式（二） href="show_710_119.html">Android 线程交互+修改Button样式（二）</A> </li><li ><A title=Android 多线程下载 href="show_711_119.html">Android 多线程下载</A> </li></UL>
  <h2><A title="Permission" href="index_120.html">Permission</A></h2>

  <h2><A title="AIDL" href="index_121.html">AIDL</A></h2>

  <h2><A title="Json" href="index_122.html">Json</A></h2>

</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1></H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>Android线程间通信的Message机制</H2>
<div style="line-height:20px; font-size:14px;"><p style="color:#3333FF;">1.1.Message</p><p>代码在frameworks\base\core\java\android\Os\Message.java中。</p><p>Message.obtain函数：有多个obtain函数，主要功能一样，只是参数不一样。作用是从Message Pool中取出一个Message，如果Message Pool中已经没有Message可取则新建一个Message返回，同时用对应的参数给得到的Message对象赋值。</p><p>Message Pool：大小为10个；通过Message.mPool-&gt;（Message并且Message.next）-&gt;（Message并且Message.next）-&gt;（Message并且Message.next）...构造一个Message Pool。Message Pool的第一个元素直接new出来，然后把Message.mPool（static类的static变量）指向它。其他的元素都是使用完的Message通过Message的recycle函数清理后放到Message Pool（通过Message Pool最后一个Message的next指向需要回收的Message的方式实现）。下图为Message Pool的结构：</p><p style="color:#3333FF;">11.2.MessageQueue</p><p>MessageQueue里面有一个收到的Message的对列：</p><p>MessageQueue.mMessages(static变量)-&gt;( Message并且Message.next)-&gt; ( Message并且Message.next)-&gt;...，下图为接收消息的消息队列：</p><p>上层代码通过Handler的sendMessage等函数放入一个message到MessageQueue里面时最终会调用MessageQueue的enqueueMessage函数。enqueueMessage根据上面的接收的Message的队列的构造把接收到的Message放入队列中。</p><p>MessageQueue的removeMessages函数根据上面的接收的Message的队列的构造把接收到的Message从队列中删除，并且调用对应Message对象的recycle函数把不用的Message放入Message Pool中。</p><p style="color:#3333FF;">11.3.Looper</p><p>Looper对象的创建是通过prepare函数，而且每一个Looper对象会和一个线程关联</p><p><pre><font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">void </font>prepare() {</p><p>	<font class="keyword">if </font>(sThreadLocal.get() != </font><font class="keyword">null</font>) {</p><p>		<font class="keyword">throw </font><font class="keyword">new </font>RuntimeException(</p><p>				<font class="Fields">"Only one Looper may be created per thread"</font>);</p><p>	}</p><p>	</font>sThreadLocal.set(<font class="keyword">new </font>Looper());</p><p>}</p><p></pre></p><p>Looper对象创建时会创建一个MessageQueue，主线程默认会创建一个Looper从而有MessageQueue，其他线程默认是没有 MessageQueue的不能接收Message，如果需要接收Message则需要通过prepare函数创建一个MessageQueue。具体操作请见示例代码。</p><p><pre><font class="keyword">private </font>Looper() {</p><p>	</font>mQueue = <font class="keyword">new </font>MessageQueue();</p><p>	</font>mRun = <font class="keyword">true</font>;</p><p>	mThread = Thread.currentThread();</p><p>}</p><p></pre></p><p>prepareMainLooper函数只给主线程调用（系统处理，程序员不用处理），它会调用prepare建立Looper对象和MessageQueue。</p><p><pre><font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">void </font>prepareMainLooper() {</p><p>	prepare();</p><p>	setMainLooper(myLooper());</p><p>	<font class="keyword">if </font>(Process.supportsProcesses()) {</p><p>		</font>myLooper().mQueue.mQuitAllowed = <font class="keyword">false</font>;</p><p>	}</p><p>}</p><p></pre></p><p>Loop函数从MessageQueue中从前往后取出Message，然后通过Handler的dispatchMessage函数进行消息的处理（可见消息的处理是Handler负责的），消息处理完了以后通过Message对象的recycle函数放到Message Pool中，以便下次使用，通过Pool的处理提供了一定的内存管理从而加速消息对象的获取。至于需要定时处理的消息如何做到定时处理，请见 MessageQueue的next函数，它在取Message来进行处理时通过判断MessageQueue里面的Message是否符合时间要求来决定是否需要把Message取出来做处理，通过这种方式做到消息的定时处理。</p><p><pre>  </p><p><font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">void </font>loop() {</p><p>	Looper me = myLooper();</p><p>	MessageQueue queue = me.mQueue;</p><p>	<font class="keyword">while </font>(</font><font class="keyword">true</font>) {</p><p>		Message msg = queue.next(); <font class="Comments">// might block</font></p><p>		<font class="Comments">// if (!me.mRun) {</font></p><p>		<font class="Comments">// break;</font></p><p>		<font class="Comments">// }</font></p><p>		<font class="keyword">if </font>(msg != </font><font class="keyword">null</font>) {</p><p>			<font class="keyword">if </font>(msg.target == </font><font class="keyword">null</font>) {</p><p>				<font class="Comments">// No target is a magic identifier for the quit message</font></p><p>				<font class="keyword">return</font>;</font></p><p>			}</p><p></p><p>			<font class="keyword">if </font>(me.mLogging != </font><font class="keyword">null</font>)</p><p>				</font>me.mLogging.println(<font class="Fields">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</font> + msg.target</p><p>						</font>+ <font class="Fields">" "</font> + msg.callback + </font><font class="Fields">": "</font> + msg.what);</p><p>			msg.target.dispatchMessage(msg);</p><p>			<font class="keyword">if </font>(me.mLogging != </font><font class="keyword">null</font>)</p><p>				</font>me.mLogging.println(<font class="Fields">"&lt;&lt;&lt;&lt;&lt; Finished to"</font> + msg.target + </font><font class="Fields">"</p><p>						+ msg.callback);</p><p>			msg.recycle();</p><p>		}</p><p>	}</p><p>}</p><p></pre></p><p style="color:#3333FF;">11.4.Handler</p><p>Handler的构造函数表示Handler会有成员变量指向Looper和MessageQueue，后面我们会看到没什么需要这些引用；至于callback是实现了Callback接口的对象，后面会看到这个对象的作用。</p><p><pre> </p><p><font class="keyword">public </font>Handler(Looper looper, Callback callback) {</p><p>	mLooper = looper;</p><p>	mQueue = looper.mQueue;</p><p>	mCallback = callback;</p><p>}</p><p><font class="keyword">public </font><font class="keyword">interface </font>Callback {</p><p>	<font class="keyword">public </font><font class="keyword">boolean </font>handleMessage(Message msg);</p><p>}</p><p></pre></p><p>获取消息：直接通过Message的obtain方法获取一个Message对象。</p><p><pre> </p><p><font class="keyword">public </font><font class="keyword">final </font>Message obtainMessage(</font><font class="keyword">int </font>what, </font><font class="keyword">int </font>arg1, </font><font class="keyword">int </font>arg2, Object obj) {</p><p>	<font class="keyword">return </font>Message.obtain(</font><font class="keyword">this</font>, what, arg1, arg2, obj);</p><p>}</p><p></pre></p><p>发送消息：通过MessageQueue的enqueueMessage把Message对象放到MessageQueue的接收消息队列中</p><p><pre> </p><p><font class="keyword">public </font><font class="keyword">boolean </font>sendMessageAtTime(Message msg, </font><font class="keyword">long </font>uptimeMillis) {</p><p>	<font class="keyword">boolean </font>sent = </font><font class="keyword">false</font>;</p><p>	MessageQueue queue = mQueue;</p><p>	<font class="keyword">if </font>(queue != </font><font class="keyword">null</font>) {</p><p>		</font>msg.target = <font class="keyword">this</font>;</p><p>		sent = queue.enqueueMessage(msg, uptimeMillis);</p><p>	</font>} <font class="keyword">else </font>{</p><p>		</font>RuntimeException e = <font class="keyword">new </font>RuntimeException(</font><font class="keyword">this</font></p><p>				</font>+ <font class="Fields">" sendMessageAtTime() called with no mQueue"</font>);</p><p>		</font>Log.w(<font class="Fields">"Looper"</font>, e.getMessage(), e);</p><p>	}</p><p>	<font class="keyword">return </font>sent;</p><p>}</p><p></pre></p><p>线程如何处理MessageQueue中接收的消息：在Looper的loop函数中循环取出MessageQueue的接收消息队列中的消息，然后调用Hander的dispatchMessage函数对消息进行处理，至于如何处理（相应消息）则由用户指定（三个方法，优先级从高到低：Message里面的Callback，一个实现了Runnable接口的对象，其中run函数做处理工作；Handler里面的mCallback指向的一个实现了Callback接口的对象，里面的handleMessage进行处理；处理消息Handler对象对应的类继承并实现了其中handleMessage函数，通过这个实现的handleMessage函数处理消息）。</p><p><pre><font class="keyword">public </font><font class="keyword">void </font>dispatchMessage(Message msg) {</p><p>	<font class="keyword">if </font>(msg.callback != </font><font class="keyword">null</font>) {</p><p>		handleCallback(msg);</p><p>	</font>} <font class="keyword">else </font>{</p><p>		<font class="keyword">if </font>(mCallback != </font><font class="keyword">null</font>) {</p><p>			<font class="keyword">if </font>(mCallback.handleMessage(msg)) {</p><p>				<font class="keyword">return</font>;</font></p><p>			}</p><p>		}</p><p>		handleMessage(msg);</p><p>	}</p><p>}</p><p></pre></p><p>Runnable说明：Runnable只是一个接口，实现了这个接口的类对应的对象也只是个普通的对象，并不是一个Java中的Thread。Thread类经常使用Runnable，很多人有误解，所以这里澄清一下。</p><p>其中清理Message是Looper里面的loop函数指把处理过的Message放到Message的Pool里面去，如果里面已经超过最大值10个，则丢弃这个Message对象。</p><p>调用Handler是指Looper里面的loop函数从MessageQueue的接收消息队列里面取出消息，然后根据消息指向的Handler对象调用其对应的处理方法。</p><p style="color:#3333FF;">11.5.代码示例</p><p>1.5.1.主线程给自己发送消息示例</p><p style="color:#3333FF;">主线程发送消息：</p><p>在onClick的case 101中创建一个继承自Handler的EventHandler对象，然后获取一个消息，然后通过EventHandler对象调用 sendMessage把消息发送到主线程的MessageQueue中。主线程由系统创建，系统会给它建立一个Looper对象和 MessageQueue，所以可以接收消息。这里只要根据主线程的Looper对象初始化EventHandler对象，就可以通过 EventHandler对象发送消息到主线程的消息队列中。</p><p style="color:#3333FF;">主线程处理消息：</p><p>这里是通过EventHandler的handleMessage函数处理的，其中收到的Message对象中what值为一的消息就是发送给它的，然后把消息里面附带的字符串在TextView上显示出来。</p><p>1.5.2.其他线程给主线程发送消息示例</p><p style="color:#3333FF;">其他线程发送消息（这里是说不使用Runnable作为callback的消息）：</p><p>首先 postRunnable设为false，表示不通过Runnable方式进行消息相关的操作。然后启动线程noLooerThread，然后以主线程的 Looper对象为参数建立EventHandler的对象mNoLooperThreadHandler，然后获取一个Message并把一个字符串赋值给它的一个成员obj，然后通过mNoLooperThreadHandler把消息发送到主线程的MessageQueue中。</p><p style="color:#3333FF;">主线程处理消息：</p><p>这里是通过EventHandler的handleMessage函数处理的，其中收到的Message对象中what值为二的消息就是上面发送给它的，然后把消息里面附带的字符串在TextView上显示出来。</p><p>1.5.3.其他线程给自己发送消息示例</p><p style="color:#3333FF;">其他线程发送消息：</p><p>其他非主线程建立后没有自己的Looper对象，所以也没有MessageQueue，需要给非主线程发送消息时需要建立MessageQueue以便接收消息。下面说明如何给自己建立MessageQueue和Looper对象。从OwnLooperThread的run函数中可以看见有一个Looper.prepare()调用，这个就是用来建立非主线程的MessageQueue和Looper对象的。</p><p>所以这里的发送消息过程是建立线程mOwnLooperThread，然后线程建立自己的Looper和MessageQueue对象，然后根据上面建立的Looper对象建立对应的EventHandler对象mOwnLooperThreadHandler，然后由 mOwnLooperThreadHandler建立消息并且发送到自己的MessageQueue里面。</p><p style="color:#3333FF;">其他线程处理接收的消息：</p><p>线程要接收消息需要在run函数中调用Looper.loop()，然后loop函数会从MessageQueue中取出消息交给对应的Handler对象mOwnLooperThreadHandler处理，在mOwnLooperThreadHandler的handleMessage函数中会把Message对象中what值为三的消息（上面发送的消息）在Log中打印出来，可以通过Logcat工具查看</p><p>程序代码如下：</p><p><pre><font class="keyword">import </font>android.app.Activity;</p><p><font class="keyword">import </font>android.content.Context;</p><p><font class="keyword">import </font>android.graphics.Color;</p><p><font class="keyword">import </font>android.os.Bundle;</p><p><font class="keyword">import </font>android.os.Handler;</p><p><font class="keyword">import </font>android.os.Looper;</p><p><font class="keyword">import </font>android.os.Message;</p><p><font class="keyword">import </font>android.util.Log;</p><p><font class="keyword">import </font>android.view.View;</p><p><font class="keyword">import </font>android.view.View.OnClickListener;</p><p><font class="keyword">import </font>android.widget.Button;</p><p><font class="keyword">import </font>android.widget.LinearLayout;</p><p><font class="keyword">import </font>android.widget.TextView;</p><p><font class="keyword">public </font><font class="keyword">class </font>MessageExample </font><font class="keyword">extends </font>Activity </font><font class="keyword">implements </font>OnClickListener {</p><p>	<font class="keyword">private </font><font class="keyword">final </font><font class="keyword">int </font>WC = LinearLayout.LayoutParams.WRAP_CONTENT;</p><p>	<font class="keyword">private </font><font class="keyword">final </font><font class="keyword">int </font>FP = LinearLayout.LayoutParams.FILL_PARENT;</p><p>	<font class="keyword">public </font>TextView tv;</p><p>	<font class="keyword">private </font>EventHandler mHandler;</p><p>	<font class="keyword">private </font>Handler mOtherThreadHandler = </font><font class="keyword">null</font>;</p><p>	<font class="keyword">private </font>Button btn, btn2, btn3, btn4, btn5, btn6;</p><p>	<font class="keyword">private </font>NoLooperThread noLooerThread = </font><font class="keyword">null</font>;</p><p>	<font class="keyword">private </font>OwnLooperThread ownLooperThread = </font><font class="keyword">null</font>;</p><p>	<font class="keyword">private </font>ReceiveMessageThread receiveMessageThread = </font><font class="keyword">null</font>;</p><p>	<font class="keyword">private </font>Context context = </font><font class="keyword">null</font>;</p><p>	<font class="keyword">private </font><font class="keyword">final </font>String sTag = <font class="Fields">"MessageExample"</font>;</p><p>	<font class="keyword">private </font><font class="keyword">boolean </font>postRunnable = </font><font class="keyword">false</font>;</p><p>	<font class="Comments">/** Called when the activity is first created. */</font></p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">void </font>onCreate(Bundle savedInstanceState) {</p><p>		<font class="keyword">super</font>.onCreate(savedInstanceState);</p><p>		</font>context = <font class="keyword">this</font>.getApplicationContext();</p><p>		</font>LinearLayout layout = <font class="keyword">new </font>LinearLayout(</font><font class="keyword">this</font>);</p><p>		layout.setOrientation(LinearLayout.VERTICAL);</p><p>		</font>btn = <font class="keyword">new </font>Button(</font><font class="keyword">this</font>);</p><p>		btn.setId(101);</p><p>		</font>btn.setText(<font class="Fields">"message from main thread self"</font>);</p><p>		</font>btn.setOnClickListener(<font class="keyword">this</font>);</p><p>		</font>LinearLayout.LayoutParams param = <font class="keyword">new </font>LinearLayout.LayoutParams(250, 50);</p><p>		param.topMargin = 10;</p><p>		layout.addView(btn, param);</p><p>		</font>btn2 = <font class="keyword">new </font>Button(</font><font class="keyword">this</font>);</p><p>		btn2.setId(102);</p><p>		</font>btn2.setText(<font class="Fields">"message from other thread to main thread"</font>);</p><p>		</font>btn2.setOnClickListener(<font class="keyword">this</font>);</p><p>		layout.addView(btn2, param);</p><p>		</font>btn3 = <font class="keyword">new </font>Button(</font><font class="keyword">this</font>);</p><p>		btn3.setId(103);</p><p>		</font>btn3.setText(<font class="Fields">"message to other thread from itself"</font>);</p><p>		</font>btn3.setOnClickListener(<font class="keyword">this</font>);</p><p>		layout.addView(btn3, param);</p><p>		</font>btn4 = <font class="keyword">new </font>Button(</font><font class="keyword">this</font>);</p><p>		btn4.setId(104);</p><p>		</font>btn4.setText(<font class="Fields">"message with Runnable as callback from other thread to main thread"</font>);</p><p>		</font>btn4.setOnClickListener(<font class="keyword">this</font>);</p><p>		layout.addView(btn4, param);</p><p>		</font>btn5 = <font class="keyword">new </font>Button(</font><font class="keyword">this</font>);</p><p>		btn5.setId(105);</p><p>		</font>btn5.setText(<font class="Fields">"main thread</font><font class="Fields">'s message to other thread"</font>);</p><p>		</font>btn5.setOnClickListener(<font class="keyword">this</font>);</p><p>		layout.addView(btn5, param);</p><p>		</font>btn6 = <font class="keyword">new </font>Button(</font><font class="keyword">this</font>);</p><p>		btn6.setId(106);</p><p>		</font>btn6.setText(<font class="Fields">"exit"</font>);</p><p>		</font>btn6.setOnClickListener(<font class="keyword">this</font>);</p><p>		layout.addView(btn6, param);</p><p>		</font>tv = <font class="keyword">new </font>TextView(</font><font class="keyword">this</font>);</p><p>		tv.setTextColor(Color.WHITE);</p><p>		</font>tv.setText(<font class="Fields">""</font>);</p><p>		</font>LinearLayout.LayoutParams param2 = <font class="keyword">new </font>LinearLayout.LayoutParams(FP, WC);</p><p>		param2.topMargin = 10;</p><p>		layout.addView(tv, param2);</p><p>		setContentView(layout);</p><p>		<font class="Comments">// 主线程要发送消息给other thread， 这里创建那个other thread</font></p><p>		</font>receiveMessageThread = <font class="keyword">new </font>ReceiveMessageThread();</p><p>		receiveMessageThread.start();</p><p>	}</p><p>	<font class="Comments">// implement the OnClickListener interface</font></p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">void </font>onClick(View v) {</p><p>		<font class="keyword">switch </font>(v.getId()) {</p><p>		<font class="keyword">case </font>101:</p><p>			<font class="Comments">// 主线程发送消息给自己</font></p><p>			Looper looper;</p><p>			looper = Looper.myLooper(); <font class="Comments">// get the Main looper related with the</font></p><p>										<font class="Comments">// main thread</font></p><p>			<font class="Comments">// 如果不给任何参数的话会用当前线程对应的Looper(这里就是Main Looper)为Handler里面的成员mLooper赋值</font></p><p>			</font>mHandler = <font class="keyword">new </font>EventHandler(looper);</p><p>			<font class="Comments">// mHandler = new EventHandler();</font></p><p>			<font class="Comments">// 清除整个MessageQueue里的消息</font></p><p>			mHandler.removeMessages(0);</p><p>			</font>String obj = <font class="Fields">"This main thread</font><font class="Fields">'s message and received by itself!"</font>;</p><p>			<font class="Comments">// 得到Message对象</font></p><p>			Message m = mHandler.obtainMessage(1, 1, 1, obj);</p><p>			<font class="Comments">// 将Message对象送入到main thread的MessageQueue里面</font></p><p>			mHandler.sendMessage(m);</p><p>			<font class="keyword">break</font>;</p><p>		<font class="keyword">case </font>102:</p><p>			<font class="Comments">// other线程发送消息给主线程</font></p><p>			</font>postRunnable = <font class="keyword">false</font>;</p><p>			</font>noLooerThread = <font class="keyword">new </font>NoLooperThread();</p><p>			noLooerThread.start();</p><p>			<font class="keyword">break</font>;</p><p>		<font class="keyword">case </font>103:</p><p>			<font class="Comments">// other thread获取它自己发送的消息</font></p><p>			</font>tv.setText(<font class="Fields">"please look at the error level log <font class="keyword">for </font>other thread received message"</font>);</p><p>			</font>ownLooperThread = <font class="keyword">new </font>OwnLooperThread();</p><p>			ownLooperThread.start();</p><p>			<font class="keyword">break</font>;</p><p>		<font class="keyword">case </font>104:</p><p>			<font class="Comments">// other thread通过Post Runnable方式发送消息给主线程</font></p><p>			</font>postRunnable = <font class="keyword">true</font>;</p><p>			</font>noLooerThread = <font class="keyword">new </font>NoLooperThread();</p><p>			noLooerThread.start();</p><p>			<font class="keyword">break</font>;</p><p>		<font class="keyword">case </font>105:</p><p>			<font class="Comments">// 主线程发送消息给other thread</font></p><p>			<font class="keyword">if </font>(</font><font class="keyword">null</font> != mOtherThreadHandler) {</p><p>				</font>tv.setText(<font class="Fields">"please look at the error level log <font class="keyword">for </font>other thread received message from main thread"</font>);</p><p>				</font>String msgObj = <font class="Fields">"message from mainThread"</font>;</p><p>				Message mainThreadMsg = mOtherThreadHandler.obtainMessage(1, 1,</p><p>						1, msgObj);</p><p>				mOtherThreadHandler.sendMessage(mainThreadMsg);</p><p>			}</p><p>			<font class="keyword">break</font>;</p><p>		<font class="keyword">case </font>106:</p><p>			finish();</p><p>			<font class="keyword">break</font>;</p><p>		}</p><p>	}</p><p>	<font class="keyword">class </font>EventHandler </font><font class="keyword">extends </font>Handler {</p><p>		<font class="keyword">public </font>EventHandler(Looper looper) {</p><p>			<font class="keyword">super</font>(looper);</p><p>		}</p><p>		<font class="keyword">public </font>EventHandler() {</p><p>			<font class="keyword">super</font>();</p><p>		}</p><p>		<font class="keyword">public </font><font class="keyword">void </font>handleMessage(Message msg) {</p><p>			<font class="Comments">// 可以根据msg.what执行不同的处理，这里没有这么做</font></p><p>			<font class="keyword">switch </font>(msg.what) {</p><p>			<font class="keyword">case </font>1:</p><p>				tv.setText((String) msg.obj);</p><p>				<font class="keyword">break</font>;</p><p>			<font class="keyword">case </font>2:</p><p>				tv.setText((String) msg.obj);</p><p>				noLooerThread.stop();</p><p>				<font class="keyword">break</font>;</p><p>			<font class="keyword">case </font>3:</p><p>				<font class="Comments">// 不能在非主线程的线程里面更新UI，所以这里通过Log打印收到的消息</font></p><p>				Log.e(sTag, (String) msg.obj);</p><p>				ownLooperThread.stop();</p><p>				<font class="keyword">break</font>;</p><p>			<font class="keyword">default</font>:</p><p>				<font class="Comments">// 不能在非主线程的线程里面更新UI，所以这里通过Log打印收到的消息</font></p><p>				Log.e(sTag, (String) msg.obj);</p><p>				<font class="keyword">break</font>;</p><p>			}</p><p>		}</p><p>	}</p><p>	<font class="Comments">// NoLooperThread</font></p><p>	<font class="keyword">class </font>NoLooperThread </font><font class="keyword">extends </font>Thread {</p><p>		<font class="keyword">private </font>EventHandler mNoLooperThreadHandler;</p><p>		<font class="keyword">public </font><font class="keyword">void </font>run() {</p><p>			Looper myLooper, mainLooper;</p><p>			myLooper = Looper.myLooper();</p><p>			mainLooper = Looper.getMainLooper(); <font class="Comments">// 这是一个static函数</font></p><p>			String obj;</p><p>			<font class="keyword">if </font>(myLooper == </font><font class="keyword">null</font>) {</p><p>				</font>mNoLooperThreadHandler = <font class="keyword">new </font>EventHandler(mainLooper);</p><p>				</font>obj = <font class="Fields">"NoLooperThread has no looper and handleMessage function executed in main thread!"</font>;</p><p>			</font>} <font class="keyword">else </font>{</p><p>				</font>mNoLooperThreadHandler = <font class="keyword">new </font>EventHandler(myLooper);</p><p>				</font>obj = <font class="Fields">"This is from NoLooperThread self and handleMessage function executed in NoLooperThread!"</font>;</p><p>			}</p><p>			mNoLooperThreadHandler.removeMessages(0);</p><p>			<font class="keyword">if </font>(</font><font class="keyword">false</font> == postRunnable) {</p><p>				<font class="Comments">// send message to main thread</font></p><p>				Message m = mNoLooperThreadHandler.obtainMessage(2, 1, 1, obj);</p><p>				mNoLooperThreadHandler.sendMessage(m);</p><p>				</font>Log.e(sTag, <font class="Fields">"NoLooperThread id:"</font> + <font class="keyword">this</font>.getId());</p><p>			</font>} <font class="keyword">else </font>{</p><p>				<font class="Comments">// 下面new出来的实现了Runnable接口的对象中run函数是在Main</font></p><p>				<font class="Comments">// Thread中执行，不是在NoLooperThread中执行</font></p><p>				<font class="Comments">// 注意Runnable是一个接口，它里面的run函数被执行时不会再新建一个线程</font></p><p>				<font class="Comments">// 您可以在run上加断点然后在eclipse调试中看它在哪个线程中执行</font></p><p>				</font>mNoLooperThreadHandler.post(<font class="keyword">new </font>Runnable() {</p><p>					@Override</p><p>					<font class="keyword">public </font><font class="keyword">void </font>run() {</p><p>						</font>tv.setText(<font class="Fields">"update UI through handler post runnalbe mechanism!"</font>);</p><p>						noLooerThread.stop();</p><p>					}</p><p>				});</p><p>			}</p><p>		}</p><p>	}</p><p>	<font class="Comments">// OwnLooperThread has his own message queue by execute Looper.prepare();</font></p><p>	<font class="keyword">class </font>OwnLooperThread </font><font class="keyword">extends </font>Thread {</p><p>		<font class="keyword">private </font>EventHandler mOwnLooperThreadHandler;</p><p>		<font class="keyword">public </font><font class="keyword">void </font>run() {</p><p>			Looper.prepare();</p><p>			Looper myLooper, mainLooper;</p><p>			myLooper = Looper.myLooper();</p><p>			mainLooper = Looper.getMainLooper(); <font class="Comments">// 这是一个static函数</font></p><p>			String obj;</p><p>			<font class="keyword">if </font>(myLooper == </font><font class="keyword">null</font>) {</p><p>				</font>mOwnLooperThreadHandler = <font class="keyword">new </font>EventHandler(mainLooper);</p><p>				</font>obj = <font class="Fields">"OwnLooperThread has no looper and handleMessage function executed in main thread!"</font>;</p><p>			</font>} <font class="keyword">else </font>{</p><p>				</font>mOwnLooperThreadHandler = <font class="keyword">new </font>EventHandler(myLooper);</p><p>				</font>obj = <font class="Fields">"This is from OwnLooperThread self and handleMessage function executed in NoLooperThread!"</font>;</p><p>			}</p><p>			mOwnLooperThreadHandler.removeMessages(0);</p><p>			<font class="Comments">// 给自己发送消息</font></p><p>			Message m = mOwnLooperThreadHandler.obtainMessage(3, 1, 1, obj);</p><p>			mOwnLooperThreadHandler.sendMessage(m);</p><p>			Looper.loop();</p><p>		}</p><p>	}</p><p>	<font class="Comments">// ReceiveMessageThread has his own message queue by execute</font></p><p>	<font class="Comments">// Looper.prepare();</font></p><p>	<font class="keyword">class </font>ReceiveMessageThread </font><font class="keyword">extends </font>Thread {</p><p>		<font class="keyword">public </font><font class="keyword">void </font>run() {</p><p>			Looper.prepare();</p><p>			</font>mOtherThreadHandler = <font class="keyword">new </font>Handler() {</p><p>				<font class="keyword">public </font><font class="keyword">void </font>handleMessage(Message msg) {</p><p>					Log.e(sTag, (String) msg.obj);</p><p>				}</p><p>			};</p><p>			Looper.loop();</p><p>		}</p><p>	}</p><p>}</p><p></p><p></pre></p><p>使用Looper.myLooper静态方法可以取得当前线程的Looper对象。</p><p>使用mHandler = new EevntHandler(Looper.myLooper()); 可建立用来处理当前线程的Handler对象；其中，EevntHandler是Handler的子类。</p><p>使用mHandler = new EevntHandler(Looper.getMainLooper()); 可建立用来处理main线程的Handler对象；其中，EevntHandler是Handler的子类。</p><p></p></div>

</DIV></DIV>

<DIV id=footer style="display:none">
<P align="center">  
 
 
 
    </P>
</DIV></BODY></HTML>

