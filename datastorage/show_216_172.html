
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>SQLite 设计与概念（一）_Android学习手册</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<META name=GENERATOR content="MSHTML 8.00.6001.18702">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">

</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li ><A href="../component/index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li ><A href="../device/index.html">设备功能</A> </li><li class="navcurrentLink"><A href="index.html">数据存储</A> </li><li ><A href="../network/index.html">网络应用</A> </li><li ><A href="../game/index.html">游戏开发</A> </li><li ><A href="../multimedia/index.html">多媒体</A> </li><li ><A href="../source/index.html">源码开发</A> </li><li ><A href="../advance/index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">课 程 表</div>


  <h2><A title="ContentProvider" href="index_170.html">ContentProvider</A></h2>

  <h2><A title="Preferences" href="index_171.html">Preferences</A></h2>

  <h2><A title="SQLite" href="index_172.html">SQLite</A></h2>
<UL><li ><A title=Android 嵌入式SQLite数据库（一） href="show_201_172.html">Android 嵌入式SQLite数据库（一）</A> </li><li ><A title=Android 嵌入式SQLite数据库（二） href="show_202_172.html">Android 嵌入式SQLite数据库（二）</A> </li><li ><A title=Android 嵌入式SQLite数据库（三） href="show_203_172.html">Android 嵌入式SQLite数据库（三）</A> </li><li ><A title=Android 嵌入式SQLite数据库（四） href="show_204_172.html">Android 嵌入式SQLite数据库（四）</A> </li><li ><A title=Android 深入研究SQLite实例（一） href="show_205_172.html">Android 深入研究SQLite实例（一）</A> </li><li ><A title=Android 深入研究SQLite实例（二） href="show_206_172.html">Android 深入研究SQLite实例（二）</A> </li><li ><A title=Android 深入研究SQLite实例（三） href="show_207_172.html">Android 深入研究SQLite实例（三）</A> </li><li ><A title=Android 深入研究SQLite实例（四） href="show_208_172.html">Android 深入研究SQLite实例（四）</A> </li><li ><A title=Android 深入研究SQLite实例（五） href="show_209_172.html">Android 深入研究SQLite实例（五）</A> </li><li ><A title=Android 深入研究SQLite实例（六） href="show_210_172.html">Android 深入研究SQLite实例（六）</A> </li><li ><A title=Android 深入研究SQLite实例（七） href="show_211_172.html">Android 深入研究SQLite实例（七）</A> </li><li ><A title=Android 深入研究SQLite实例（八） href="show_212_172.html">Android 深入研究SQLite实例（八）</A> </li><li ><A title=Android 深入研究SQLite实例（九） href="show_213_172.html">Android 深入研究SQLite实例（九）</A> </li><li ><A title=Android 深入研究SQLite实例（十） href="show_214_172.html">Android 深入研究SQLite实例（十）</A> </li><li ><A title=Android 深入研究SQLite实例（十一） href="show_215_172.html">Android 深入研究SQLite实例（十一）</A> </li><li class="currentLink"><A title=SQLite 设计与概念（一） href="show_216_172.html">SQLite 设计与概念（一）</A> </li><li ><A title=SQLite 设计与概念（二） href="show_217_172.html">SQLite 设计与概念（二）</A> </li><li ><A title=SQLite数据库学习 href="show_218_172.html">SQLite数据库学习</A> </li><li ><A title=SQLite数据库增删改查操作 href="show_219_172.html">SQLite数据库增删改查操作</A> </li><li ><A title=Android 浅谈Cursor href="show_220_172.html">Android 浅谈Cursor</A> </li><li ><A title=SQLite 数据类型 href="show_221_172.html">SQLite 数据类型</A> </li><li ><A title=Android里sqlite多表联合查询 href="show_222_172.html">Android里sqlite多表联合查询</A> </li><li ><A title=SQLite的工具类 href="show_223_172.html">SQLite的工具类</A> </li><li ><A title=自定义SQlite数据文件存放位置 href="show_224_172.html">自定义SQlite数据文件存放位置</A> </li><li ><A title=SQLite和Android小项目 href="show_225_172.html">SQLite和Android小项目</A> </li><li ><A title=如何将SQLite数据库（dictionary.db文件）与apk文件一起发布 href="show_226_172.html">如何将SQLite数据库（dictionary.db文件）与apk文件一起发布</A> </li><li ><A title=SQLiteSpy免费正式版-小巧好用的SQLite GUI管理工具 href="show_227_172.html">SQLiteSpy免费正式版-小巧好用的SQLite GUI管理工具</A> </li></UL>
  <h2><A title="SD卡" href="index_173.html">SD卡</A></h2>

  <h2><A title="数据库" href="index_174.html">数据库</A></h2>

  <h2><A title="URI" href="index_175.html">URI</A></h2>

  <h2><A title="MediaStore" href="index_176.html">MediaStore</A></h2>

</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1></H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>SQLite 设计与概念（一）</H2>
<div style="line-height:20px; font-size:14px;"><p>1、API </p><p>由两部分组成: 核心API(core API) 和扩展API（extension API）</p><p>核心API的函数实现基本的数据库操作：连接数据库，处理SQL，遍历结果集。它也包括一些实用函数，比如字符串转换，操作控制，调试和错误处理。</p><p>扩展API通过创建你自定义的SQL函数去扩展SQLite。</p><p>1.1、SQLite Version 3的一些新特点：</p><p>(1)SQLite的API全部重新设计，由第二版的15个函数增加到88个函数。这些函数包括支持UTF-8和UTF-16编码的功能函数。</p><p>(2)改进并发性能。加锁子系统引进一种锁升级模型(lock escalation model)，解决了第二版的写进程饿死的问题(该问题是任何一个DBMS必须面对的问题)。这种模型保证写进程按照先来先服务的算法得到排斥锁(Exclusive Lock)。甚至，写进程通过把结果写入临时缓冲区(Temporary Buffer)，可以在得到排斥锁之前就能开始工作。这对于写要求较高的应用，性能可提高400%（引自参考文献）。</p><p>(3)改进的B-树。对于表采用B+树，大大提高查询效率。</p><p>(4)SQLite 3最重要的改变是它的存储模型。由第二版只支持文本模型，扩展到支持5种本地数据类型。</p><p>总之，SQLite Version 3与SQLite Vertion 2有很大的不同，在灵活性，特点和性能方面有很大的改进。</p><p>1.2、主要的数据结构(The Principal Data Structures)</p><p>SQLite由很多部分组成－parser,tokenize,virtual machine等等。但是从程序员的角度，最需要知道的是:connection,statements,B-tree和pager。它们之间的关系如下：</p><p><img src="../img/data_sqlite/16_sqlite.jpg"></p><p>上图告诉我们在编程需要知道的三个主要方面：API,事务(Transaction)和锁(Locks)。从技术上来说，B-tree和pager不是API的一部分。但是它们却在事务和锁上起着关键作用。　</p><p>1.3、Connections和Statements</p><p>Connection和statement是执行SQL命令涉及的两个主要数据结构，几乎所有通过API进行的操作都要用到它们。一个连接(Connection)代表在一个独立的事务环境下的一个连接A (connection represents a single connection to a database as well as a single transaction context)。每一个statement都和一个connection关联，它通常表示一个编译过的SQL语句，在内部，它以VDBE字节码表示。Statement包括执行一个命令所需要一切，包括保存VDBE程序执行状态所需的资源，指向硬盘记录的B-树游标，以及参数等等。</p><p>1.4、B-tree和pager</p><p>一个connection可以有多个database对象---一个主要的数据库以及附加的数据库，每一个数据库对象有一个B-tree对象，一个B-tree有一个pager对象(这里的对象不是面向对象的“对象”，只是为了说清楚问题)。</p><p>Statement最终都是通过connection的B-tree和pager从数据库读或者写数据，通过B-tree的游标(cursor)遍历存储在页面(page)中的记录。游标在访问页面之前要把数所从disk加载到内存，而这就是pager的任务。任何时候，如果B-tree需要页面，它都会请求pager从disk读取数据，然后把页面(page)加载到页面缓冲区(page cache)，之后，B-tree和与之关联的游标就可以访问位于page中的记录了。</p><p>如果cursor改变了page，为了防止事务回滚，pager必须采取特殊的方式保存原来的page。总的来说，pager负责读写数据库，管理内存缓存和页面（page），以及管理事务，锁和崩溃恢复(这些在事务一节会详细介绍)。</p><p>总之，关于connection和transaction，你必须知道两件事：</p><p>(1)对数据库的任何操作，一个连接存在于一个事务下。</p><p>(2)一个连接决不会同时存在多个事务下。</p><p>whenever a connection does anything with a database, it always operates under exactly one</p><p>transaction, no more, no less.</p><p>1.5、核心API</p><p>核心API 主要与执行SQL命令有关，本质上有两种方法执行SQL语句：prepared query 和wrapped query。Prepared query由三个阶段构成：preparation，execution和finalization。其实wrapped query只是对prepared query的三个过程包装而已，最终也会转化为prepared query的执行。</p><p>1.5.1、连接的生命周期(The Connection Lifecycle)</p><p>和大多数据库连接相同，由三个过程构成：</p><p>（1）连接数据库(Connect to the database)：</p><p>每一个SQLite数据库都存储在单独的操作系统文件中，连接，打开数据库的C API为：sqlite3_open()，它的实现位于main.c文件中，如下：</p><p><pre><font class="keyword">int </font>sqlite3_open(const char *zFilename, sqlite3 **ppDb){</p><p>	<font class="keyword">return </font>openDatabase(zFilename, ppDb, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, 0);</p><p>}</p><p></pre></p><p>当连接一个在磁盘上的数据库，如果数据库文件存在，SQLite打开一个文件；如果不存在，SQLite会假定你想创建一个新的数据库。在这种情况下，SQLite不会立即在磁盘上创建一个文件，只有当你向数据库写入数据时才会创建文件，比如：创建表、视图或者其它数据库对象。如果你打开一个数据，不做任何事，然后关闭它，SQLite会创建一个文件，只是一个空文件而已。</p><p>另外一个不立即创建一个新文件的原因是，一些数据库的参数，比如：编码，页面大小等，只在在数据库创建前设置。默认情况下，页面大小为1024字节，但是你可以选择512-32768字节之间为 2幂数的数字。有些时候，较大的页面能更有效的处理大量的数据。</p><p>（2）执行事务(Perform transactions)：</p><p>all commands are executed within transactions。默认情况下，事务自动提交，也就是每一个SQL语句都在一个独立的事务下运行。当然也可以通过使用BEGIN..COMMIT手动提交事务。</p><p>（3）断开连接(Disconnect from the database)：</p><p>主要是关闭数据库的文件。</p><p>1.5.2、执行Prepared Query</p><p>前面提到，预处理查询(Prepared Query)是SQLite执行所有SQL命令的方式，包括以下三个过程：</p><p>(1)Prepared Query：</p><p>分析器（parser），分词器(tokenizer)和代码生成器(code generator)把SQL Statement编译成VDBE字节码，编译器会创建一个statement句柄(sqlite3_stmt)，它包括字节码以及其它执行命令和遍历结果集的所有资源。</p><p>相应的C API为sqlite3_prepare()，位于prepare.c文件中，如下：</p><p><pre><font class="keyword">int </font>sqlite3_prepare(</p><p>	sqlite3 *db,　</p><p>	const char *zSql,</p><p>	<font class="keyword">int </font>nBytes,　</p><p>	sqlite3_stmt **ppStmt,</p><p>	const char **pzTail　</p><p>)</p><p>{</p><p>	<font class="keyword">int </font>rc;</p><p>	rc = sqlite3LockAndPrepare(db,zSql,nBytes,0,ppStmt,pzTail);</p><p>	assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );　</p><p>	<font class="keyword">return </font>rc;</p><p>}</p><p></pre></p><p>(2)Execution：虚拟机执行字节码，执行过程是一个步进(stepwise)的过程，每一步(step)由sqlite3_step()启动，并由VDBE执行一段字节码。由sqlite3_prepare编译字节代码，并由sqlite3_step()启动虚拟机执行。在遍历结果集的过程中，它返回SQLITE_ROW，当到达结果末尾时，返回SQLITE_DONE。</p><p>(3)Finalization：</p><p>VDBE关闭statement，释放资源。相应的C API为sqlite3_finalize()。</p><p>通过下图可以更容易理解该过程：</p><p><pre>include</p><p>include</p><p></font>include<font class="Fields">"sqlite3.h</p><p>include</p><p><font class="keyword">int </font>main(intargc,char**argv){</p><p>	<font class="keyword">int </font>rc,i,ncols;</p><p>	sqlite3 *db;</p><p>	sqlite3_stmt *stmt;</p><p>	char *sql;</p><p>	const char*tail;</p><p>	<font class="Comments">//打开数据</font></p><p>	</font>rc=sqlite3_open(<font class="Fields">"foods.db"</font>,&db);</p><p>	if(rc){</p><p>		</font>fprintf(stderr,<font class="Fields">"Can</font><font class="Fields">'topendatabase:%sn"</font>,sqlite3_errmsg(db));</p><p>		sqlite3_close(db);</p><p>		exit(1);</p><p>	}</p><p>	</font>sql=<font class="Fields">"select * from episodes"</font>;</p><p>	<font class="Comments">//预处理</font></p><p>	</font>rc=sqlite3_prepare(db,sql,(<font class="keyword">int</font>)strlen(sql),&stmt,&tail);</p><p>	if(rc!=SQLITE_OK){</p><p>		</font>fprintf(stderr,<font class="Fields">"SQLerror:%sn"</font>,sqlite3_errmsg(db));</p><p>	}</p><p>	rc=sqlite3_step(stmt);</p><p>	ncols=sqlite3_column_count(stmt);</p><p>	while(rc==SQLITE_ROW){</p><p>		</font>for(i=0;ifprintf(stderr,<font class="Fields">"</font><font class="Fields">'%s'</font>"</font>,sqlite3_column_text(stmt,i));</p><p>	}</p><p>	</font>fprintf(stderr,<font class="Fields">"n"</font>);</p><p>	rc=sqlite3_step(stmt);</p><p>}</p><p><font class="Comments">//释放statement</font></p><p>sqlite3_finalize(stmt);</p><p><font class="Comments">//关闭数据库</font></p><p>sqlite3_close(db);</p><p>return0;</p><p>}</p><p></pre></p><p></p><p></p></div>

</DIV></DIV>

<DIV id=footer style="display:none">
<P align="center">  
 
 
 
    </P>
</DIV></BODY></HTML>

