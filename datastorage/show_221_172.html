
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>SQLite 数据类型_Android学习手册</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<META name=GENERATOR content="MSHTML 8.00.6001.18702">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">

</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li ><A href="../component/index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li ><A href="../device/index.html">设备功能</A> </li><li class="navcurrentLink"><A href="index.html">数据存储</A> </li><li ><A href="../network/index.html">网络应用</A> </li><li ><A href="../game/index.html">游戏开发</A> </li><li ><A href="../multimedia/index.html">多媒体</A> </li><li ><A href="../source/index.html">源码开发</A> </li><li ><A href="../advance/index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">课 程 表</div>


  <h2><A title="ContentProvider" href="index_170.html">ContentProvider</A></h2>

  <h2><A title="Preferences" href="index_171.html">Preferences</A></h2>

  <h2><A title="SQLite" href="index_172.html">SQLite</A></h2>
<UL><li ><A title=Android 嵌入式SQLite数据库（一） href="show_201_172.html">Android 嵌入式SQLite数据库（一）</A> </li><li ><A title=Android 嵌入式SQLite数据库（二） href="show_202_172.html">Android 嵌入式SQLite数据库（二）</A> </li><li ><A title=Android 嵌入式SQLite数据库（三） href="show_203_172.html">Android 嵌入式SQLite数据库（三）</A> </li><li ><A title=Android 嵌入式SQLite数据库（四） href="show_204_172.html">Android 嵌入式SQLite数据库（四）</A> </li><li ><A title=Android 深入研究SQLite实例（一） href="show_205_172.html">Android 深入研究SQLite实例（一）</A> </li><li ><A title=Android 深入研究SQLite实例（二） href="show_206_172.html">Android 深入研究SQLite实例（二）</A> </li><li ><A title=Android 深入研究SQLite实例（三） href="show_207_172.html">Android 深入研究SQLite实例（三）</A> </li><li ><A title=Android 深入研究SQLite实例（四） href="show_208_172.html">Android 深入研究SQLite实例（四）</A> </li><li ><A title=Android 深入研究SQLite实例（五） href="show_209_172.html">Android 深入研究SQLite实例（五）</A> </li><li ><A title=Android 深入研究SQLite实例（六） href="show_210_172.html">Android 深入研究SQLite实例（六）</A> </li><li ><A title=Android 深入研究SQLite实例（七） href="show_211_172.html">Android 深入研究SQLite实例（七）</A> </li><li ><A title=Android 深入研究SQLite实例（八） href="show_212_172.html">Android 深入研究SQLite实例（八）</A> </li><li ><A title=Android 深入研究SQLite实例（九） href="show_213_172.html">Android 深入研究SQLite实例（九）</A> </li><li ><A title=Android 深入研究SQLite实例（十） href="show_214_172.html">Android 深入研究SQLite实例（十）</A> </li><li ><A title=Android 深入研究SQLite实例（十一） href="show_215_172.html">Android 深入研究SQLite实例（十一）</A> </li><li ><A title=SQLite 设计与概念（一） href="show_216_172.html">SQLite 设计与概念（一）</A> </li><li ><A title=SQLite 设计与概念（二） href="show_217_172.html">SQLite 设计与概念（二）</A> </li><li ><A title=SQLite数据库学习 href="show_218_172.html">SQLite数据库学习</A> </li><li ><A title=SQLite数据库增删改查操作 href="show_219_172.html">SQLite数据库增删改查操作</A> </li><li ><A title=Android 浅谈Cursor href="show_220_172.html">Android 浅谈Cursor</A> </li><li class="currentLink"><A title=SQLite 数据类型 href="show_221_172.html">SQLite 数据类型</A> </li><li ><A title=Android里sqlite多表联合查询 href="show_222_172.html">Android里sqlite多表联合查询</A> </li><li ><A title=SQLite的工具类 href="show_223_172.html">SQLite的工具类</A> </li><li ><A title=自定义SQlite数据文件存放位置 href="show_224_172.html">自定义SQlite数据文件存放位置</A> </li><li ><A title=SQLite和Android小项目 href="show_225_172.html">SQLite和Android小项目</A> </li><li ><A title=如何将SQLite数据库（dictionary.db文件）与apk文件一起发布 href="show_226_172.html">如何将SQLite数据库（dictionary.db文件）与apk文件一起发布</A> </li><li ><A title=SQLiteSpy免费正式版-小巧好用的SQLite GUI管理工具 href="show_227_172.html">SQLiteSpy免费正式版-小巧好用的SQLite GUI管理工具</A> </li></UL>
  <h2><A title="SD卡" href="index_173.html">SD卡</A></h2>

  <h2><A title="数据库" href="index_174.html">数据库</A></h2>

  <h2><A title="URI" href="index_175.html">URI</A></h2>

  <h2><A title="MediaStore" href="index_176.html">MediaStore</A></h2>

</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1></H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>SQLite 数据类型</H2>
<div style="line-height:20px; font-size:14px;"><p>SQLite与其他常见的DBMS的最大不同是它对数据类型的支持。其他常见的DBMS通常支持强类型的数据，也就是每一列的类型都必须预先指定，但是SQLite采用的是弱类型的字段。实际上，其内部仅有下列五种存储类型：</p><p><pre>NULL: 表示一个NULL值。</p><p>INTEGER: 用来存储一个整数,根据大小可以使用1,2,3,4,6,8位来存储。</p><p>REAL: IEEE 浮点数。</p><p>TEXT: 按照字符串来存储。</p><p>BLOB: 按照二进制值存储，不做任何改变。</p><p></pre></p><p>要注意,这些类型是值本身的属性,而不是列的属性。</p><p>但是为了和其他DBMS（以及SQL标准）兼容，在其create table语句中可以指定列的类型，为此,SQLite有个列相似性的概念(Column Affinity). 列相似性是列的属性,SQLite有以下几种列相似性:</p><p><pre>TEXT: TEXT列使用NULL,TEXT或者BLOB存储任何插入到此列的数据,如果数据是数字,则转换为TEXT。</p><p>NUMERIC: NUMERIC列可以使用任何存储类型，它首先试图将插入的数据转换为REAL或INTEGER型的，如果成功则存储为REAL和INTEGER型,否则不加改变的存入。</p><p>INTEGER:和NUMERIC类似，只是它将可以转换为INTEGER值都转换为INTEGER，如果是REAL型，且没有小数部分，也转为INTEGER。</p><p>REAL: 和NUMERIC类型，只是它将可以转换为REAL和INTEGER值都转换为REAL。</p><p>NONE:不做任何改变的尝试。</p><p></pre></p><p>SQLite根据create table语句来决定每个列的列相似性.规则如下(大小写均忽略):</p><p>1. 如果数据类型中包括INT,则是INTEGER</p><p>2. 如果数据类型中包括CHAR,CLOB,TEXT则是TEXT</p><p>3. 如果数据类型中包括BLOB,或者没有指定数据类型,则是NONE</p><p>4. 如果数据类型中包括REAL,FLOA或者DOUB,则是REAL</p><p>5. 其余的情况都是NUMERIC</p><p>由上可知,对于sqlite来说char,varchar,nchar,nvarchar等都是等价的，且后面最大长度也是没有意义的。但是对于其他DBMS却不是相同的。另外，列相似性仅仅是向Sqlite提出了一个存储数据的建议，即使实际存储的数据类型和列相似性不一致，SQLite还是可以成功插入的，下面给出一个例子来说明下以上论述，注意，这个例子需要在SQLite的命令行下运行，如果在SQLite Expert工具下执行，SQLite会进行一些额外的处理。</p><p>如下图，创建一个新表，两列的类型分别是int 和varchar，但是还是可以插入其他类型的数据，并且可以正确读出。</p><p>要注意SQLite的这种特性可能会给SQLite的ADO驱动造成一些麻烦，因为.NET都是强类型的语言，必须把数据库中的字段转换为合适的类型，所以在插入数据的时候，还是应该严格的按照create table中的定义插入数据。</p><p>（2）自增列</p><p>在SQL Server中，只需要指定identity(1,1)就可以设定自增列，但是在SQLite中不支持这样做。在SQLite中，任何一张表都有一个字段类型是Integer，且是自增的，这个列是作为B树的索引的，它的名字是ROWID，如下图所示：</p><p>test2表虽然只有一列，但是ROWID列还是存在的。在程序中对任何一张表都可以使用ROWID作为自增列。不过这样可能导致和其他数据库的不兼容，SQLite中如果一个列的声明类型是Integer，并且是主键，那么这个列的名字就成为ROWID的别名。注意，声明类型必须是Integer，而不能是int或bigint之类。例如：</p><p>注意上面例子的最后3条语句，它显示了SQLite默认的自增列算法是在当前表中最大的数再加1，这样可能导致的结果是ID被重复使用——当最后一条数据被删除的时候。这与SQL Server的Identity列的行为是不一致的，例如：</p><p>SQL Server会记住每一次插入的序号，哪怕它已经被删除了。要实现SQL Server 这样的效果，需要使用autoincrement关键字。如下例所示：</p><p>不过autoincrement关键字不被SQL Server支持（我不知道SQL 92标准中是否有此关键字），同样SQL Server的indentity关键字在SQLite中也无法使用，因为SQLite只要求声明类型必须是integer才可以启用自增列。所以，我想不出什么方法能使建库的脚本能够不加修改的被两种数据库使用。</p><p>(3) 日期函数</p><p>Sqlite的日期函数比较有特色，它的使用本质上是调用C的库函数strftime,基本使用方法如下：</p><p>(4) 不被支持的特性</p><p>用户自定义函数，存储过程</p><p>外键的约束（不过可以通过自定义触发器来替代）</p><p></p></div>

</DIV></DIV>

<DIV id=footer style="display:none">
<P align="center">  
 
 
 
    </P>
</DIV></BODY></HTML>

