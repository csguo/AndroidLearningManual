
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>关于Android SQLite database存储到sdcard上的问题_Android学习手册</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<META name=GENERATOR content="MSHTML 8.00.6001.18702">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">

</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li ><A href="../component/index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li ><A href="../device/index.html">设备功能</A> </li><li class="navcurrentLink"><A href="index.html">数据存储</A> </li><li ><A href="../network/index.html">网络应用</A> </li><li ><A href="../game/index.html">游戏开发</A> </li><li ><A href="../multimedia/index.html">多媒体</A> </li><li ><A href="../source/index.html">源码开发</A> </li><li ><A href="../advance/index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">课 程 表</div>


  <h2><A title="ContentProvider" href="index_170.html">ContentProvider</A></h2>

  <h2><A title="Preferences" href="index_171.html">Preferences</A></h2>

  <h2><A title="SQLite" href="index_172.html">SQLite</A></h2>

  <h2><A title="SD卡" href="index_173.html">SD卡</A></h2>

  <h2><A title="数据库" href="index_174.html">数据库</A></h2>
<UL><li ><A title=Android 数据存取之Databases href="show_401_174.html">Android 数据存取之Databases</A> </li><li ><A title=Android教程之SQlite数据库操作 href="show_402_174.html">Android教程之SQlite数据库操作</A> </li><li ><A title=Android 数据库一次创建多个表（一） href="show_403_174.html">Android 数据库一次创建多个表（一）</A> </li><li ><A title=Android 数据库一次创建多个表（二） href="show_404_174.html">Android 数据库一次创建多个表（二）</A> </li><li ><A title=Android 数据库经验总结 href="show_405_174.html">Android 数据库经验总结</A> </li><li ><A title=创建数据库的时候就将数据库保存到SDcard href="show_406_174.html">创建数据库的时候就将数据库保存到SDcard</A> </li><li ><A title=Android保存图片到数据库 href="show_407_174.html">Android保存图片到数据库</A> </li><li ><A title=Android中访问已有的SQLite数据库 href="show_408_174.html">Android中访问已有的SQLite数据库</A> </li><li class="currentLink"><A title=关于Android SQLite database存储到sdcard上的问题 href="show_409_174.html">关于Android SQLite database存储到sdcard上的问题</A> </li></UL>
  <h2><A title="URI" href="index_175.html">URI</A></h2>

  <h2><A title="MediaStore" href="index_176.html">MediaStore</A></h2>

</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1></H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>关于Android SQLite database存储到sdcard上的问题</H2>
<div style="line-height:20px; font-size:14px;"><p>最近碰到apk和后台的cpp code都需要访问一个数据库的问题。结果发现apk中创建的数据库外部的进程是没有权限去读/写的。这就需要把数据库文件创建到sdcard上。</p><p>后来发现在SQLiteOpenHelper(frameworks/base/core/java/android/database/sqlite/SQLiteOpenHelper.java)这个类中，创建数据库文件的路径是使用传入的contex的getDatabasePath获取的，这个是不允许修改的。</p><p>那我就仿照这个SQLiteOpenHelper写了一个abstract class SDSQLiteOpenHelper，其使用和SQLiteOpenHelper一样，然后只要加上相应的permission，这样就可以实现把数据库存储到sdcard上了。</p><p><pre><font class="keyword">import </font>java.io.File;</p><p><font class="keyword">import </font>android.content.Context;</p><p><font class="keyword">import </font>android.database.sqlite.SQLiteDatabase;</p><p><font class="keyword">import </font>android.database.sqlite.SQLiteException;</p><p><font class="keyword">import </font>android.database.sqlite.SQLiteDatabase.CursorFactory;</p><p><font class="keyword">import </font>android.util.Log;</p><p><font class="Comments">/**</font></p><p> <font class="Comments">* A helper class to manage database creation and version management. You create</font></p><p> <font class="Comments">* a subclass implementing {@link onCreate}, {@link onUpgrade} and optionally</font></p><p> <font class="Comments">* {@link onOpen}, and this class takes care of opening the database if it</font></p><p> <font class="Comments">* exists, creating it if it does not, and upgrading it as necessary.</font></p><p> <font class="Comments">* Transactions are used to make sure the database is always in a sensible</font></p><p> <font class="Comments">* state.</font></p><p> <font class="Comments">* &lt;p&gt;</font></p><p> <font class="Comments">* For an example, see the NotePadProvider class in the NotePad sample</font></p><p> <font class="Comments">* application, in the &lt;em&gt;samples/&lt;/em&gt; directory of the SDK.</font></p><p> <font class="Comments">* &lt;/p&gt;</font></p><p> <font class="Comments">*/</font></p><p><font class="keyword">public </font><font class="keyword">abstract </font><font class="keyword">class </font>SDSQLiteOpenHelper {</p><p>	<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">final </font>String TAG = SDSQLiteOpenHelper.</font><font class="keyword">class</font>.getSimpleName();</p><p>	<font class="keyword">private </font><font class="keyword">final </font>Context mContext;</p><p>	<font class="keyword">private </font><font class="keyword">final </font>String mName;</p><p>	<font class="keyword">private </font><font class="keyword">final </font>CursorFactory mFactory;</p><p>	<font class="keyword">private </font><font class="keyword">final </font><font class="keyword">int </font>mNewVersion;</p><p>	<font class="keyword">private </font>SQLiteDatabase mDatabase = </font><font class="keyword">null</font>;</p><p>	<font class="keyword">private </font><font class="keyword">boolean </font>mIsInitializing = </font><font class="keyword">false</font>;</p><p>	<font class="Comments">/**</font></p><p>	 <font class="Comments">* Create a helper object to create, open, and/or manage a database. The</font></p><p>	 <font class="Comments">* database is not actually created or opened until one of</font></p><p>	 <font class="Comments">* {@link getWritableDatabase} or {@link getReadableDatabase} is called.</font></p><p>	 <font class="Comments">* </font></p><p>	 <font class="Comments">* @param context</font></p><p>	 <font class="Comments">*            to use to open or create the database</font></p><p>	 <font class="Comments">* @param name</font></p><p>	 <font class="Comments">*            of the database file, or null for an in-memory database</font></p><p>	 <font class="Comments">* @param factory</font></p><p>	 <font class="Comments">*            to use for creating cursor objects, or null for the default</font></p><p>	 <font class="Comments">* @param version</font></p><p>	 <font class="Comments">*            number of the database (starting at 1); if the database is</font></p><p>	 <font class="Comments">*            older, {@link onUpgrade} will be used to upgrade the database</font></p><p>	 <font class="Comments">*/</font></p><p>	<font class="keyword">public </font>SDSQLiteOpenHelper(Context context, String name,</p><p>			</font>CursorFactory factory, <font class="keyword">int </font>version) {</p><p>		<font class="keyword">if </font>(version &lt; 1)</p><p>			<font class="keyword">throw </font><font class="keyword">new </font>IllegalArgumentException(<font class="Fields">"Version must be &gt;= 1, was </p><p>					+ version);</p><p>		mContext = context;</p><p>		mName = name;</p><p>		mFactory = factory;</p><p>		mNewVersion = version;</p><p>	}</p><p>	<font class="Comments">/**</font></p><p>	 <font class="Comments">* Create and/or open a database that will be used for reading and writing.</font></p><p>	 <font class="Comments">* Once opened successfully, the database is cached, so you can call this</font></p><p>	 <font class="Comments">* method every time you need to write to the database. Make sure to call</font></p><p>	 <font class="Comments">* {@link close} when you no longer need it.</font></p><p>	 <font class="Comments">* </font></p><p>	 <font class="Comments">* &lt;p&gt;</font></p><p>	 <font class="Comments">* Errors such as bad permissions or a full disk may cause this operation to</font></p><p>	 <font class="Comments">* fail, but future attempts may succeed if the problem is fixed.</font></p><p>	 <font class="Comments">* &lt;/p&gt;</font></p><p>	 <font class="Comments">* </font></p><p>	 <font class="Comments">* @throws SQLiteException</font></p><p>	 <font class="Comments">*             if the database cannot be opened for writing</font></p><p>	 <font class="Comments">* @return a read/write database object valid until {@link close} is called</font></p><p>	 <font class="Comments">*/</font></p><p>	<font class="keyword">public </font><font class="keyword">synchronized </font>SQLiteDatabase getWritableDatabase() {</p><p>		<font class="keyword">if </font>(mDatabase != </font><font class="keyword">null</font> && mDatabase.isOpen() && !mDatabase.isReadOnly()) {</p><p>			<font class="keyword">return </font>mDatabase; <font class="Comments">// The database is already open </font><font class="keyword">for </font>business</font></p><p>		}</p><p>		<font class="keyword">if </font>(mIsInitializing) {</p><p>			<font class="keyword">throw </font><font class="keyword">new </font>IllegalStateException(</p><p>					<font class="Fields">"getWritableDatabase called recursively"</font>);</p><p>		}</p><p>		<font class="Comments">// If we have a read-only database open, someone could be using it</font></p><p>		<font class="Comments">// (though they shouldn't), which would cause a lock to be held on</font></p><p>		<font class="Comments">// the file, and our attempts to open the database read-write would</font></p><p>		<font class="Comments">// fail waiting for the file lock. To prevent that, we acquire the</font></p><p>		<font class="Comments">// lock on the read-only database, which shuts out other users.</font></p><p>		<font class="keyword">boolean </font>success = </font><font class="keyword">false</font>;</p><p>		</font>SQLiteDatabase db = <font class="keyword">null</font>;</p><p>		<font class="keyword">try </font>{</p><p>			</font>mIsInitializing = <font class="keyword">true</font>;</p><p>			<font class="keyword">if </font>(mName == </font><font class="keyword">null</font>) {</p><p>				</font>db = SQLiteDatabase.create(<font class="keyword">null</font>);</p><p>			</font>} <font class="keyword">else </font>{</p><p>				String path = getDatabasePath(mName).getPath();</p><p>				db = SQLiteDatabase.DatabopenOrCreatease(path, mFactory);</p><p>			}</p><p>			<font class="keyword">int </font>version = db.getVersion();</p><p>			<font class="keyword">if </font>(version != mNewVersion) {</p><p>				db.beginTransaction();</p><p>				<font class="keyword">try </font>{</p><p>					<font class="keyword">if </font>(version == 0) {</p><p>						onCreate(db);</p><p>					</font>} <font class="keyword">else </font>{</p><p>						onUpgrade(db, version, mNewVersion);</p><p>					}</p><p>					db.setVersion(mNewVersion);</p><p>					db.setTransactionSuccessful();</p><p>				} finally {</p><p>					db.endTransaction();</p><p>				}</p><p>			}</p><p>			onOpen(db);</p><p>			</font>success = <font class="keyword">true</font>;</p><p>			<font class="keyword">return </font>db;</p><p>		} finally {</p><p>			</font>mIsInitializing = <font class="keyword">false</font>;</p><p>			<font class="keyword">if </font>(success) {</p><p>				<font class="keyword">if </font>(mDatabase != </font><font class="keyword">null</font>) {</p><p>					<font class="keyword">try </font>{</p><p>						mDatabase.close();</p><p>					</font>} <font class="keyword">catch </font>(Exception e) {</p><p>					}</p><p>				}</p><p>				mDatabase = db;</p><p>			</font>} <font class="keyword">else </font>{</p><p>				<font class="keyword">if </font>(db != </font><font class="keyword">null</font>)</p><p>					db.close();</p><p>			}</p><p>		}</p><p>	}</p><p>	<font class="Comments">/**</font></p><p>	 <font class="Comments">* Create and/or open a database. This will be the same object returned by</font></p><p>	 <font class="Comments">* {@link getWritableDatabase} unless some problem, such as a full disk,</font></p><p>	 <font class="Comments">* requires the database to be opened read-only. In that case, a read-only</font></p><p>	 <font class="Comments">* database object will be returned. If the problem is fixed, a future call</font></p><p>	 <font class="Comments">* to {@link getWritableDatabase} may succeed, in which case the read-only</font></p><p>	 <font class="Comments">* database object will be closed and the read/write object will be returned</font></p><p>	 <font class="Comments">* in the future.</font></p><p>	 <font class="Comments">* </font></p><p>	 <font class="Comments">* @throws SQLiteException</font></p><p>	 <font class="Comments">*             if the database cannot be opened</font></p><p>	 <font class="Comments">* @return a database object valid until {@link getWritableDatabase} or</font></p><p>	 <font class="Comments">*         {@link close} is called.</font></p><p>	 <font class="Comments">*/</font></p><p>	<font class="keyword">public </font><font class="keyword">synchronized </font>SQLiteDatabase getReadableDatabase() {</p><p>		<font class="keyword">if </font>(mDatabase != </font><font class="keyword">null</font> && mDatabase.isOpen()) {</p><p>			<font class="keyword">return </font>mDatabase; <font class="Comments">// The database is already open </font><font class="keyword">for </font>business</font></p><p>		}</p><p>		<font class="keyword">if </font>(mIsInitializing) {</p><p>			<font class="keyword">throw </font><font class="keyword">new </font>IllegalStateException(</p><p>					<font class="Fields">"getReadableDatabase called recursively"</font>);</p><p>		}</p><p>		<font class="keyword">try </font>{</p><p>			<font class="keyword">return </font>getWritableDatabase();</p><p>		</font>} <font class="keyword">catch </font>(SQLiteException e) {</p><p>			<font class="keyword">if </font>(mName == </font><font class="keyword">null</font>)</p><p>				<font class="keyword">throw </font>e; <font class="Comments">// Can<font class="Fields">'t open a temp database read-only!</font></p><p>			</font>Log.e(TAG, <font class="Fields">"Couldn</font><font class="Fields">'t open "</font> + mName</p><p>					</font>+ <font class="Fields">" <font class="keyword">for </font>writing (will </font><font class="keyword">try </font>read-only):"</font>, e);</p><p>		}</p><p>		</font>SQLiteDatabase db = <font class="keyword">null</font>;</p><p>		<font class="keyword">try </font>{</p><p>			</font>mIsInitializing = <font class="keyword">true</font>;</p><p>			String path = getDatabasePath(mName).getPath();</p><p>			db = SQLiteDatabase.openDatabase(path, mFactory,</p><p>					SQLiteDatabase.OPEN_READWRITE);</p><p>			<font class="keyword">if </font>(db.getVersion() != mNewVersion) {</p><p>				<font class="keyword">throw </font><font class="keyword">new </font>SQLiteException(</p><p>						<font class="Fields">"Can</font><font class="Fields">'t upgrade read-only database from version </p><p>								</font>+ db.getVersion() + <font class="Fields">" to "</font> + mNewVersion + </font><font class="Fields">":</p><p>								+ path);</p><p>			}</p><p>			onOpen(db);</p><p>			</font>Log.w(TAG, <font class="Fields">"Opened "</font> + mName + </font><font class="Fields">" in read-only mode"</font>);</p><p>			mDatabase = db;</p><p>			<font class="keyword">return </font>mDatabase;</p><p>		} finally {</p><p>			</font>mIsInitializing = <font class="keyword">false</font>;</p><p>			<font class="keyword">if </font>(db != </font><font class="keyword">null</font> && db != mDatabase)</p><p>				db.close();</p><p>		}</p><p>	}</p><p>	<font class="Comments">/**</font></p><p>	 <font class="Comments">* Close any open database object.</font></p><p>	 <font class="Comments">*/</font></p><p>	<font class="keyword">public </font><font class="keyword">synchronized </font><font class="keyword">void </font>close() {</p><p>		<font class="keyword">if </font>(mIsInitializing)</p><p>			<font class="keyword">throw </font><font class="keyword">new </font>IllegalStateException(<font class="Fields">"Closed during initialization"</font>);</p><p>		<font class="keyword">if </font>(mDatabase != </font><font class="keyword">null</font> && mDatabase.isOpen()) {</p><p>			mDatabase.close();</p><p>			</font>mDatabase = <font class="keyword">null</font>;</p><p>		}</p><p>	}</p><p>	<font class="keyword">public </font>File getDatabasePath(String name) {</p><p>		<font class="keyword">return </font><font class="keyword">new </font>File(<font class="Fields">"/sdcard/"</font> + name);</p><p>	}</p><p>	<font class="Comments">/**</font></p><p>	 <font class="Comments">* Called when the database is created for the first time. This is where the</font></p><p>	 <font class="Comments">* creation of tables and the initial population of the tables should</font></p><p>	 <font class="Comments">* happen.</font></p><p>	 <font class="Comments">* </font></p><p>	 <font class="Comments">* @param db</font></p><p>	 <font class="Comments">*            The database.</font></p><p>	 <font class="Comments">*/</font></p><p>	<font class="keyword">public </font><font class="keyword">abstract </font><font class="keyword">void </font>onCreate(SQLiteDatabase db);</p><p>	<font class="Comments">/**</font></p><p>	 <font class="Comments">* Called when the database needs to be upgraded. The implementation should</font></p><p>	 <font class="Comments">* use this method to drop tables, add tables, or do anything else it needs</font></p><p>	 <font class="Comments">* to upgrade to the new schema version.</font></p><p>	 <font class="Comments">* </font></p><p>	 <font class="Comments">* &lt;p&gt;</font></p><p>	 <font class="Comments">* The SQLite ALTER TABLE documentation can be found &lt;a</font></p><p>	 <font class="Comments">* href="http://sqlite.org/lang_altertable.html"&gt;here&lt;/a&gt;. If you add new</font></p><p>	 <font class="Comments">* columns you can use ALTER TABLE to insert them into a live table. If you</font></p><p>	 <font class="Comments">* rename or remove columns you can use ALTER TABLE to rename the old table,</font></p><p>	 <font class="Comments">* then create the new table and then populate the new table with the</font></p><p>	 <font class="Comments">* contents of the old table.</font></p><p>	 <font class="Comments">* </font></p><p>	 <font class="Comments">* @param db</font></p><p>	 <font class="Comments">*            The database.</font></p><p>	 <font class="Comments">* @param oldVersion</font></p><p>	 <font class="Comments">*            The old database version.</font></p><p>	 <font class="Comments">* @param newVersion</font></p><p>	 <font class="Comments">*            The new database version.</font></p><p>	 <font class="Comments">*/</font></p><p>	<font class="keyword">public </font><font class="keyword">abstract </font><font class="keyword">void </font>onUpgrade(SQLiteDatabase db, </font><font class="keyword">int </font>oldVersion,</p><p>			<font class="keyword">int </font>newVersion);</p><p>	<font class="Comments">/**</font></p><p>	 <font class="Comments">* Called when the database has been opened. Override method should check</font></p><p>	 <font class="Comments">* {@link SQLiteDatabaseisReadOnly} before updating the database.</font></p><p>	 <font class="Comments">* </font></p><p>	 <font class="Comments">* @param db</font></p><p>	 <font class="Comments">*            The database.</font></p><p>	 <font class="Comments">*/</font></p><p>	<font class="keyword">public </font><font class="keyword">void </font>onOpen(SQLiteDatabase db) {</p><p>	}</p><p>}</p><p></pre></p><p></p></div>

</DIV></DIV>

<DIV id=footer style="display:none">
<P align="center">  
 
 
 
    </P>
</DIV></BODY></HTML>

