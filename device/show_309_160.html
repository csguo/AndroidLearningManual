
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>Android 监听电话状态并自动接听来电_Android学习手册</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<META name=GENERATOR content="MSHTML 8.00.6001.18702">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">

</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li ><A href="../component/index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li class="navcurrentLink"><A href="index.html">设备功能</A> </li><li ><A href="../datastorage/index.html">数据存储</A> </li><li ><A href="../network/index.html">网络应用</A> </li><li ><A href="../game/index.html">游戏开发</A> </li><li ><A href="../multimedia/index.html">多媒体</A> </li><li ><A href="../source/index.html">源码开发</A> </li><li ><A href="../advance/index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">课 程 表</div>


  <h2><A title="设备信息" href="index_157.html">设备信息</A></h2>

  <h2><A title="摄像头" href="index_158.html">摄像头</A></h2>

  <h2><A title="通讯录" href="index_159.html">通讯录</A></h2>

  <h2><A title="电话" href="index_160.html">电话</A></h2>
<UL><li ><A title=Andriod 解析通话处理流程（一） href="show_301_160.html">Andriod 解析通话处理流程（一）</A> </li><li ><A title=Andriod 解析通话处理流程（二） href="show_302_160.html">Andriod 解析通话处理流程（二）</A> </li><li ><A title=Andriod 解析通话处理流程（三） href="show_303_160.html">Andriod 解析通话处理流程（三）</A> </li><li ><A title=Andriod 解析通话处理流程（四） href="show_304_160.html">Andriod 解析通话处理流程（四）</A> </li><li ><A title=Andriod 解析通话处理流程（五） href="show_305_160.html">Andriod 解析通话处理流程（五）</A> </li><li ><A title=Android 主被动获取打接电话状态 href="show_306_160.html">Android 主被动获取打接电话状态</A> </li><li ><A title=Android 设置铃声+震动 href="show_307_160.html">Android 设置铃声+震动</A> </li><li ><A title=Android 删除未接来电通知 href="show_308_160.html">Android 删除未接来电通知</A> </li><li class="currentLink"><A title=Android 监听电话状态并自动接听来电 href="show_309_160.html">Android 监听电话状态并自动接听来电</A> </li></UL>
  <h2><A title="短信" href="index_161.html">短信</A></h2>

  <h2><A title="传感器" href="index_162.html">传感器</A></h2>

  <h2><A title="定位" href="index_163.html">定位</A></h2>

  <h2><A title="视频系统" href="index_164.html">视频系统</A></h2>

  <h2><A title="音频系统" href="index_165.html">音频系统</A></h2>

  <h2><A title="铃声" href="index_166.html">铃声</A></h2>

  <h2><A title="音量" href="index_167.html">音量</A></h2>

  <h2><A title="录音" href="index_168.html">录音</A></h2>

  <h2><A title="输入法" href="index_169.html">输入法</A></h2>

</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1></H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>Android 监听电话状态并自动接听来电</H2>
<div style="line-height:20px; font-size:14px;"><p>一、开发环境</p><p>Elispse，JDK1.6，Aadroid 2.1</p><p>二、开发中使用到的重点技术点：</p><p>距离感应(SENSOR_SERVICE ),音讯管理(AUDIO_SERVICE ),</p><p>电话状态监听 (TELEPHONY_SERVICE)，</p><p>java反射启动自动接听,开机自动启动Service，</p><p>监听来电，在Service 中启动Activity 并传递参数</p><p>三、主要开发流程：</p><p>1. 在前三步中我们看到有一个公共的辅助类CommonHelper</p><p><pre><font class="keyword">import </font>android.content.Context;</p><p><font class="keyword">import </font>android.content.Intent;</p><p><font class="keyword">public </font><font class="keyword">class </font>CommonHelper { <font class="Comments">// 保存电话状态</font></p><p>	<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">int </font>phoneState = 0; <font class="Comments">// 保存音讯管理对象</font></p><p>	<font class="keyword">public </font><font class="keyword">static </font>MyAudioManager mam = </font><font class="keyword">null</font>; <font class="Comments">// 保存去点电话号码</font></p><p>	<font class="keyword">public </font><font class="keyword">static </font>String outGoingPhoneNumber = <font class="Fields">""</font>;</p><p>	<font class="Comments">// 启动一个新的Activity</font></p><p>	<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">void </font>StartCustomerInfoActivity(Context context, String telNo) {</p><p>		<font class="Comments">// 第一个参数</font></p><p>		<font class="Comments">// 启动新的Acitivity的Context;</font></p><p>		<font class="Comments">// 第二个参数</font></p><p>		<font class="Comments">// 启动的Acitivity的类</font></p><p>		</font>Intent intent = <font class="keyword">new </font>Intent(context, CustomerInfo.</font><font class="keyword">class</font>); <font class="Comments">// 在Service中启动一个Activity并需添加此Flag</font></p><p>		intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); <font class="Comments">// 启动新的Activity时传递的参数</font></p><p>		</font>intent.putExtra(<font class="Fields">"TelNo"</font>, telNo); <font class="Comments">// 启动新的Activity</font></p><p>		context.startActivity(intent);</p><p>	}</p><p>}</p><p></pre></p><p>其实将这个类放到第一步是不合适的，因为这个公共类实在我不断写码过程中完善的，并不是一开始就创建的。</p><p>2.首先我们建立我们一个音讯管理的类，用于管理当来电或者去点时扩音器的开关。</p><p><pre><font class="keyword">import </font>android.content.Context;</p><p><font class="keyword">import </font>android.media.AudioManager;</p><p><font class="keyword">public </font><font class="keyword">class </font>MyAudioManager {</p><p>	<font class="keyword">private </font>AudioManager audioManager;</p><p>	<font class="keyword">private </font><font class="keyword">int </font>currVolume = 0;</p><p>	<font class="keyword">public </font>MyAudioManager(Object object, Context mc) {</p><p>		<font class="Comments">// 音频管理对象由外部调用时传入（http:<font class="Comments">//www.my400800.cn ）</font></p><p>		<font class="Comments">// this.audioManager=(AudioManager)object; this.context=mc;</font></p><p>		<font class="Comments">// <font class="Comments">//设置音讯模式为对外输出</font></p><p>		<font class="keyword">this</font>.audioManager.setMode(AudioManager.ROUTE_SPEAKER); <font class="Comments">// 取得当前的音量</font></p><p>		currVolume = audioManager</p><p>				.getStreamVolume(AudioManager.STREAM_VOICE_CALL);</p><p>	}</p><p>	<font class="Comments">// 打开扬声器</font></p><p>	<font class="keyword">public </font><font class="keyword">void </font>OpenSpeaker() { <font class="Comments">// 设置为</font><font class="keyword">true</font>，打开扬声器</font></p><p>		</font>audioManager.setSpeakerphoneOn(<font class="keyword">true</font>); <font class="Comments">// 设置打开扬声器的音量为最大</font></p><p>		audioManager</p><p>				.setStreamVolume(AudioManager.STREAM_VOICE_CALL, audioManager</p><p>						.getStreamMaxVolume(AudioManager.STREAM_VOICE_CALL),</p><p>						AudioManager.STREAM_VOICE_CALL);</p><p>		<font class="Comments">// Toast.makeText(context,"扬声器已经打开",Toast.LENGTH_SHORT).show();</font></p><p>	}</p><p>	<font class="Comments">// 关闭扬声器</font></p><p>	<font class="keyword">public </font><font class="keyword">void </font>CloseSpeaker() { <font class="Comments">// 设置为</font><font class="keyword">false</font>，关闭已经打开的扬声器</font></p><p>		</font>audioManager.setSpeakerphoneOn(<font class="keyword">false</font>); <font class="Comments">// 恢复为正常音量</font></p><p>		audioManager.setStreamVolume(AudioManager.STREAM_VOICE_CALL,</p><p>				currVolume, AudioManager.STREAM_VOICE_CALL);</p><p>		<font class="Comments">// Toast.makeText(context,"扬声器已经关闭",Toast.LENGTH_SHORT).show();</font></p><p>	}</p><p>}</p><p></pre></p><p>3.建立一个监听电话状态的类</p><p><pre><font class="keyword">import </font>java.lang.reflect.InvocationTargetException;</p><p><font class="keyword">import </font>java.lang.reflect.Method;</p><p><font class="keyword">import </font>com.android.internal.*;</p><p><font class="keyword">import </font>com.android.internal.telephony.ITelephony;</p><p><font class="keyword">import </font>android.content.Context;</p><p><font class="keyword">import </font>android.os.RemoteException;</p><p><font class="keyword">import </font>android.telephony.PhoneStateListener;</p><p><font class="keyword">import </font>android.telephony.TelephonyManager;</p><p><font class="keyword">import </font>android.widget.Toast;</p><p><font class="keyword">public </font><font class="keyword">class </font>SpeakMananger {</p><p>	<font class="keyword">private </font>TelephonyManager teleManager;</p><p>	<font class="keyword">private </font>Context context;</p><p>	<font class="keyword">public </font>SpeakMananger(Object object, Context p_context) { <font class="Comments">// 转换从外部传入的Object为TelephonyManager对象</font></p><p>		<font class="keyword">this</font>.teleManager = (TelephonyManager) object;</p><p>		<font class="keyword">this</font>.context = p_context;</p><p>	}</p><p>	<font class="Comments">// 注册电话状态监听器</font></p><p>	<font class="keyword">public </font><font class="keyword">void </font>RegisterListener() {</p><p>		</font>teleManager.listen(<font class="keyword">new </font>MyPhoneStateListener(),</p><p>				PhoneStateListener.LISTEN_CALL_STATE);</p><p>	}</p><p>	<font class="keyword">class </font>MyPhoneStateListener </font><font class="keyword">extends </font>PhoneStateListener {</p><p>		@Override</p><p>		<font class="keyword">public </font><font class="keyword">void </font>onCallStateChanged(</font><font class="keyword">int </font>state, String incomingNumber) {</p><p>			<font class="keyword">super</font>.onCallStateChanged(state, incomingNumber);</p><p>			<font class="keyword">switch </font>(state) {</p><p>			<font class="Comments">// 空闲 没有电话打入或者打出 处于挂机空闲状态</font></p><p>			<font class="keyword">case </font>TelephonyManager.CALL_STATE_IDLE:</p><p>				<font class="Comments">// Toast.makeText(context,"空闲",Toast.LENGTH_SHORT).show();</font></p><p>				<font class="keyword">break</font>;</p><p>			<font class="Comments">// 摘机 有电话打出或者打入 按接听接或者其它操作拨打或接听来电</font></p><p>			<font class="keyword">case </font>TelephonyManager.CALL_STATE_OFFHOOK:</p><p>				<font class="Comments">// Toast.makeText(context,"摘机",Toast.LENGTH_SHORT).show();</font></p><p></p><p>				<font class="Comments">// 去电 如果是去电则incomingNumber为null或""</font></p><p>				<font class="Comments">// <font class="Comments">//【因为此处无法监听去电并且无法去电的电话号码，所以当去电时此处的打入电话号码为null或者""】</font></p><p>				<font class="keyword">if </font>(incomingNumber == </font><font class="keyword">null</font> || incomingNumber.length() &lt;= 0) { <font class="Comments">// 打开扬声器</font></p><p>					CommonHelper.mam.OpenSpeaker(); <font class="Comments">// 根据公共类中保存的去电电话号码启动一个新的Activity</font></p><p>					CommonHelper.StartCustomerInfoActivity(context,</p><p>							CommonHelper.outGoingPhoneNumber);</p><p>				}</p><p>				<font class="Comments">// else <font class="Comments">//来电 本人是需要在来电振铃的时候就打开扩音器和启动一个新的Acitivity，所以此处被注释掉</font></p><p>				<font class="Comments">// CommonHelper.StartCustomerInfoActivity(context,incomingNumber);</font></p><p>				<font class="Comments">// break;</font></p><p>				<font class="Comments">// 振铃 在此处我需要在振铃的时候自动接听电话并且打开扬声器和新启动一个Activity</font></p><p>			<font class="keyword">case </font>TelephonyManager.CALL_STATE_RINGING:</p><p>				<font class="Comments">// Toast.makeText(context,"振铃",Toast.LENGTH_SHORT).show();</font></p><p>				<font class="keyword">try </font>{</p><p>					/* 以下两种方法都可以使用 都能完成自动接听 但是第一种的异常信息处理的比较完善 */</p><p>					<font class="Comments">// StartCall();</font></p><p>					answerPhoneAidl(); <font class="Comments">// 新启动一个Activity</font></p><p>					CommonHelper.StartCustomerInfoActivity(context,</p><p>							incomingNumber);</p><p>				</font>} <font class="keyword">catch </font>(Exception e) {</p><p>					</font>Toast.makeText(context, <font class="Fields">"自动接听发生异常："</font> + e.getMessage(),</p><p>							Toast.LENGTH_LONG).show();</p><p>				}</p><p>				<font class="keyword">break</font>;</p><p>			} <font class="Comments">// 保存当前电话状态</font></p><p>			CommonHelper.phoneState = state;</p><p>		}</p><p>	}</p><p>	<font class="Comments">// 此自动接听代码来自官方开源Demo http:<font class="Comments">//code.google.com/p/auto-answer/source/detail?r=17</font></p><p>	<font class="keyword">private </font><font class="keyword">void </font>answerPhoneAidl() </font><font class="keyword">throws </font>Exception {</p><p>		Class c = Class.forName(teleManager.getClass().getName());</p><p>		</font>Method m = c.getDeclaredMethod(<font class="Fields">"getITelephony"</font>, (Class[]) <font class="keyword">null</font>);</p><p>		</font>m.setAccessible(<font class="keyword">true</font>);</p><p>		ITelephony telephonyService;</p><p>		</font>telephonyService = (ITelephony) m.invoke(teleManager, (Object[]) <font class="keyword">null</font>);</p><p>		<font class="Comments">// Silence the ringer and answer the call!</font></p><p>		telephonyService.silenceRinger();</p><p>		telephonyService.answerRingingCall();</p><p>	}</p><p>	<font class="Comments">/**</font></p><p>	 <font class="Comments">* 利用JAVA反射机制调用ITelephony的answerRingingCall()开始通话。</font></p><p>	 <font class="Comments">*/</font></p><p>	<font class="keyword">private </font><font class="keyword">void </font>StartCall() {</p><p>		<font class="Comments">// 初始化iTelephony</font></p><p>		</font>Class&lt;TelephonyManager&gt; c = TelephonyManager.<font class="keyword">class</font>;</p><p>		</font>Method getITelephonyMethod = <font class="keyword">null</font>;</p><p>		<font class="keyword">try </font>{</p><p>			<font class="Comments">// 获取所有public/private/protected/默认</font></p><p>			<font class="Comments">// 方法的函数，如果只需要获取public方法，则可以调用getMethod.</font></p><p>			</font>getITelephonyMethod = c.getDeclaredMethod(<font class="Fields">"getITelephony"</font>,</p><p>					</font>(Class[]) <font class="keyword">null</font>);</p><p>			<font class="Comments">// 将要执行的方法对象设置是否进行访问检查，也就是说对于public/private/protected/默认</font></p><p>			<font class="Comments">// 我们是否能够访问。值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。值为 false</font></p><p>			<font class="Comments">// 则指示反射的对象应该实施 Java 语言访问检查。</font></p><p>			</font>getITelephonyMethod.setAccessible(<font class="keyword">true</font>);</p><p>		</font>} <font class="keyword">catch </font>(SecurityException e) {</p><p>			</font>Toast.makeText(context, <font class="Fields">"安全异常："</font> + e.getMessage(),</p><p>					Toast.LENGTH_SHORT).show();</p><p>		</font>} <font class="keyword">catch </font>(NoSuchMethodException e) {</p><p>			</font>Toast.makeText(context, <font class="Fields">"未找到方法："</font> + e.getMessage(),</p><p>					Toast.LENGTH_SHORT).show();</p><p>		}</p><p>		<font class="keyword">try </font>{</p><p>			ITelephony iTelephony = (ITelephony) getITelephonyMethod.invoke(</p><p>					</font>teleManager, (Object[]) <font class="keyword">null</font>); <font class="Comments">// 停止响铃</font></p><p>			iTelephony.silenceRinger(); <font class="Comments">// 接听来电</font></p><p>			iTelephony.answerRingingCall();</p><p>		</font>} <font class="keyword">catch </font>(IllegalArgumentException e) {</p><p>			</font>Toast.makeText(context, <font class="Fields">"参数异常："</font> + e.getMessage(),</p><p>					Toast.LENGTH_SHORT).show();</p><p>		</font>} <font class="keyword">catch </font>(IllegalAccessException e) {</p><p>			</font>Toast.makeText(context, <font class="Fields">"进入权限异常："</font> + e.getMessage(),</p><p>					Toast.LENGTH_SHORT).show();</p><p>		</font>} <font class="keyword">catch </font>(InvocationTargetException e) {</p><p>			</font>Toast.makeText(context, <font class="Fields">"目标异常："</font> + e.getMessage(),</p><p>					Toast.LENGTH_SHORT).show();</p><p>		</font>} <font class="keyword">catch </font>(RemoteException e) {</p><p>			</font>Toast.makeText(context, <font class="Fields">"Remote异常："</font> + e.getMessage(),</p><p>					Toast.LENGTH_SHORT).show();</p><p>		}</p><p>	}</p><p>}</p><p></pre></p><p>4.建立一个用于监听距离感应的类</p><p><pre><font class="keyword">import </font>android.hardware.Sensor;</p><p><font class="keyword">import </font>android.hardware.SensorEvent;</p><p><font class="keyword">import </font>android.hardware.SensorEventListener;</p><p><font class="keyword">import </font>android.hardware.SensorManager;</p><p><font class="keyword">import </font>android.telephony.TelephonyManager;</p><p><font class="keyword">public </font><font class="keyword">class </font>ProximitySensor {</p><p>	<font class="keyword">private </font>SensorManager sensorManager;</p><p>	<font class="keyword">private </font>Sensor sensor;</p><p>	<font class="keyword">private </font>SensorEventListener listener;</p><p>	<font class="keyword">public </font>ProximitySensor(Object object) { <font class="Comments">// 获得外部传入的SensorManager对象</font></p><p>		<font class="keyword">this</font>.sensorManager = (SensorManager) object; <font class="Comments">// 取得距离感应类型的感应器</font></p><p>		<font class="keyword">this</font>.sensor = sensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY);</p><p>		</font>listener = <font class="keyword">new </font>SensorEventListener() {</p><p>			@Override</p><p>			<font class="keyword">public </font><font class="keyword">void </font>onAccuracyChanged(Sensor sensor, </font><font class="keyword">int </font>accuracy) {</p><p>			}</p><p>			@Override</p><p>			<font class="keyword">public </font><font class="keyword">void </font>onSensorChanged(SensorEvent event) {</p><p>				<font class="keyword">if </font>(event.values[0] == 1.0) {</p><p>					<font class="keyword">switch </font>(CommonHelper.phoneState) {</p><p>					<font class="Comments">// 空闲 离开耳边并且电话空闲的状态，关闭扬声器</font></p><p>					<font class="keyword">case </font>TelephonyManager.CALL_STATE_IDLE:</p><p>						CommonHelper.mam.CloseSpeaker();</p><p>						<font class="keyword">break</font>;</p><p>					<font class="Comments">// 摘机 离开耳边并且电话状态为摘机状态，打开扬声器</font></p><p>					<font class="keyword">case </font>TelephonyManager.CALL_STATE_OFFHOOK:</p><p>						CommonHelper.mam.OpenSpeaker();</p><p>						<font class="keyword">break</font>;</p><p>					}</p><p>				</font>} <font class="keyword">else </font>{ <font class="Comments">// 耳边接听电话关闭扬声器</font></p><p>					CommonHelper.mam.CloseSpeaker();</p><p>				}</p><p>			}</p><p>		};</p><p>	}</p><p>	<font class="Comments">// 注册监听器</font></p><p>	<font class="keyword">public </font><font class="keyword">void </font>RegisterListener() {</p><p>		<font class="keyword">this</font>.sensorManager.registerListener(listener, sensor,</p><p>				SensorManager.SENSOR_DELAY_FASTEST);</p><p>	}</p><p>	<font class="Comments">// 移除监听器</font></p><p>	<font class="keyword">public </font><font class="keyword">void </font>UnRegisterListener() {</p><p>		<font class="keyword">this</font>.sensorManager.unregisterListener(listener);</p><p>	}</p><p>}</p><p></pre></p><p>5.现在我们建立我们的Service</p><p><pre><font class="keyword">import </font>android.app.Service;</p><p><font class="keyword">import </font>android.content.Intent;</p><p><font class="keyword">import </font>android.os.IBinder;</p><p><font class="keyword">public </font><font class="keyword">class </font>PhoneCallStateService </font><font class="keyword">extends </font>Service {</p><p>	@Overide</p><p>	<font class="keyword">public </font>IBinder onBind(Intent intent) {</p><p>		<font class="keyword">return </font><font class="keyword">null</font>;</p><p>	}</p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">void </font>onCreate() {</p><p>		<font class="keyword">super</font>.onCreate();</p><p>	}</p><p>	/* 在Service启动的时候，实例化我们刚才建立的所有类 */</p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">void </font>onStart(Intent intent, </font><font class="keyword">int </font>startId) {</p><p>		<font class="keyword">super</font>.onStart(intent, startId);</p><p>		<font class="Comments">// 音频管理服务</font></p><p>		</font>MyAudioManager am = <font class="keyword">new </font>MyAudioManager(</p><p>				<font class="keyword">this</font>.getSystemService(AUDIO_SERVICE), </font><font class="keyword">this</font>); <font class="Comments">// 将音讯管理对象保存到公共类中</font></p><p>		CommonHelper.mam = am;</p><p>		<font class="Comments">// 电话-监听-服务【是否有来电、去电、是否空闲】</font></p><p>		</font>SpeakMananger sm = <font class="keyword">new </font>SpeakMananger(</p><p>				<font class="keyword">this</font>.getSystemService(TELEPHONY_SERVICE), </font><font class="keyword">this</font>);</p><p>		sm.RegisterListener();</p><p>		<font class="Comments">// 距离感应</font></p><p>		</font>ProximitySensor ps = <font class="keyword">new </font>ProximitySensor(</p><p>				<font class="keyword">this</font>.getSystemService(SENSOR_SERVICE));</p><p>		ps.RegisterListener();</p><p>	}</p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">void </font>onDestroy() {</p><p>		<font class="keyword">super</font>.onDestroy();</p><p>	}</p><p>}</p><p></pre></p><p>6.建立一个广播接收类，用于在开机启动完毕后启动我们的Service，并且监听去电获得去电电话号码</p><p><pre><font class="keyword">import </font>android.content.BroadcastReceiver;</p><p><font class="keyword">import </font>android.content.Context;</p><p><font class="keyword">import </font>android.content.Intent; /*</p><p> <font class="Comments">* 1.首先开机启动后系统会发出一个Standard Broadcast Action，</font></p><p> <font class="Comments">*    名字叫android.intent.action.BOOT_COMPLETED，这个Action只会发出一次。</font></p><p> <font class="Comments">* 2.构造一个BroadcastReceiver类，重构其抽象方法onReceive(Context context, Intent intent)，</font></p><p> <font class="Comments">*         在其中启动你想要启动的Service。</font></p><p> <font class="Comments">* 3.在AndroidManifest.xml中，首先加入</font></p><p> <font class="Comments">*    &lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"&gt;&lt;/uses-permission&gt;</font></p><p> <font class="Comments">*    来获得BOOT_COMPLETED的使用许可，然后注册前面重构的IntentReceiver类，</font></p><p> <font class="Comments">*    在其&lt;intent-filter&gt;中加入&lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt; ，</font></p><p> <font class="Comments">*    以使其能捕捉到这个Action。       </font></p><p> <font class="Comments">* 参考文档： </font></p><p> <font class="Comments">*/</font></p><p><font class="keyword">public </font><font class="keyword">class </font>StartReceiver </font><font class="keyword">extends </font>BroadcastReceiver {</p><p>	/* 要接收的intent源 */</p><p>	<font class="keyword">static </font><font class="keyword">final </font>String ACTION = <font class="Fields">"android.intent.action.BOOT_COMPLETED"</font>;</p><p>	<font class="keyword">public </font><font class="keyword">void </font>onReceive(Context context, Intent intent) {</p><p>		<font class="Comments">// 如果系统已经开机完毕，则启动电话状态服务</font></p><p>		<font class="keyword">if </font>(intent.getAction().equals(ACTION)) {</p><p>			<font class="Comments">// 启动电话状态服务</font></p><p>			</font>context.startService(<font class="keyword">new </font>Intent(context,</p><p>					</font>PhoneCallStateService.<font class="keyword">class</font>));</p><p>		}</p><p>		/*</p><p>		 <font class="Comments">* intent.getAction().equals(Intent.ACTION_NEW_OUTGOING_CALL) 去电</font></p><p>		 <font class="Comments">* intent.getAction().equals(Intent.ACTION_CALL)) 来电</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="Comments">// 监听去电获得去电电话号码</font></p><p>		<font class="keyword">if </font>(intent.getAction().equals(Intent.ACTION_NEW_OUTGOING_CALL)) {</p><p>			CommonHelper.outGoingPhoneNumber = intent</p><p>					.getStringExtra(Intent.EXTRA_PHONE_NUMBER);</p><p>		}</p><p>	}</p><p>}</p><p></pre></p><p>7.由有上述类需要使用到一些权限，所以我们要在我们的AndroidManifest.xml配置文件中做如下修改：</p><p><pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;</p><p>&lt;manifest xmlns:android=" http://schemas.android.com/apk/res/android "</p><p>    package="com.org.speaker"</p><p>    android:versionCode="1"</p><p>    android:versionName="1.0" &gt;</p><p>    &lt;application android:icon="@drawable/icon" &gt;</p><p>        &lt;activity android:name="CustomerInfo" &gt;</p><p>        &lt;/activity&gt;</p><p>        &lt;receiver android:name="StartReceiver" &gt;</p><p>            &lt;intent-filter&gt;</p><p>                &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt;</p><p></p><p>                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;</p><p>                &lt;!-- 添加过滤条件 监听电话状态 --&gt;</p><p>                &lt;action android:name="android.intent.action.PHONE_STATE" /&gt;</p><p>                &lt;!-- 监听电话拨出 --&gt;</p><p>                &lt;action android:name="android.intent.action.NEW_OUTGOING_CALL" /&gt;</p><p>            &lt;/intent-filter&gt;</p><p>        &lt;/receiver&gt;</p><p>        &lt;service</p><p>            android:name="PhoneCallStateService"</p><p>            android:enabled="true" &gt;</p><p>        &lt;/service&gt;</p><p>    &lt;/application&gt;</p><p>    &lt;uses-sdk android:minSdkVersion="4" /&gt;</p><p>    &lt;!-- 连接互联网的权限 --&gt;</p><p>    &lt;uses-permission android:name="android.permission.INTERNET" /&gt;</p><p>    &lt;!-- 读取手机状态的权限 --&gt;</p><p>    &lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt;</p><p>    &lt;!-- 接收手机开机广播的权限 --&gt;</p><p>    &lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" /&gt;</p><p>    &lt;!-- 更改音讯设置的权限 --&gt;</p><p>    &lt;uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" /&gt;</p><p>    &lt;!-- 使用SD卡的权限 这个是我个人用到的 大家可以不使用 --&gt;</p><p>    &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;</p><p>    &lt;!-- 监听去电的权限 --&gt;</p><p>    &lt;uses-permission android:name="android.permission.PROCESS_OUTGOING_CALLS" /&gt;</p><p>    &lt;!-- 修改电话状态的权限 --&gt;</p><p>    &lt;uses-permission android:name="android.permission.MODIFY_PHONE_STATE" /&gt;</p><p>    &lt;!-- 监听来电的权限 --&gt;</p><p>    &lt;uses-permission android:name="android.permission.CALL_PHONE" /&gt;</p><p>&lt;/manifest&gt;</p><p></pre></p><p></p></div>

</DIV></DIV>

<DIV id=footer style="display:none">
<P align="center">  
 
 
 
    </P>
</DIV></BODY></HTML>

