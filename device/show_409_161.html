
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>短信的收发及在android模拟器之间实践（一）_Android学习手册</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<META name=GENERATOR content="MSHTML 8.00.6001.18702">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">

</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li ><A href="../component/index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li class="navcurrentLink"><A href="index.html">设备功能</A> </li><li ><A href="../datastorage/index.html">数据存储</A> </li><li ><A href="../network/index.html">网络应用</A> </li><li ><A href="../game/index.html">游戏开发</A> </li><li ><A href="../multimedia/index.html">多媒体</A> </li><li ><A href="../source/index.html">源码开发</A> </li><li ><A href="../advance/index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">课 程 表</div>


  <h2><A title="设备信息" href="index_157.html">设备信息</A></h2>

  <h2><A title="摄像头" href="index_158.html">摄像头</A></h2>

  <h2><A title="通讯录" href="index_159.html">通讯录</A></h2>

  <h2><A title="电话" href="index_160.html">电话</A></h2>

  <h2><A title="短信" href="index_161.html">短信</A></h2>
<UL><li ><A title=Android sms讲解 href="show_401_161.html">Android sms讲解</A> </li><li ><A title=Android 发送和接收短信实例（一） href="show_402_161.html">Android 发送和接收短信实例（一）</A> </li><li ><A title=Android 发送和接收短信实例（二） href="show_403_161.html">Android 发送和接收短信实例（二）</A> </li><li ><A title=Android 发送和接收短信实例（三） href="show_404_161.html">Android 发送和接收短信实例（三）</A> </li><li ><A title=Android 监听SMS消息 href="show_405_161.html">Android 监听SMS消息</A> </li><li ><A title=Android 追踪和确认SMS消息传递 href="show_406_161.html">Android 追踪和确认SMS消息传递</A> </li><li ><A title=Android 读取短信 href="show_407_161.html">Android 读取短信</A> </li><li ><A title=Android SMS小结 href="show_408_161.html">Android SMS小结</A> </li><li class="currentLink"><A title=短信的收发及在android模拟器之间实践（一） href="show_409_161.html">短信的收发及在android模拟器之间实践（一）</A> </li><li ><A title=短信的收发及在android模拟器之间实践（二） href="show_410_161.html">短信的收发及在android模拟器之间实践（二）</A> </li><li ><A title=如何在你的程序中嵌入收发短信功能 href="show_411_161.html">如何在你的程序中嵌入收发短信功能</A> </li><li ><A title=系统短信库的一些用法 href="show_412_161.html">系统短信库的一些用法</A> </li><li ><A title=在Android中发送短信和彩信 href="show_413_161.html">在Android中发送短信和彩信</A> </li><li ><A title=怎么编写代码实现拦截一些网络垃圾短信 href="show_414_161.html">怎么编写代码实现拦截一些网络垃圾短信</A> </li><li ><A title=Android调用系统短信Intent时将预填接收号码 href="show_415_161.html">Android调用系统短信Intent时将预填接收号码</A> </li><li ><A title=Android广播监听短信并显示内容 href="show_416_161.html">Android广播监听短信并显示内容</A> </li></UL>
  <h2><A title="传感器" href="index_162.html">传感器</A></h2>

  <h2><A title="定位" href="index_163.html">定位</A></h2>

  <h2><A title="视频系统" href="index_164.html">视频系统</A></h2>

  <h2><A title="音频系统" href="index_165.html">音频系统</A></h2>

  <h2><A title="铃声" href="index_166.html">铃声</A></h2>

  <h2><A title="音量" href="index_167.html">音量</A></h2>

  <h2><A title="录音" href="index_168.html">录音</A></h2>

  <h2><A title="输入法" href="index_169.html">输入法</A></h2>

</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1></H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>短信的收发及在android模拟器之间实践（一）</H2>
<div style="line-height:20px; font-size:14px;"><p style="color:#3333FF;">引言</p><p>本文通过运行两个Android模拟器，介绍在Android中如何实现短信服务（SMS，short message service）的功能。通过这个例子，我想带给大家的是：更加熟悉之前介绍过的Android应用程序的概念及技术细节，且通过实例调度大家的兴趣。我之所以选择SMS为例子，主要原因是SMS已经非常成熟了，从中可以发掘更多的信息和技术细节，而且我相信大部分人发短信比打电话多。</p><p>本文的主要内容如下：</p><p><pre>1、温故知新</p><p>2、准备工作：SMS涉及的主要类SmsManager</p><p>3、简单的SMS发送程序</p><p>3.1、运行SMS程序给另一个android模拟器发短</p><p>4、SMS增强（一）</p><p>5、SMS增强（二）</p><p>6、SMS接收程序（下篇）</p><p>7、emulator工具（下篇）</p><p></pre></p><p style="color:#3333FF;">1、温故知新</p><p>广播接收者：一个广播接收者是这样一个组件，它不做什么事，仅是接受广播公告并作出相应的反应。许多广播源自于系统代码，例如公告时区的改变、电池电量低、已采取图片、用户改变了语言偏好。应用程序也可以发起广播，例如为了他其他程序知道某些数据已经下载到设备且他们可以使用这些数据</p><p>BroadcastReceiver类：是接受sendBroadcast()发送的意图（intents）的基类。可以用Context.registerReceiver()动态地注册这个类的实例，或者通过AndroidManifest.xml中标签静态发布。 </p><p>广播接收者不显示一个用户界面。然而，它们启动一个活动去响应收到的信息，或者他们可能使用NotificationManager去通知用户。通知可以使用多种方式获得用户的注意——闪烁的背光、振动设备、播放声音等等。典型的是放在一个持久的图标在状态栏，用户可以打开获取信息。</p><p style="color:#3333FF;">2、准备工作：SMS涉及的主要类SmsManager</p><p>实现SMS主要用到SmsManager类，该类继承自java.lang.Object类，下面我们介绍一下该类的主要成员。</p><p>公有方法：</p><p>ArrayList&lt; span&gt;String&lt;divideMessage(String text) </p><p>当短信超过SMS消息的最大长度时，将短信分割为几块。 </p><p>参数：text——初始的消息，不能为空 </p><p>返回值：有序的ArrayList&lt; span&gt;String&lt;，可以重新组合为初始的消息 &lt;/span&gt;</p><p>staticSmsManagergetDefault() </p><p>获取SmsManager的默认实例。 </p><p>返回值：SmsManager的默认实例</p><p>voidSendDataMessage(String destinationAddress,String scAddress,short destinationPort,byte[] data,PendingIntent sentIntent, PendingIntent deliveryIntent) </p><p>发送一个基于SMS的数据到指定的应用程序端口。 </p><p>参数： </p><p>1)、destinationAddress——消息的目标地址。</p><p>2)、scAddress——服务中心的地址or为空使用当前默认的SMSC 3)destinationPort——消息的目标端口号。</p><p>4)、data——消息的主体，即消息要发送的数据。</p><p>5)、sentIntent——如果不为空，当消息成功发送或失败这个PendingIntent就广播。结果代码是Activity.RESULT_OK表示成功，或RESULT_ERROR_GENERIC_FAILURE、RESULT_ERROR_RADIO_OFF、RESULT_ERROR_NULL_PDU之一表示错误。对应RESULT_ERROR_GENERIC_FAILURE，sentIntent可能包括额外的“错误代码”包含一个无线电广播技术特定的值，通常只在修复故障时有用。 </p><p>每一个基于SMS的应用程序控制检测sentIntent。如果sentIntent是空，调用者将检测所有未知的应用程序，这将导致在检测的时候发送较小数量的SMS。 </p><p>6)、deliveryIntent——如果不为空，当消息成功传送到接收者这个PendingIntent就广播。</p><p>异常：如果destinationAddress或data是空时，抛出IllegalArgumentException异常。</p><p>void sendMultipartTextMessage(String destinationAddress,String scAddress, ArrayList&lt; span&gt;String&lt;parts, ArrayList&lt; span&gt;PendingIntent&lt; sentIntents, ArrayList&lt; span&gt;PendingIntent&lt;deliverIntents) </p><p>发送一个基于SMS的多部分文本，调用者应用已经通过调用divideMessage(String text)将消息分割成正确的大小。 </p><p>参数： </p><p>1)、destinationAddress——消息的目标地址。</p><p>2)、scAddress——服务中心的地址or为空使用当前默认的SMSC。</p><p>3)、parts——有序的ArrayList&lt; span&gt;String&lt;，可以重新组合为初始的消息。</p><p>4)、sentIntents——跟SendDataMessage方法中一样，只不过这里的是一组PendingIntent。</p><p>5)、deliverIntents——跟SendDataMessage方法中一样，只不过这里的是一组PendingIntent。</p><p>异常：如果destinationAddress或data是空时，抛出IllegalArgumentException异常。</p><p>void sendTextMessage(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent) </p><p>发送一个基于SMS的文本。参数的意义和异常前面的已存在的一样，不再累述。</p><p>常量：</p><p><pre><font class="keyword"></font><font class="keyword">public static final int </font></font>RESULT_ERROR_GENERIC_FAILURE </p><p>表示普通错误，值为1(0x00000001)</p><p><font class="keyword">public static final int </font>RESULT_ERROR_NO_SERVICE</p><p>表示服务当前不可用，值为4 (0x00000004)</p><p><font class="keyword">public static final int </font>RESULT_ERROR_NULL_PDU</p><p>表示没有提供pdu，值为3 (0x00000003)</p><p><font class="keyword">public static final int </font>RESULT_ERROR_RADIO_OFF</p><p>表示无线广播被明确地关闭，值为2 (0x00000002)</p><p><font class="keyword">public static final int </font>STATUS_ON_ICC_FREE</p><p>表示自由空间，值为0 (0x00000000)</p><p><font class="keyword">public static final int </font>STATUS_ON_ICC_READ</p><p>表示接收且已读，值为1 (0x00000001)</p><p><font class="keyword">public static final int </font>STATUS_ON_ICC_SENT</p><p>表示存储且已发送，值为5 (0x00000005)</p><p><font class="keyword">public static final int </font>STATUS_ON_ICC_UNREAD</p><p>表示接收但未读，值为3 (0x00000003)</p><p><font class="keyword">public static final int </font>STATUS_ON_ICC_UNSENT</p><p>表示存储但为发送，值为7 (0x00000007)</p><p></pre></p><p style="color:#3333FF;">3、简单的SMS发送程序</p><p>1)、首先，编辑布局文件res/layout/main.xml，达到我们想要的结果，界面如下：</p><p><img src="../img/device_sms/09_sms.jpg"></p><p>图1、程序运行界面</p><p>对应的xml代码如下：</p><p><pre>&lt;?xml version=<font class="Fields">"1.0"</font> encoding=</font><font class="Fields">"utf-8"</font>?&gt;</p><p>&lt;LinearLayout xmlns:android=<font class="Fields">"http:<font class="Comments">//schemas.android.com/apk/res/android</font></p><p>    </font>android:layout_width=<font class="Fields">"fill_parent</p><p>    </font>android:layout_height=<font class="Fields">"fill_parent</p><p>    </font>android:orientation=<font class="Fields">"vertical"</font> &gt;</p><p>    &lt;TextView</p><p>        </font>android:layout_width=<font class="Fields">"fill_parent</p><p>        </font>android:layout_height=<font class="Fields">"wrap_content</p><p>        </font>android:text=<font class="Fields">"@string/txtPhoneNo"</font> /&gt;</p><p>    </font>&lt;!-- text<font class="Fields">'s value define in res/values/strings.xml --&gt;</p><p>    &lt;EditText</p><p>        </font>android:id=<font class="Fields">"@+id/edtPhoneNo</p><p>        </font>android:layout_width=<font class="Fields">"fill_parent</p><p>        </font>android:layout_height=<font class="Fields">"wrap_content"</font> /&gt;</p><p>    &lt;TextView</p><p>        </font>android:layout_width=<font class="Fields">"fill_parent</p><p>        </font>android:layout_height=<font class="Fields">"wrap_content</p><p>        </font>android:text=<font class="Fields">"@string/txtContent"</font> /&gt;</p><p>    &lt;EditText</p><p>        </font>android:id=<font class="Fields">"@+id/edtContent</p><p>        </font>android:layout_width=<font class="Fields">"fill_parent</p><p>        </font>android:layout_height=<font class="Fields">"wrap_content</p><p>        </font>android:minLines=<font class="Fields">"3"</font> /&gt;</p><p>    &lt;Button</p><p>        </font>android:id=<font class="Fields">"@+id/btnSend</p><p>        </font>android:layout_width=<font class="Fields">"wrap_content</p><p>        </font>android:layout_height=<font class="Fields">"wrap_content</p><p>        </font>android:text=<font class="Fields">"@string/btnText"</font> /&gt;</p><p>&lt;/LinearLayout&gt;</p><p></pre></p><p>相应的要在res/values/strings.xm中添加上面定义的视图的text的值，如下：</p><p><pre>&lt;?xml version=<font class="Fields">"1.0"</font> encoding=</font><font class="Fields">"utf-8"</font>?&gt;</p><p>&lt;resources&gt;</p><p>    </font>&lt;string name=<font class="Fields">"txtPhoneNo"</font>&gt;Please input phone NO:&lt;/string&gt;</p><p>    </font>&lt;string name=<font class="Fields">"txtContent"</font>&gt;Please input SMS\</font><font class="Fields">'s content:&lt;/string&gt;</p><p>    </font>&lt;string name=<font class="Fields">"btnText"</font>&gt;send!&lt;/string&gt;</p><p>    </font>&lt;string name=<font class="Fields">"app_name"</font>&gt;SMS&lt;/string&gt;</p><p>&lt;/resources&gt;</p><p></pre></p><p>2)、做完这些准备工作之后，我么要开始编写代码实现简单的短信发送了。</p><p>通过第一步我们构建好界面之后，现在要在上面的基础上编写业务逻辑了。大致过程为：在java源文件中，获取用户在edtPhoneNo中输入的电话号码，edtContent中输入要发送的内容；然后点击btnSend按钮发送短信，要达到这个目的我们要设置btnSend的OnClickListener以达到当点击它触发发送短信的功能，而且要发送短信就要用到我们前面介绍的SmsManager类提供的方法接口。</p><p></p><p>设置btnSend的OnClickListener的代码如下：</p><p><pre></font>btnSend.setOnClickListener(<font class="keyword">new </font>View.OnClickListener() {</p><p>	<font class="keyword">public </font><font class="keyword">void </font>onClick(View v) {</p><p>		String phoneNo = edtPhoneNo.getText().toString();</p><p>		String message = edtContent.getText().toString();</p><p>		<font class="keyword">if </font>(phoneNo.length() &gt; 0 && message.length() &gt; 0) {</p><p>			<font class="Comments">// call sendSMS to send message to phoneNo</font></p><p>			sendSMS(phoneNo, message);</p><p>		</font>}<font class="keyword"> else</font></p><p>			Toast.makeText(getBaseContext(),</p><p>					<font class="Fields">"Please enter both phone number and message."</font>,</p><p>					Toast.LENGTH_SHORT).show();</p><p>	}</p><p>});</p><p></pre></p><p>发送短信的功能的代码如下：</p><p><pre><font class="keyword">private </font><font class="keyword">void </font>sendSMS(String phoneNumber, String message) {</p><p>	<font class="Comments">// ---sends an SMS message to another device---</font></p><p>	SmsManager sms = SmsManager.getDefault();</p><p>	</font>PendingIntent pi = PendingIntent.getActivity(<font class="keyword">this</font>, 0, </font><font class="keyword">new </font>Intent(</font><font class="keyword">this</font>,</p><p>			</font>TextMessage.<font class="keyword">class</font>), 0);</p><p>	<font class="Comments">// if message's length more than 70 ,</font></p><p>	<font class="Comments">// then call divideMessage to dive message into several part</font></p><p>	<font class="Comments">// and call sendTextMessage()</font></p><p>	<font class="Comments">// else direct call sendTextMessage()</font></p><p>	<font class="keyword">if </font>(message.length() &gt; 70) {</p><p>		ArrayList&lt;String&gt; msgs = sms.divideMessage(message);</p><p>		<font class="keyword">for </font>(String msg : msgs) {</p><p>			</font>sms.sendTextMessage(phoneNumber, <font class="keyword">null</font>, msg, pi, </font><font class="keyword">null</font>);</p><p>		}</p><p>	</font>} <font class="keyword">else </font>{</p><p>		</font>sms.sendTextMessage(phoneNumber, <font class="keyword">null</font>, message, pi, </font><font class="keyword">null</font>);</p><p>	}</p><p>	</font>Toast.makeText(TextMessage.<font class="keyword">this</font>, <font class="Fields">"短信发送完成"</font>, Toast.LENGTH_LONG).show();</p><p>}</p><p></pre></p><p>如果你已经看了第2节介绍的SmsManager类的介绍，代码应该很好理解。在这里要说明的是，sendTextMessage方法中的第4个和第5个参数PendingIntent设为null，这样的话不能根据短信发出之后的状态做相应的事情，如短信发送失败后的提醒、接收者成功接收后的回执……完整的流程源码如下：</p><p><pre><font class="keyword">import </font>java.util.ArrayList;</p><p><font class="keyword">import </font>android.app.Activity;</p><p><font class="keyword">import </font>android.app.PendingIntent;</p><p><font class="keyword">import </font>android.content.Intent;</p><p><font class="keyword">import </font>android.os.Bundle;</p><p><font class="keyword">import </font>android.telephony.SmsManager;</p><p><font class="keyword">import </font>android.view.View;</p><p><font class="keyword">import </font>android.widget.*;</p><p><font class="keyword">public </font><font class="keyword">class </font>TextMessage </font><font class="keyword">extends </font>Activity {</p><p>	<font class="Comments">/** Called when the activity is first created. */</font></p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">void </font>onCreate(Bundle savedInstanceState) {</p><p>		<font class="keyword">super</font>.onCreate(savedInstanceState);</p><p>		setContentView(R.layout.main);</p><p>		btnSend = (Button) findViewById(R.id.btnSend);</p><p>		edtPhoneNo = (EditText) findViewById(R.id.edtPhoneNo);</p><p>		edtContent = (EditText) findViewById(R.id.edtContent);</p><p>		</font>btnSend.setOnClickListener(<font class="keyword">new </font>View.OnClickListener() {</p><p>			<font class="keyword">public </font><font class="keyword">void </font>onClick(View v) {</p><p>				String phoneNo = edtPhoneNo.getText().toString();</p><p>				String message = edtContent.getText().toString();</p><p>				<font class="keyword">if </font>(phoneNo.length() &gt; 0 && message.length() &gt; 0) {</p><p>					<font class="Comments">// call sendSMS to send message to phoneNo</font></p><p>					sendSMS(phoneNo, message);</p><p>				</font>}<font class="keyword"> else</font></p><p>					Toast.makeText(getBaseContext(),</p><p>							<font class="Fields">"Please enter both phone number and message."</font>,</p><p>							Toast.LENGTH_SHORT).show();</p><p>			}</p><p>		});</p><p>	}</p><p>	<font class="keyword">private </font>Button btnSend;</p><p>	<font class="keyword">private </font>EditText edtPhoneNo;</p><p>	<font class="keyword">private </font>EditText edtContent;</p><p>	<font class="keyword">private </font><font class="keyword">void </font>sendSMS(String phoneNumber, String message) {</p><p>		<font class="Comments">// ---sends an SMS message to another device---</font></p><p>		SmsManager sms = SmsManager.getDefault();</p><p>		</font>PendingIntent pi = PendingIntent.getActivity(<font class="keyword">this</font>, 0, </font><font class="keyword">new </font>Intent(</font><font class="keyword">this</font>,</p><p>				</font>TextMessage.<font class="keyword">class</font>), 0);</p><p>		<font class="Comments">// if message's length more than 70 ,</font></p><p>		<font class="Comments">// then call divideMessage to dive message into several part ,and call</font></p><p>		<font class="Comments">// sendTextMessage()</font></p><p>		<font class="Comments">// else direct call sendTextMessage()</font></p><p>		<font class="keyword">if </font>(message.length() &gt; 70) {</p><p>			ArrayList&lt;String&gt; msgs = sms.divideMessage(message);</p><p>			<font class="keyword">for </font>(String msg : msgs) {</p><p>				</font>sms.sendTextMessage(phoneNumber, <font class="keyword">null</font>, msg, pi, </font><font class="keyword">null</font>);</p><p>			}</p><p>		</font>} <font class="keyword">else </font>{</p><p>			</font>sms.sendTextMessage(phoneNumber, <font class="keyword">null</font>, message, pi, </font><font class="keyword">null</font>);</p><p>		}</p><p>		</font>Toast.makeText(TextMessage.<font class="keyword">this</font>, <font class="Fields">"短信发送完成"</font>, Toast.LENGTH_LONG).show();</p><p>	}</p><p>}</p><p></pre></p><p>3）运行前，还要在清单文件AndroidManifest.xml中加入允许发送短信的权限：</p><p><pre>&lt;?xml version=<font class="Fields">"1.0"</font> encoding=</font><font class="Fields">"utf-8"</font>?&gt;</p><p>&lt;manifest xmlns:android=<font class="Fields">"http:<font class="Comments">//schemas.android.com/apk/res/android</font></p><p>    </font>package=<font class="Fields">"skynet.com.cnblogs.www</p><p>    </font>android:versionCode=<font class="Fields">"1</p><p>    </font>android:versionName=<font class="Fields">"1.0"</font> &gt;</p><p>    &lt;application</p><p>        </font>android:icon=<font class="Fields">"@drawable/icon</p><p>        </font>android:label=<font class="Fields">"@string/app_name"</font> &gt;</p><p>        &lt;activity</p><p>            </font>android:name=<font class="Fields">".TextMessage</p><p>            </font>android:label=<font class="Fields">"@string/app_name"</font> &gt;</p><p>            &lt;intent-filter&gt;</p><p>                </font>&lt;action android:name=<font class="Fields">"android.intent.action.MAIN"</font> /&gt;</p><p>                </font>&lt;category android:name=<font class="Fields">"android.intent.category.LAUNCHER"</font> /&gt;</p><p>            &lt;/intent-filter&gt;</p><p>        &lt;/activity&gt;</p><p>    &lt;/application&gt;</p><p>    </font>&lt;uses-permission android:name=<font class="Fields">"android.permission.SEND_SMS"</font> /&gt;</p><p>&lt;/manifest&gt;</p><p></pre></p><p style="color:#3333FF;">3.1、运行SMS程序给另一个android模拟器发短信</p><p>运行上面我们编写的TextMessage程序，另外在Windows的命令行下切换到tools目录下，并输入emulator –data smsReceiver，我的如下：</p><p><img src="../img/device_sms/09_sms2.jpg"></p><p>这样就会启动一个android模拟器，如下所示：（注意它的编号：5556，就是用这个编号与它通信的）</p><p><img src="../img/device_sms/09_sms3.jpg"></p><p>图2、通过emulator启动一个android模拟器</p><p>通过我们TextMessage程序启动的android模拟器，编写短信：</p><p><img src="../img/device_sms/09_sms4.jpg"></p><p>图3、TextMessage程序个5556模拟器发短信</p><p>点击发送之后，通过命令行启动的5556号android模拟器会收到我们刚才发送的短信，如下所示：</p><p><img src="../img/device_sms/09_sms5.jpg"></p><p>图4、收到短信的提示</p><p>tips：</p><p>如果通过命令行的emulator启动android模拟器提示“NO DNS servers found！”，这时我们发的短信模拟器是收不到的。</p><p>在Windows下，如果电脑没有介入网络，即找不DNS服务器的话会出现这种情况！</p><p>在Mac下，如果提示这个警告的话，可以这样解决：检查你是否有/etc/resolv.conf文件，如果没有的话，通过下面的命令行</p><p>ln -s /private/var/run/resolv.conf /etc/resolv.conf可以解决。</p><p style="color:#3333FF;">4、SMS增强（一）</p><p>上面我们实现了一个简单的SMS程序，下面我们要对它进行增强！你肯定已经注意到了，我们上面的SMS程序的sendTextMessage方法中的第4个和第5个参数PendingIntent设为null，即sentIntent和deliveryIntent。</p><p>第4个参数-sendIntent，当消息成功发送或发送失败都将被触发。广播接收者的结果码，Activity.RESULT_OK表示成功，或RESULT_ERROR_GENERIC_FAILURE、RESULT_ERROR_RADIO_OFF、RESULT_ERROR_NULL_PDU之一表示错误。对应RESULT_ERROR_GENERIC_FAILURE，sentIntent可能包括额外的“错误代码”包含一个无线电广播技术特定的值，通常只在修复故障时有用。第5个参数-deliveryIntent，仅当目标接收到你的SMS消息才触发。</p><p>为了跟踪发出的短信的状态，实现和注册Broadcast Receiver（广播接收者）监听传递给sendTextMessage方法的参数Pending Intents。下面我们就实现和注册这个广播接收者：</p><p><pre></font>String SENT_SMS_ACTION=<font class="Fields">"SENT_SMS_ACTION"</font>;</p><p></font>String DELIVERED_SMS_ACTION=<font class="Fields">"DELIVERED_SMS_ACTION"</font>;</p><p><font class="Comments">//create the sentIntent parameter</font></p><p></font>Intent sentIntent=<font class="keyword">new </font>Intent(SENT_SMS_ACTION);</p><p>PendingIntent sentPI=PendingIntent.getBroadcast(</p><p>		<font class="keyword">this</font>,</p><p>		0,</p><p>		sentIntent,</p><p>		0);</p><p><font class="Comments">//create the deilverIntent parameter</font></p><p></font>Intent deliverIntent=<font class="keyword">new </font>Intent(DELIVERED_SMS_ACTION);</p><p>PendingIntent deliverPI=PendingIntent.getBroadcast(</p><p>		<font class="keyword">this</font>,</p><p>		0,</p><p>		deliverIntent,</p><p>		0);</p><p><font class="Comments">//register the Broadcast Receivers</font></p><p></font>registerReceiver(<font class="keyword">new </font>BroadcastReceiver(){</p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">void </font>onReceive(Context _context,Intent _intent)</p><p>	{</p><p>		switch(getResultCode()){</p><p>			<font class="keyword">case </font>Activity.RESULT_OK:</p><p>				Toast.makeText(getBaseContext(),</p><p>						<font class="Fields">"SMS sent success actions"</font>,</p><p>						Toast.LENGTH_SHORT).show();</p><p>				<font class="keyword">break</font>;</p><p>			<font class="keyword">case </font>SmsManager.RESULT_ERROR_GENERIC_FAILURE:</p><p>				Toast.makeText(getBaseContext(),</p><p>						<font class="Fields">"SMS generic failure actions"</font>,</p><p>						Toast.LENGTH_SHORT).show();</p><p>				<font class="keyword">break</font>;</p><p>			<font class="keyword">case </font>SmsManager.RESULT_ERROR_RADIO_OFF:</p><p>				Toast.makeText(getBaseContext(),</p><p>						<font class="Fields">"SMS radio off failure actions"</font>,</p><p>						Toast.LENGTH_SHORT).show();</p><p>				<font class="keyword">break</font>;</p><p>			<font class="keyword">case </font>SmsManager.RESULT_ERROR_NULL_PDU:</p><p>				Toast.makeText(getBaseContext(),</p><p>						<font class="Fields">"SMS <font class="keyword">null</font> PDU failure actions"</font>,</p><p>						Toast.LENGTH_SHORT).show();</p><p>				<font class="keyword">break</font>;</p><p>		}</p><p>	}</p><p>},</p><p><font class="keyword">new </font>IntentFilter(SENT_SMS_ACTION));</p><p></font>registerReceiver(<font class="keyword">new </font>BroadcastReceiver(){</p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">void </font>onReceive(Context _context,Intent _intent)</p><p>	{</p><p>		Toast.makeText(getBaseContext(),</p><p>				<font class="Fields">"SMS delivered actions"</font>,</p><p>				Toast.LENGTH_SHORT).show();</p><p>	}</p><p>},</p><p><font class="keyword">new </font>IntentFilter(DELIVERED_SMS_ACTION));</p><p></pre></p><p>在基本完成了要做的工作，接下来要做的就是将sendTextMessage的第4个和第5个参数改为sentPI、deliverPI，这样工作基本完成，修改后的sendSMS方法如下：</p><p><pre><font class="keyword">private </font><font class="keyword">void </font>sendSMS(String phoneNumber, String message) {</p><p>	<font class="Comments">// ---sends an SMS message to another device---</font></p><p>	SmsManager sms = SmsManager.getDefault();</p><p>	</font>String SENT_SMS_ACTION = <font class="Fields">"SENT_SMS_ACTION"</font>;</p><p>	</font>String DELIVERED_SMS_ACTION = <font class="Fields">"DELIVERED_SMS_ACTION"</font>;</p><p></p><p>	<font class="Comments">// create the sentIntent parameter</font></p><p>	</font>Intent sentIntent = <font class="keyword">new </font>Intent(SENT_SMS_ACTION);</p><p>	</font>PendingIntent sentPI = PendingIntent.getBroadcast(<font class="keyword">this</font>, 0, sentIntent,</p><p>			0);</p><p></p><p>	<font class="Comments">// create the deilverIntent parameter</font></p><p>	</font>Intent deliverIntent = <font class="keyword">new </font>Intent(DELIVERED_SMS_ACTION);</p><p>	</font>PendingIntent deliverPI = PendingIntent.getBroadcast(<font class="keyword">this</font>, 0,</p><p>			deliverIntent, 0);</p><p></p><p>	<font class="Comments">// register the Broadcast Receivers</font></p><p>	</font>registerReceiver(<font class="keyword">new </font>BroadcastReceiver() {</p><p>		@Override</p><p>		<font class="keyword">public </font><font class="keyword">void </font>onReceive(Context _context, Intent _intent) {</p><p>			<font class="keyword">switch </font>(getResultCode()) {</p><p>			<font class="keyword">case </font>Activity.RESULT_OK:</p><p>				Toast.makeText(getBaseContext(),</p><p>						<font class="Fields">"SMS sent success actions"</font>, Toast.LENGTH_SHORT)</p><p>						.show();</p><p>				<font class="keyword">break</font>;</p><p>			<font class="keyword">case </font>SmsManager.RESULT_ERROR_GENERIC_FAILURE:</p><p>				Toast.makeText(getBaseContext(),</p><p>						<font class="Fields">"SMS generic failure actions"</font>, Toast.LENGTH_SHORT)</p><p>						.show();</p><p>				<font class="keyword">break</font>;</p><p>			<font class="keyword">case </font>SmsManager.RESULT_ERROR_RADIO_OFF:</p><p>				Toast.makeText(getBaseContext(),</p><p>						<font class="Fields">"SMS radio off failure actions"</font>, Toast.LENGTH_SHORT)</p><p>						.show();</p><p>				<font class="keyword">break</font>;</p><p>			<font class="keyword">case </font>SmsManager.RESULT_ERROR_NULL_PDU:</p><p>				Toast.makeText(getBaseContext(),</p><p>						<font class="Fields">"SMS <font class="keyword">null</font> PDU failure actions"</font>, Toast.LENGTH_SHORT)</p><p>						.show();</p><p>				<font class="keyword">break</font>;</p><p>			}</p><p>		}</p><p>	</font>}, <font class="keyword">new </font>IntentFilter(SENT_SMS_ACTION));</p><p>	</font>registerReceiver(<font class="keyword">new </font>BroadcastReceiver() {</p><p>		@Override</p><p>		<font class="keyword">public </font><font class="keyword">void </font>onReceive(Context _context, Intent _intent) {</p><p>			</font>Toast.makeText(getBaseContext(), <font class="Fields">"SMS delivered actions"</font>,</p><p>					Toast.LENGTH_SHORT).show();</p><p>		}</p><p>	</font>}, <font class="keyword">new </font>IntentFilter(DELIVERED_SMS_ACTION));</p><p></p><p>	<font class="Comments">// if message's length more than 70 ,</font></p><p>	<font class="Comments">// then call divideMessage to dive message into several part ,and call</font></p><p>	<font class="Comments">// sendTextMessage()</font></p><p>	<font class="Comments">// else direct call sendTextMessage()</font></p><p>	<font class="keyword">if </font>(message.length() &gt; 70) {</p><p>		ArrayList&lt;String&gt; msgs = sms.divideMessage(message);</p><p>		<font class="keyword">for </font>(String msg : msgs) {</p><p>			</font>sms.sendTextMessage(phoneNumber, <font class="keyword">null</font>, msg, sentPI, deliverPI);</p><p>		}</p><p>	</font>} <font class="keyword">else </font>{</p><p>		</font>sms.sendTextMessage(phoneNumber, <font class="keyword">null</font>, message, sentPI, deliverPI);</p><p>	}</p><p>}</p><p></pre></p><p>运行之后的，发送短信成功的话就可以看到如下界面：</p><p><img src="../img/device_sms/09_sms6.jpg"></p><p>图5、增强SMS（一）</p><p style="color:#3333FF;">5、SMS增强（二）</p><p>下面这个增强是使SMS能够发送二进制数据。要发送数据要使用SmsManager类的sendDataMessage方法，跟sendTextMessage方法类似，只不过该方法多了一个目标端口的参数，构建该SMS的过程跟前面的类似这里就不在累述。</p><p></p></div>

</DIV></DIV>

<DIV id=footer style="display:none">
<P align="center">  
 
 
 
    </P>
</DIV></BODY></HTML>

