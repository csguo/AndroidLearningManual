
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>OpenGL ES基础教程（二）_Android学习手册</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<META name=GENERATOR content="MSHTML 8.00.6001.18702">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">

</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li ><A href="../component/index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li ><A href="../device/index.html">设备功能</A> </li><li ><A href="../datastorage/index.html">数据存储</A> </li><li ><A href="../network/index.html">网络应用</A> </li><li class="navcurrentLink"><A href="index.html">游戏开发</A> </li><li ><A href="../multimedia/index.html">多媒体</A> </li><li ><A href="../source/index.html">源码开发</A> </li><li ><A href="../advance/index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">课 程 表</div>


  <h2><A title="游戏开发须知" href="index_187.html">游戏开发须知</A></h2>

  <h2><A title="游戏策划、设计分析" href="index_188.html">游戏策划、设计分析</A></h2>

  <h2><A title="Android OpenGL学习" href="index_190.html">Android OpenGL学习</A></h2>
<UL><li ><A title=Android OpenGL基础实例（一） href="show_301_190.html">Android OpenGL基础实例（一）</A> </li><li ><A title=Android OpenGL基础实例（二） href="show_302_190.html">Android OpenGL基础实例（二）</A> </li><li ><A title=Android OpenGL基础实例（三） href="show_303_190.html">Android OpenGL基础实例（三）</A> </li><li ><A title=Android OpenGL基础实例（四） href="show_304_190.html">Android OpenGL基础实例（四）</A> </li><li ><A title=Android 浅谈OpenGL ES（一） href="show_305_190.html">Android 浅谈OpenGL ES（一）</A> </li><li ><A title=Android 浅谈OpenGL ES（二） href="show_306_190.html">Android 浅谈OpenGL ES（二）</A> </li><li ><A title=OpenGL ES基础教程（一） href="show_307_190.html">OpenGL ES基础教程（一）</A> </li><li class="currentLink"><A title=OpenGL ES基础教程（二） href="show_308_190.html">OpenGL ES基础教程（二）</A> </li><li ><A title=Android OpenGL实战一—开发框架搭建、三角形和四边形的绘制 href="show_309_190.html">Android OpenGL实战一—开发框架搭建、三角形和四边形的绘制</A> </li><li ><A title=Android OpenGL实战二—颜色和旋转 href="show_310_190.html">Android OpenGL实战二—颜色和旋转</A> </li><li ><A title=Android 3D OpenGL开发之一— 变幻的背景色 href="show_311_190.html">Android 3D OpenGL开发之一— 变幻的背景色</A> </li><li ><A title=Android 3D OpenGL开发之二 —旋转的三角形 href="show_312_190.html">Android 3D OpenGL开发之二 —旋转的三角形</A> </li><li ><A title=Android 3D OpenGL开发之三 —漂亮的金字塔 href="show_313_190.html">Android 3D OpenGL开发之三 —漂亮的金字塔</A> </li><li ><A title=OpenGL ES 2.0实现的3D（一） href="show_314_190.html">OpenGL ES 2.0实现的3D（一）</A> </li><li ><A title=OpenGL ES 2.0实现的3D（二） href="show_315_190.html">OpenGL ES 2.0实现的3D（二）</A> </li><li ><A title=OpenGL ES 2.0实现的3D（三） href="show_316_190.html">OpenGL ES 2.0实现的3D（三）</A> </li><li ><A title=OpenGL核心函数库 href="show_317_190.html">OpenGL核心函数库</A> </li><li ><A title=OpenGL ES绘制3D图形 href="show_318_190.html">OpenGL ES绘制3D图形</A> </li><li ><A title=OpenGL ES 如何判断点击滑动线路位于哪个平面？ href="show_319_190.html">OpenGL ES 如何判断点击滑动线路位于哪个平面？</A> </li><li ><A title=OpenGL ES 学习阶段性总结 href="show_320_190.html">OpenGL ES 学习阶段性总结</A> </li><li ><A title=Android 图形绘制（Skia EGL OpenGL ES） href="show_321_190.html">Android 图形绘制（Skia EGL OpenGL ES）</A> </li><li ><A title=Android Graphic:apk and SkiaOpenGLES href="show_322_190.html">Android Graphic:apk and SkiaOpenGLES</A> </li><li ><A title=Android里的FrameBuffer href="show_323_190.html">Android里的FrameBuffer</A> </li></UL>
  <h2><A title="Android游戏开发之旅" href="index_191.html">Android游戏开发之旅</A></h2>

  <h2><A title="Android2D游戏开发" href="index_192.html">Android2D游戏开发</A></h2>

  <h2><A title="Android经典实例教程解析" href="index_193.html">Android经典实例教程解析</A></h2>

  <h2><A title="Android游戏开发实例" href="index_194.html">Android游戏开发实例</A></h2>

  <h2><A title="Libgdx游戏引擎" href="index_195.html">Libgdx游戏引擎</A></h2>

</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1></H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>OpenGL ES基础教程（二）</H2>
<div style="line-height:20px; font-size:14px;"><p>二、绘制多边形</p><p>前面的教程都是关于设置GLSurfaceView.的，接下来的教程将教我们渲染出一个多边形。3D模型用较小的元素创建（点，边，面），他们可以被分别操作。</p><p>顶点</p><p><img src="../img/games_opengl/08_opengl.jpg"></p><p><img src="../img/games_opengl/08_opengl2.jpg"></p><p>在Android中，我们通过float数组定义顶点，并将它放到字节型缓冲区内来获取更好的性能。</p><p>下例的代码即为上图所示顶点。</p><p>OpenGL ES的很多功能都必须手动的开启和关闭。</p><p><pre>gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);</p><p>// 设置顶点数据，3代表XYZ坐标系</p><p>gl.glVertexPointer(3, GL10.GL_FLOAT, 0, vertexBuffer);</p><p>// 关闭顶点设置</p><p>gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);</p><p></pre></p><p>边</p><p><img src="../img/games_opengl/08_opengl3.jpg"></p><p>面</p><p><img src="../img/games_opengl/08_opengl4.jpg"></p><p>计算多边形面的时候，一定要注意正确的方向.。因为这将决定哪一面为正面哪一面为背面。 所以我们尽量保证整个项目都使用相同的环绕。</p><p style="color:#3333FF;">gl.glFrontFace(GL10.GL_CCW);</p><p>控制多边形的正面是如何决定的。在默认情况下，mode是GL_CCW。</p><p>mode的值为： 　　</p><p>GL_CCW 表示窗口坐标上投影多边形的顶点顺序为逆时针方向的表面为正面。 　　</p><p>GL_CW 表示顶点顺序为顺时针方向的表面为正面。</p><p>顶点的方向又称为环绕。</p><p style="color:#3333FF;">gl.glEnable(GL10.GL_CULL_FACE);</p><p style="color:#3333FF;">gl.glCullFace(GL10.GL_BACK);</p><p>剔除多边形的背面，禁用多边形背面上的光照、阴影和颜色计算及操作。</p><p style="color:#3333FF;">gl.glDisable(GL10.GL_CULL_FACE);  </p><p>多边形</p><p><img src="../img/games_opengl/08_opengl5.jpg"></p><p><img src="../img/games_opengl/08_opengl6.jpg"></p><p>到了绘制面的时候了， 我们使用默认的逆时针环绕。</p><p>下例代码将绘制上图多边形。</p><p><pre>// 将坐标数组放入字节缓存中</p><p>// (1) 分配缓存，一个short为2个字节，所以要乘以2</p><p>ByteBuffer ibb = ByteBuffer.allocateDirect(indices.length * 2);</p><p>// (2) 设置字节处理规则</p><p>ibb.order(ByteOrder.nativeOrder());</p><p>// (3) 转换为short型字符</p><p>ShortBuffer indexBuffer = ibb.asShortBuffer();</p><p>// (4) 放入坐标数组</p><p>indexBuffer.put(indices);</p><p>// (5) 复位</p><p>indexBuffer.position(0);</p><p></pre></p><p>渲染</p><p>是时候弄些玩意儿到屏幕上去了，绘制时我们将用到两个函数</p><p><pre>public abstract void glDrawArrays(int mode, int first, int count)</p><p></pre></p><p>通过我们构造的顶点缓存来绘制顶点</p><p><pre>public abstract void glDrawElements(int mode, int count, int type, Buffer indices)</p><p></pre></p><p>和glDrawArrays类似，但需要直接传入type（索引值的类型，如GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT），和indices（索引缓存）</p><p>两者的共同点是，都必须知道他们需要画什么。怎样渲染图元，有不同方式，为了帮助调试，我们应该了解它们。</p><p>Mode：</p><p>GL_POINTS</p><p>绘制独立的点到屏幕</p><p><img src="../img/games_opengl/08_opengl7.jpg"></p><p>GL_LINE_STRIP</p><p>连续的连线，第n个顶点与第n-1个顶点绘制一条直线</p><p><img src="../img/games_opengl/08_opengl8.jpg"></p><p>GL_LINE_LOOP</p><p>和上面相同，但首尾相连</p><p><img src="../img/games_opengl/08_opengl9.jpg"></p><p>GL_LINES</p><p>各对独立的线段</p><p><img src="../img/games_opengl/08_opengl10.jpg"></p><p>GL_TRIANGLES</p><p>各个独立的三角形</p><p><img src="../img/games_opengl/08_opengl11.jpg"></p><p>GL_TRIANGLE_STRIP</p><p>绘制一系列的三角形，先是顶点 v0, v1, v2, 然后是 v2, v1, v3 (注意规律), 然后v2, v3, v4等。该规律确保所有的三角形都以相同的方向绘制。</p><p><img src="../img/games_opengl/08_opengl12.jpg"></p><p>GL_TRIANGLE_FAN</p><p>和GL_TRIANGLE_STRIP类似, 但其先绘制 v0, v1, v2, 再是 v0, v2, v3, 然后 v0, v3, v4等。</p><p><img src="../img/games_opengl/08_opengl13.jpg"></p><p>我认为GL_TRIANGLES是使用最方便的，所以我们将先使用它。</p><p><pre><font class="keyword">public </font><font class="keyword">class </font>Square {</p><p>	<font class="Comments">// 顶点坐标数组</font></p><p>	<font class="keyword">private </font><font class="keyword">float </font>vertices[] = { -1.0f, 1.0f, 0.0f, <font class="Comments">// 0, 左上</font></p><p>			-1.0f, -1.0f, 0.0f, <font class="Comments">// 1, 左下</font></p><p>			1.0f, -1.0f, 0.0f, <font class="Comments">// 2, 右下</font></p><p>			1.0f, 1.0f, 0.0f, <font class="Comments">// 3, 右上</font></p><p>	};</p><p>	<font class="Comments">// 连接规则</font></p><p>	<font class="keyword">private </font>short[] indices = { 0, 1, 2, 0, 2, 3 </font>};</p><p>	<font class="Comments">// 顶点缓存</font></p><p>	<font class="keyword">private </font>FloatBuffer vertexBuffer;</p><p>	<font class="Comments">// 索引缓存</font></p><p>	<font class="keyword">private </font>ShortBuffer indexBuffer;</p><p>	<font class="keyword">public </font>Square() {</p><p>		<font class="Comments">// 一个float为4 bytes, 因此要乘以4</font></p><p>		ByteBuffer vbb = ByteBuffer.allocateDirect(vertices.length * 4);</p><p>		vbb.order(ByteOrder.nativeOrder());</p><p>		vertexBuffer = vbb.asFloatBuffer();</p><p>		vertexBuffer.put(vertices);</p><p>		vertexBuffer.position(0);</p><p>		<font class="Comments">// short类型同理</font></p><p>		ByteBuffer ibb = ByteBuffer.allocateDirect(indices.length * 2);</p><p>		ibb.order(ByteOrder.nativeOrder());</p><p>		indexBuffer = ibb.asShortBuffer();</p><p>		indexBuffer.put(indices);</p><p>		indexBuffer.position(0);</p><p>	}</p><p>	<font class="Comments">/**</font></p><p>	 <font class="Comments">* 绘制正方形到屏幕</font></p><p>	 <font class="Comments">* </font></p><p>	 <font class="Comments">* @param gl</font></p><p>	 <font class="Comments">*/</font></p><p>	<font class="keyword">public </font><font class="keyword">void </font>draw(GL10 gl) {</p><p>		<font class="Comments">// 逆时针环绕</font></p><p>		gl.glFrontFace(GL10.GL_CCW);</p><p>		<font class="Comments">// 开启剔除功能</font></p><p>		gl.glEnable(GL10.GL_CULL_FACE);</p><p>		<font class="Comments">// 剔除背面</font></p><p>		gl.glCullFace(GL10.GL_BACK);</p><p>		<font class="Comments">// 开启顶点缓存写入功能</font></p><p>		gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);</p><p>		<font class="Comments">// 设置顶点</font></p><p>		<font class="Comments">// size:每个顶点有几个数指描述。</font></p><p>		<font class="Comments">// type:数组中每个顶点的坐标类型。</font></p><p>		<font class="Comments">// stride:数组中每个顶点间的间隔，步长（字节位移）。</font></p><p>		<font class="Comments">// pointer:存储着每个顶点的坐标值。初始值为0</font></p><p>		gl.glVertexPointer(3, GL10.GL_FLOAT, 0, vertexBuffer);</p><p>		gl.glDrawElements(GL10.GL_TRIANGLES, indices.length,</p><p>				GL10.GL_UNSIGNED_SHORT, indexBuffer);</p><p>		<font class="Comments">// 关闭各个功能</font></p><p>		gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);</p><p>		gl.glDisable(GL10.GL_CULL_FACE);</p><p>	}</p><p>}</p><p></pre></p><p>我们必须在OpenGLRenderer类中初始化square</p><p><pre>square = new Square();&lt;!--EndFragment--&gt;</p><p></pre></p><p>并在主绘制方法中调用square的绘制方法</p><p><pre><font class="keyword">public </font><font class="keyword">void </font>onDrawFrame(GL10 gl) {</p><p>    <font class="Comments">// 清除屏幕和深度缓存</font></p><p>    gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);</p><p>    <font class="Comments">// 绘制正方形</font></p><p>    square.draw(gl);</p><p>}</p><p></pre></p><p>如果你现在运行应用，我们又看到了华丽的黑屏，为什么？因为OpenGL ES渲染默认的当前位置为(0,0,0)，窗口的定位也一样。而且OpenGL ES不渲染太靠近窗体定位的东西。解决方法就是移动绘制的位置。</p><p><pre>gl.glTranslatef(0, 0, -4);  &lt;!--EndFragment--&gt;</p><p></pre></p><p>再次运行应用你将看到该正方形已经被绘制，但是它好像离我们越来越远一样，最后消失了。</p><p>OpenGL ES不会在画面之间复位绘制点，所以我们要自己完成。</p><p><pre><font class="Comments">// 重置当前的模型观察矩阵</font></p><p>gl.glLoadIdentity();&lt;!--EndFragment--&gt;</p><p></pre></p><p>现在，我们运行应用将会看到一个固定位置的正方形。</p><p><img src="../img/games_opengl/08_opengl14.jpg"></p><p></p></div>

</DIV></DIV>

<DIV id=footer style="display:none">
<P align="center">  
 
 
 
    </P>
</DIV></BODY></HTML>

