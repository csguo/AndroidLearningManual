
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>OpenGL ES 学习阶段性总结_Android学习手册</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<META name=GENERATOR content="MSHTML 8.00.6001.18702">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">

</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li ><A href="../component/index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li ><A href="../device/index.html">设备功能</A> </li><li ><A href="../datastorage/index.html">数据存储</A> </li><li ><A href="../network/index.html">网络应用</A> </li><li class="navcurrentLink"><A href="index.html">游戏开发</A> </li><li ><A href="../multimedia/index.html">多媒体</A> </li><li ><A href="../source/index.html">源码开发</A> </li><li ><A href="../advance/index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">课 程 表</div>


  <h2><A title="游戏开发须知" href="index_187.html">游戏开发须知</A></h2>

  <h2><A title="游戏策划、设计分析" href="index_188.html">游戏策划、设计分析</A></h2>

  <h2><A title="Android OpenGL学习" href="index_190.html">Android OpenGL学习</A></h2>
<UL><li ><A title=Android OpenGL基础实例（一） href="show_301_190.html">Android OpenGL基础实例（一）</A> </li><li ><A title=Android OpenGL基础实例（二） href="show_302_190.html">Android OpenGL基础实例（二）</A> </li><li ><A title=Android OpenGL基础实例（三） href="show_303_190.html">Android OpenGL基础实例（三）</A> </li><li ><A title=Android OpenGL基础实例（四） href="show_304_190.html">Android OpenGL基础实例（四）</A> </li><li ><A title=Android 浅谈OpenGL ES（一） href="show_305_190.html">Android 浅谈OpenGL ES（一）</A> </li><li ><A title=Android 浅谈OpenGL ES（二） href="show_306_190.html">Android 浅谈OpenGL ES（二）</A> </li><li ><A title=OpenGL ES基础教程（一） href="show_307_190.html">OpenGL ES基础教程（一）</A> </li><li ><A title=OpenGL ES基础教程（二） href="show_308_190.html">OpenGL ES基础教程（二）</A> </li><li ><A title=Android OpenGL实战一—开发框架搭建、三角形和四边形的绘制 href="show_309_190.html">Android OpenGL实战一—开发框架搭建、三角形和四边形的绘制</A> </li><li ><A title=Android OpenGL实战二—颜色和旋转 href="show_310_190.html">Android OpenGL实战二—颜色和旋转</A> </li><li ><A title=Android 3D OpenGL开发之一— 变幻的背景色 href="show_311_190.html">Android 3D OpenGL开发之一— 变幻的背景色</A> </li><li ><A title=Android 3D OpenGL开发之二 —旋转的三角形 href="show_312_190.html">Android 3D OpenGL开发之二 —旋转的三角形</A> </li><li ><A title=Android 3D OpenGL开发之三 —漂亮的金字塔 href="show_313_190.html">Android 3D OpenGL开发之三 —漂亮的金字塔</A> </li><li ><A title=OpenGL ES 2.0实现的3D（一） href="show_314_190.html">OpenGL ES 2.0实现的3D（一）</A> </li><li ><A title=OpenGL ES 2.0实现的3D（二） href="show_315_190.html">OpenGL ES 2.0实现的3D（二）</A> </li><li ><A title=OpenGL ES 2.0实现的3D（三） href="show_316_190.html">OpenGL ES 2.0实现的3D（三）</A> </li><li ><A title=OpenGL核心函数库 href="show_317_190.html">OpenGL核心函数库</A> </li><li ><A title=OpenGL ES绘制3D图形 href="show_318_190.html">OpenGL ES绘制3D图形</A> </li><li ><A title=OpenGL ES 如何判断点击滑动线路位于哪个平面？ href="show_319_190.html">OpenGL ES 如何判断点击滑动线路位于哪个平面？</A> </li><li class="currentLink"><A title=OpenGL ES 学习阶段性总结 href="show_320_190.html">OpenGL ES 学习阶段性总结</A> </li><li ><A title=Android 图形绘制（Skia EGL OpenGL ES） href="show_321_190.html">Android 图形绘制（Skia EGL OpenGL ES）</A> </li><li ><A title=Android Graphic:apk and SkiaOpenGLES href="show_322_190.html">Android Graphic:apk and SkiaOpenGLES</A> </li><li ><A title=Android里的FrameBuffer href="show_323_190.html">Android里的FrameBuffer</A> </li></UL>
  <h2><A title="Android游戏开发之旅" href="index_191.html">Android游戏开发之旅</A></h2>

  <h2><A title="Android2D游戏开发" href="index_192.html">Android2D游戏开发</A></h2>

  <h2><A title="Android经典实例教程解析" href="index_193.html">Android经典实例教程解析</A></h2>

  <h2><A title="Android游戏开发实例" href="index_194.html">Android游戏开发实例</A></h2>

  <h2><A title="Libgdx游戏引擎" href="index_195.html">Libgdx游戏引擎</A></h2>

</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1></H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>OpenGL ES 学习阶段性总结</H2>
<div style="line-height:20px; font-size:14px;"><p>这几天看了OpenGL ES的相关资料和代码，总结了一些经验。 </p><p>1. 要画图，得设定画的是什么图形，是点，直线还是三角形，通过gl.glDrawArrays( p1, 0, p2);中的p1来设定。可用的参数有GL10.GL_POINTS, GL10.GL_LINES, GL10.GL_TRIANGLES, GL10.GL_TRANGLES_FAN, GL10.GL_TRIANGLE_STRIP... </p><p>2. 知道了形状，要设定数据源，也就是要画的点有哪些。</p><p>通过gl.glVertexPointer(3, GL10.GL_FIXED, 0, vertexBuff );来设定。</p><p>vertexBuff就是你想要画的哪些点。它表示为一个一维矩阵，但实际上根据你要画的形状来分成多个部分的。比如你想一个三角形。那么这个矩阵就可以表示为{-1，0，1，0，0，2}，{-1，0}表示第一个点，{1，0}表示第二个点，{0，2}表示第三个点。如果之后还有的话，也应该是6*N个数字，以确定更多的三角形坐标。 </p><p>3. 要是gl.glDrawArrays()方法起作用，之前得调用gl.glEnableClientState(int p1); </p><p>p1表示要激活的数组的种类，</p><p>比如要gl.glVertexPointer()设置vertex,那么必须先调用gl.glEnableClientState(GL10.GL_VERTEX_ARRAY）;</p><p>要用数组设置颜色，先调用gl.glEnableClientState( GL10.GL_COLOR_ARRAY ); </p><p>4. 画三维图像时，要激活深度测试。gl.glEnable( GL10.GL_DEPTH_TEST ); </p><p>5. 使用texture之前必须先调用gl.glEnable( GL10.GL_TEXTURE_2D );</p><p>同时调用gl.glEnableClientState( GL10.GL_TEXTURE_COORD_ARRAY );</p><p>来激活texture数组画图。 </p><p>6. glLoadIdentity():另当前绘图坐标系从新回到世界坐标系的位置，另他们重合。 </p><p>glTranslatef(x,y,z):使绘图坐标系相对世界坐标系沿x,y,z轴移动x,y,z个单位。 </p><p>glVertex3f(x,y,z):在当前绘图坐标系绘制一个点 </p><p>glColor3f(r,g,b):设置以后绘图函数的绘图颜色，如果没有再次碰到glColor3f(),以后任何绘图函数绘制出的图形颜色都是这个颜色。r,g,b的范围从0.0-1.0。r-蓝色，g-绿色，b-蓝色，色彩是这三种颜色分量的混合，比如glColor3f(1.0,1.0,0.0)是黄色，glColor3f(1.0,0.0,0.0)是红色。 </p><p>glRotatef(angle,x,y,z):和glTranslatef()属于一类函数，glTranslatef()是平移，glRotatef是旋转，就是使当前绘图坐标系绕世界坐标系的x,y,z旋转angle个角度，x,y,z的值非0既1，比如glRotatef(30,1.0f,0.0f,0.0f)就是绕x轴旋转30度，glRotatef(30,1.0f,1.0f,0.0f)就是绕x,y的夹角线旋转30度。 </p><p>7.用glRotatef能是对象本身围绕一个向量旋转，我们也可以改变观测镜头本身，参考点和向上向量来改变所看到的对象，能产生glRotatef同样的旋转效果。 </p><p><pre>GLU.gluLookAt(gl, </p><p>0.0f, 0.0f, 3.0f,<font class="Comments">//观测点在屏幕正中向外3.0f单位距离的地方 </font></p><p>viewX, 0.0f, 0.0f, <font class="Comments">//参考点在屏幕中间水平位置viewX </font></p><p>0.0f, 1.0f, 0.0f );<font class="Comments">//表示Y轴向上 </font></p><p></pre></p><p>综合这三个点，表示你这个人的眼睛从屏幕正中向外的3.0单位距离的地方,拿着摄像机瞄准viewX的地方再看，看的时候你的头是向上的（如果设置成1.0f, 0.0f, 0.0f，那么表示你的头得向右歪过来，成水平来看）。 </p><p>8.当窗口被创建时需要调用 onSurfaceCreate ，我们可以在这里对 OpenGL 做一些初始化工作，例如：</p><p>glHint 用于告诉 OpenGL 我们希望进行最好的透视修正，这会轻微地影响性能，但会使得透视图更好看。</p><p>glClearColor 设置清除屏幕时所用的颜色，色彩值的范围从 0.0f~1.0f 大小从暗到这的过程。</p><p>glShadeModel 用于启用阴影平滑度。阴影平滑通过多边形精细地混合色彩，并对外部光进行平滑。</p><p>glDepthFunc 为将深度缓存设想为屏幕后面的层，它不断地对物体进入屏幕内部的深度进行跟踪。</p><p>glEnable 启用深度测试。</p><p><pre><font class="Comments">// 启用阴影平滑</font></p><p>gl.glShadeModel(GL10.GL_SMOOTH);</p><p><font class="Comments">// 黑色背景</font></p><p>gl.glClearColor(0, 0, 0, 0);</p><p><font class="Comments">// 设置深度缓存</font></p><p>gl.glClearDepthf(1.0f);</p><p><font class="Comments">// 启用深度测试</font></p><p>gl.glEnable(GL10.GL_DEPTH_TEST);</p><p><font class="Comments">// 所作深度测试的类型</font></p><p>gl.glDepthFunc(GL10.GL_LEQUAL);</p><p><font class="Comments">// 告诉系统对透视进行修正</font></p><p>gl.glHint(GL10.GL_PERSPECTIVE_CORRECTION_HINT, GL10.GL_FASTEST);</p><p></pre></p><p>9、当窗口大小发生改变时系统将调用 onSurfaceChange 方法，可以在该方法中设置 OpenGL 场景大小 ，代码如下：</p><p><pre><font class="Comments">//设置OpenGL场景的大小</font></p><p>gl.glViewport(0, 0, width, height);</p><p></pre></p><p>10、场景画出来了，接下来我们就要实现场景里面的内容，比如：设置它的透视图，让它有种越远的东西看起来越小的感觉，代码如下：</p><p><pre><font class="Comments">//设置投影矩阵</font></p><p>gl.glMatrixMode(GL10.GL_PROJECTION);</p><p><font class="Comments">//重置投影矩阵</font></p><p>gl.glLoadIdentity();</p><p><font class="Comments">// 设置视口的大小</font></p><p>gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10);</p><p><font class="Comments">// 选择模型观察矩阵</font></p><p>gl.glMatrixMode(GL10.GL_MODELVIEW);</p><p><font class="Comments">// 重置模型观察矩阵</font></p><p>gl.glLoadIdentity();  </p><p></pre></p><p>gl.glMatrixMode(GL10.GL_PROJECTION); 指明接下来的代码将影响 projection matrix （投影矩阵），投影矩阵负责为场景增加透视度。</p><p>gl.glLoadIdentity(); 此方法相当于我们手机的重置功能，它将所选择的矩阵状态恢复成原始状态，调用  glLoadIdentity(); 之后为场景设置透视图。</p><p>gl.glMatrixMode(GL10.GL_MODELVIEW);   指明任何新的变换将会影响 modelview matrix （模型观察矩阵）。</p><p>gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10); </p><p>此方法，前面4个参数用于确定窗口的大小，而后面两个参数分别是在场景中所能绘制深度的起点和终点。</p><p>7、了解了上面两个重写方法的作用和功能之后，第三个方法 onDrawFrame 从字面上理解就知道此方法做绘制图操作的。嗯，没错。在绘图之前，需要将屏幕清除成前面所指定的颜色，清除尝试缓存并且重置场景，然后就可以绘图了， 代码如下：</p><p><pre><font class="Comments">// 清除屏幕和深度缓存</font></p><p>gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);</p><p><font class="Comments">// 重置当前的模型观察矩</font></p><p>gl.glLoadIdentity();</p><p></pre></p><p>8、Renderer 类在实现了上面的三个重写之后，在程序入口中只需要调用 </p><p><pre>Renderer render=<font class="keyword">new </font>ThreeDGl(</font><font class="keyword">this</font>);</p><p><font class="Comments">/** Called when the activity is first created. */</font></p><p>@Override</p><p><font class="keyword">public </font><font class="keyword">void </font>onCreate(Bundle savedInstanceState) {</p><p>	<font class="keyword">super</font>.onCreate(savedInstanceState);</p><p>	</font>GLSurfaceView gview=<font class="keyword">new </font>GLSurfaceView(</font><font class="keyword">this</font>);</p><p>	gview.setRenderer(render);</p><p>	setContentView(gview);</p><p>}</p><p></pre></p><p>下面分享一段使用Renderer类绘制的三角形和四边形的代码：</p><p><pre><font class="keyword">import </font>java.nio.IntBuffer;</p><p><font class="keyword">import </font>javax.microedition.khronos.egl.EGLConfig;</p><p><font class="keyword">import </font>javax.microedition.khronos.opengles.GL10;</p><p><font class="keyword">import </font>android.opengl.GLSurfaceView.Renderer;</p><p><font class="keyword">public </font><font class="keyword">class </font>GLRender </font><font class="keyword">implements </font>Renderer {</p><p>	<font class="keyword">float </font>rotateTri, rotateQuad;</p><p>	<font class="keyword">int </font>one = 0x10000;</p><p>	<font class="Comments">// 三角形的一个顶点</font></p><p>	<font class="keyword">private </font>IntBuffer triggerBuffer = IntBuffer.wrap(</font><font class="keyword">new </font><font class="keyword">int</font>[] { 0, one, 0, <font class="Comments">// 上顶点</font></p><p>			-one, -one, 0,<font class="Comments">// 左顶点</font></p><p>			one, -one, 0 <font class="Comments">// 右下点</font></p><p>			});</p><p>	<font class="Comments">// 正方形的四个顶点</font></p><p>	<font class="keyword">private </font>IntBuffer quateBuffer = IntBuffer.wrap(</font><font class="keyword">new </font><font class="keyword">int</font>[] { one, one, 0,</p><p>			-one, -one, 0, one, -one, 0, -one, -one, 0 });</p><p>	<font class="keyword">private </font>IntBuffer colorBuffer = IntBuffer.wrap(</font><font class="keyword">new </font><font class="keyword">int</font>[] { one, 0, 0, one,</p><p>			0, one, 0, one, 0, 0, one, one });</p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">void </font>onDrawFrame(GL10 gl) {</p><p>		<font class="Comments">// 清除屏幕和深度缓存</font></p><p>		gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);</p><p>		<font class="Comments">// 重置当前的模型观察矩阵</font></p><p>		gl.glLoadIdentity();</p><p>		<font class="Comments">// 左移 1.5 单位，并移入屏幕 6.0</font></p><p>		gl.glTranslatef(-1.5f, 0.0f, -6.0f);</p><p>		<font class="Comments">// 设置旋转</font></p><p>		gl.glRotatef(rotateTri, 0.0f, 1.0f, 0.0f);</p><p>		<font class="Comments">// 设置定点数组</font></p><p>		gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);</p><p>		<font class="Comments">// 设置颜色数组</font></p><p>		gl.glEnableClientState(GL10.GL_COLOR_ARRAY);</p><p>		gl.glColorPointer(4, GL10.GL_FIXED, 0, colorBuffer);</p><p>		<font class="Comments">// 设置三角形顶点</font></p><p>		gl.glVertexPointer(3, GL10.GL_FIXED, 0, triggerBuffer);</p><p>		<font class="Comments">// 绘制三角形</font></p><p>		gl.glDrawArrays(GL10.GL_TRIANGLES, 0, 3);</p><p>		gl.glDisableClientState(GL10.GL_COLOR_ARRAY);</p><p>		<font class="Comments">// 绘制三角形结束</font></p><p>		gl.glFinish();</p><p>		<font class="Comments">/***********************/</font></p><p>		/* 渲染正方形 */</p><p>		<font class="Comments">// 重置当前的模型观察矩阵</font></p><p>		gl.glLoadIdentity();</p><p>		<font class="Comments">// 左移 1.5 单位，并移入屏幕 6.0</font></p><p>		gl.glTranslatef(1.5f, 0.0f, -6.0f);</p><p>		<font class="Comments">// 设置当前色为蓝色</font></p><p>		gl.glColor4f(0.5f, 0.5f, 1.0f, 1.0f);</p><p>		<font class="Comments">// 设置旋转</font></p><p>		gl.glRotatef(rotateQuad, 1.0f, 0.0f, 0.0f);</p><p>		<font class="Comments">// 设置和绘制正方形</font></p><p>		gl.glVertexPointer(3, GL10.GL_FIXED, 0, quateBuffer);</p><p>		gl.glDrawArrays(GL10.GL_TRIANGLE_STRIP, 0, 4);</p><p>		<font class="Comments">// 绘制正方形结束</font></p><p>		gl.glFinish();</p><p>		<font class="Comments">// 取消顶点数组</font></p><p>		gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);</p><p>		<font class="Comments">// 改变旋转的角度</font></p><p>		rotateTri += 0.5f;</p><p>		rotateQuad -= 0.5f;</p><p>	}</p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">void </font>onSurfaceChanged(GL10 gl, </font><font class="keyword">int </font>width, </font><font class="keyword">int </font>height) {</p><p>		<font class="keyword">float </font>ratio = (</font><font class="keyword">float</font>) width / height;</p><p>		<font class="Comments">// 设置OpenGL场景的大小</font></p><p>		gl.glViewport(0, 0, width, height);</p><p>		<font class="Comments">// 设置投影矩阵</font></p><p>		gl.glMatrixMode(GL10.GL_PROJECTION);</p><p>		<font class="Comments">// 重置投影矩阵</font></p><p>		gl.glLoadIdentity();</p><p>		<font class="Comments">// 设置视口的大小</font></p><p>		gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10);</p><p>		<font class="Comments">// 选择模型观察矩阵</font></p><p>		gl.glMatrixMode(GL10.GL_MODELVIEW);</p><p>		<font class="Comments">// 重置模型观察矩阵</font></p><p>		gl.glLoadIdentity();</p><p>	}</p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">void </font>onSurfaceCreated(GL10 gl, EGLConfig config) {</p><p>		<font class="Comments">// 启用阴影平滑</font></p><p>		gl.glShadeModel(GL10.GL_SMOOTH);</p><p>		<font class="Comments">// 黑色背景</font></p><p>		gl.glClearColor(0, 0, 0, 0);</p><p>		<font class="Comments">// 设置深度缓存</font></p><p>		gl.glClearDepthf(1.0f);</p><p>		<font class="Comments">// 启用深度测试</font></p><p>		gl.glEnable(GL10.GL_DEPTH_TEST);</p><p>		<font class="Comments">// 所作深度测试的类型</font></p><p>		gl.glDepthFunc(GL10.GL_LEQUAL);</p><p>		<font class="Comments">// 告诉系统对透视进行修正</font></p><p>		gl.glHint(GL10.GL_PERSPECTIVE_CORRECTION_HINT, GL10.GL_FASTEST);</p><p>	}</p><p>}</p><p></pre></p><p>OpenGL包含几十个选项，通过glEnable()方法和glDisable()方法可以启用和禁用这些选项，启用每个选项都会对性能产生影响。</p><p>下面列出最常用的选项：</p><p><pre>GL_BLEND :将传入的色值与颜色缓存中的色织进行混合</p><p>GL_CULL_FACE :根据窗口坐标中多边形的转动方向（顺时针或逆时针）来忽略多边形的某些面。这是一种消除多边形后面图像绘制的简便方法。</p><p>GL_DEPTH_TEST :进行深度对比，并更新深度缓冲内容。如果某些像素距离已经绘制的很远，则这些像素将被忽略。</p><p>GL_LIGHTING :进行亮度和材料计算。</p><p>GL_LINE_SMOOTH :绘制无锯齿的线。</p><p>GL_POINT_SMOOTH :绘制无锯齿的点。</p><p>GL_TEXTURE_2D :使用纹理绘制桌面。</p><p></pre></p><p>视点变换：</p><p><pre>void gluLookAt(GLdouble eyex,GLdouble eyey,GLdouble eyez,</p><p>GLdouble centerx,GLdouble centery,</p><p>GLdouble upx,GLdouble upy,GLdouble upz);</p><p></pre></p><p>模型变换:</p><p><pre>模型平移glTranslate{fd}(TYPE x,TYPE y,TYPE z);</p><p>模型旋转glRotate{fd}(TYPE angle,TYPE x,TYPE,y,TYPE z);</p><p>模型缩放glScale{fd}(TYPE x,TYPE y,TYPE z);</p><p></pre></p><p>投影变换:</p><p>透视投影函数</p><p><pre>void glFrustum(GLdouble left,GLdouble Right,GLdouble bottom,GLdouble top,GLdouble near,GLdouble far);</p><p>void gluPerspective(GLdouble fovy,GLdouble aspect,GLdouble zNear, GLdouble zFar);</p><p></pre></p><p>正射投影函数</p><p><pre>void glOrtho(GLdouble left,GLdouble right,GLdouble bottom,GLdouble top, GLdouble near,GLdouble far)</p><p>void gluOrtho2D(GLdouble left,GLdouble right,GLdouble bottom,GLdouble top)</p><p></pre></p><p>视口变换:</p><p><pre>glViewport(GLint x,GLint y,GLsizei width, GLsizei height);</p><p>glMatrixMode():指定哪一个矩阵是当前矩阵</p><p>模型视景矩阵 GL_MODEVIEW对模型视景矩阵堆栈应用随后的矩阵操作。</p><p>模型转换和视点转换共同构成模型视景矩阵</p><p>投影矩阵 GL_PROJECTION  对投影矩阵应用随后的矩阵操作。</p><p>纹理矩阵 GLTEXTURE  对纹理矩阵堆栈应用随后的矩阵操作。</p><p>glLoadIdentity():该函数的功能是重置当前指定的矩阵为单位矩阵。</p><p></pre></p><p>纹理映射</p><p><pre><font class="Comments">//设置深度缓存 </font></p><p>gl.glClearDepthf(1.0f);</p><p><font class="Comments">//允许2D贴图,纹理</font></p><p>gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);</p><p>gl.glEnable(GL10.GL_TEXTURE_2D);</p><p>IntBuffer intBuffer = IntBuffer.allocate(1);</p><p><font class="Comments">// 创建纹理，生成一个纹理的名字</font></p><p>gl.glGenTextures(1, intBuffer);</p><p><font class="Comments">// 获得纹理名字</font></p><p>texture = intBuffer.get();</p><p><font class="Comments">// 绑定纹理，设置要使用的纹理</font></p><p>gl.glBindTexture(GL10.GL_TEXTURE_2D, texture);</p><p><font class="Comments">//生成纹理，1：纹理类型，2：纹理的详细程度，一般设为0，3：图像数据，4：边框</font></p><p>GLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, GLImage.mBitmap, 0);</p><p><font class="Comments">//纹理和四边形对应的顶点</font></p><p>gl.glVertexPointer(3, GL10.GL_FIXED, 0, vertices);</p><p>gl.glTexCoordPointer(2, GL10.GL_FIXED, 0, texCoords);</p><p><font class="Comments">//绘制</font></p><p>gl.glDrawElements(GL10.GL_TRIANGLE_STRIP, 24,  GL10.GL_UNSIGNED_BYTE, indices);</p><p></pre></p><p>光照</p><p>光的种类：环境光(Ambient )、漫射光(Diffuse)、高光(Specular)。</p><p>环境光是无所不在的漫射光，是场景的背景亮度，因此无法确定其来源，平均作用于场景中的所有物体的所有面。</p><p>漫射光由特定的光源产生，并在场景中的对象表面产生反射。处于漫射光照射下的任何对象表面都变得很亮，而机会未被照射的区域就显得要暗一些。</p><p><pre><font class="Comments">//如果不启用GL_LIGHTING光就什么都看不见</font></p><p>gl.glEnable(GL10.GL_LIGHTING);</p><p>定义环境光 (r,g,b,a)的颜色(半亮)：</p><p>FloatBuffer lightAmbient = FloatBuffer.wrap(<font class="keyword">new </font><font class="keyword">float</font>[]{0.5f,0.5f,0.5f,1.0f</font>}); </p><p><font class="Comments">//定义漫射光(最亮)</font></p><p>FloatBuffer lightDiffuse = FloatBuffer.wrap(<font class="keyword">new </font><font class="keyword">float</font>[]{1.0f,1.0f,1.0f,1.0f</font>});</p><p>设置好光源组后需要定义光源在场景中所处的位置</p><p><font class="Comments">//定义光源，把光源放在2.0f的位置上，最后一个参数是1.0f告知OpenGL指定的坐标就是光源的位置，0来定义平行光源 </font></p><p>FloatBuffer lightPosition = FloatBuffer.wrap(<font class="keyword">new </font><font class="keyword">float</font>[]{0.0f,0.0f,2.0f,1.0f</font>});</p><p><font class="Comments">//设置环境光</font></p><p>gl.glLightfv(GL10.GL_LIGHT1, GL10.GL_AMBIENT, lightAmbient);</p><p><font class="Comments">//设置漫射光</font></p><p>gl.glLightfv(GL10.GL_LIGHT1, GL10.GL_DIFFUSE, lightDiffuse);</p><p><font class="Comments">//设置光源的位置</font></p><p>gl.glLightfv(GL10.GL_LIGHT1, GL10.GL_POSITION, lightPosition); </p><p><font class="Comments">//启用一号光源</font></p><p>gl.glEnable(GL10.GL_LIGHT1);</p><p></pre></p><p>glfrustumf前四个参数是-1，1，-1.5，1.5，这是规定视窗的大小和纵横位置，前两个参数指以原点为参照，视窗宽度的左值和右值，两值的绝对值相加就是视窗的宽，同理，后两个参数指以原点为参照,视窗高度的上值和下值，两值的绝对值相加就是视窗的高度。视窗决定了三维物体的可视区域。超过这个视窗范围的物体将不会显示出来，GDI的说法就是会被剪切掉.后两个参数是一个距离，2，5，这两个参数只是正值,虽然看上去没有和坐标相关，但实际上它的意义还是坐标上，只是需要自己算一下，第一个参数2是指视窗到视点的距离，第二个参数5是指投影面到视点的距离，第一个参数指示了视窗的前后位置，参数越小，视窗越靠近视点，可视区域越大，反之亦然，投影面就是屏幕了，投影面的远近</p><p>纹理对象</p><p>除了默认的TEXTURE_2D和TEXTURE_CUBE_MAP，可以创建有名称的纹理对象；</p><p><pre>void BindTexture(enum target, uinttexture); <font class="Comments">//创建纹理对象，连接一个未使用的名称到TEXTURE_2D或TEXTURE_CUBE_MAP，也可以修改已有纹理对象的连接；</font></p><p></pre></p><p>新创建的纹理对象有3.7.12中所有的state。</p><p><pre>void DeleteTextures(sizei n, uint*textures ); <font class="Comments">//删除已有的n个纹理对象</font></p><p>void GenTextures(sizei n, uint *textures); <font class="Comments">//返回未使用的纹理对象名称</font></p><p></pre></p><p>当需要更新纹理时，在OpenGL ES中可以使用glTextSubImage2D函数来代替glText-Image2D函数，这样就可以避免内存分配与回收问题。此外还可以采用纹理压缩技术，在OpenGLES中可以调用glCompressedTextImage2D函数和glCompressedTextSubImage2D函数来压缩纹理。压缩纹理的优点在于使用内存较小，可以提高高速缓存的利用率。</p><p>贴上去的纹理必须是512*512的或2^次方的</p><p>GLSurfaceView.setRenderMode(RENDERMODE_WHEN_DIRTY);停止持续渲染。</p><p>GLSurfaceView.requestRender()；程序再渲染屏幕。默认持续型渲染</p><p></p></div>

</DIV></DIV>

<DIV id=footer style="display:none">
<P align="center">  
 
 
 
    </P>
</DIV></BODY></HTML>

