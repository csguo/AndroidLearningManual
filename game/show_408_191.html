
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>Android游戏开发之旅（八）SurfaceView类实例_Android学习手册</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<META name=GENERATOR content="MSHTML 8.00.6001.18702">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">

</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li ><A href="../component/index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li ><A href="../device/index.html">设备功能</A> </li><li ><A href="../datastorage/index.html">数据存储</A> </li><li ><A href="../network/index.html">网络应用</A> </li><li class="navcurrentLink"><A href="index.html">游戏开发</A> </li><li ><A href="../multimedia/index.html">多媒体</A> </li><li ><A href="../source/index.html">源码开发</A> </li><li ><A href="../advance/index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">课 程 表</div>


  <h2><A title="游戏开发须知" href="index_187.html">游戏开发须知</A></h2>

  <h2><A title="游戏策划、设计分析" href="index_188.html">游戏策划、设计分析</A></h2>

  <h2><A title="Android OpenGL学习" href="index_190.html">Android OpenGL学习</A></h2>

  <h2><A title="Android游戏开发之旅" href="index_191.html">Android游戏开发之旅</A></h2>
<UL><li ><A title=Android游戏开发之旅（一）长按Button原理 href="show_401_191.html">Android游戏开发之旅（一）长按Button原理</A> </li><li ><A title=Android游戏开发之旅（二）View和SurfaceView href="show_402_191.html">Android游戏开发之旅（二）View和SurfaceView</A> </li><li ><A title=Android游戏开发之旅（三）View类详解 href="show_403_191.html">Android游戏开发之旅（三）View类详解</A> </li><li ><A title=Android游戏开发之旅（四）Canvas和Paint实例 href="show_404_191.html">Android游戏开发之旅（四）Canvas和Paint实例</A> </li><li ><A title=Android游戏开发之旅（五）Path和Typeface href="show_405_191.html">Android游戏开发之旅（五）Path和Typeface</A> </li><li ><A title=Android游戏开发之旅（六）自定义View href="show_406_191.html">Android游戏开发之旅（六）自定义View</A> </li><li ><A title=Android游戏开发之旅（七）自定义SurfaceView href="show_407_191.html">Android游戏开发之旅（七）自定义SurfaceView</A> </li><li class="currentLink"><A title=Android游戏开发之旅（八）SurfaceView类实例 href="show_408_191.html">Android游戏开发之旅（八）SurfaceView类实例</A> </li><li ><A title=Android游戏开发之旅（九）VideoView类剖析 href="show_409_191.html">Android游戏开发之旅（九）VideoView类剖析</A> </li><li ><A title=Android游戏开发之旅（十）位图旋转 href="show_410_191.html">Android游戏开发之旅（十）位图旋转</A> </li><li ><A title=Android游戏开发之旅（十一）View中手势识别 href="show_411_191.html">Android游戏开发之旅（十一）View中手势识别</A> </li><li ><A title=Android游戏开发之旅（十二）Sensor重力感应 href="show_412_191.html">Android游戏开发之旅（十二）Sensor重力感应</A> </li><li ><A title=Android游戏开发之旅（十三）Sensor感应示例 href="show_413_191.html">Android游戏开发之旅（十三）Sensor感应示例</A> </li><li ><A title=Android游戏开发之旅（十四）游戏开发实战一 href="show_414_191.html">Android游戏开发之旅（十四）游戏开发实战一</A> </li><li ><A title=Android游戏开发之旅（十五）按键中断处理 href="show_415_191.html">Android游戏开发之旅（十五）按键中断处理</A> </li><li ><A title=Android游戏开发之旅（十六）异步音乐播放 href="show_416_191.html">Android游戏开发之旅（十六）异步音乐播放</A> </li><li ><A title=Android游戏开发之旅（十七）图像渐变特效 href="show_417_191.html">Android游戏开发之旅（十七）图像渐变特效</A> </li><li ><A title=Android游戏开发之旅（十八）SoundPool类 href="show_418_191.html">Android游戏开发之旅（十八）SoundPool类</A> </li><li ><A title=Android游戏开发之旅（十九）分辨率大全 href="show_419_191.html">Android游戏开发之旅（十九）分辨率大全</A> </li><li ><A title=Android游戏开发之旅（二十）双按事件捕获 href="show_420_191.html">Android游戏开发之旅（二十）双按事件捕获</A> </li></UL>
  <h2><A title="Android2D游戏开发" href="index_192.html">Android2D游戏开发</A></h2>

  <h2><A title="Android经典实例教程解析" href="index_193.html">Android经典实例教程解析</A></h2>

  <h2><A title="Android游戏开发实例" href="index_194.html">Android游戏开发实例</A></h2>

  <h2><A title="Libgdx游戏引擎" href="index_195.html">Libgdx游戏引擎</A></h2>

</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1></H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>Android游戏开发之旅（八）SurfaceView类实例</H2>
<div style="line-height:20px; font-size:14px;"><p>有关SurfaceView我们将通过三个系统自带的例子来深入掌握Android绘图必会的SurfaceView，今天我们以SDK中的Sample游戏lunarlander中的LunarView具体实现，建议大家导入该游戏工程到你的Eclipse然后自己编译先玩一下这个游戏，然后再看代码比较好理解。</p><p><pre><font class="keyword">class </font>LunarView </font><font class="keyword">extends </font>SurfaceView </font><font class="keyword">implements </font>SurfaceHolder.Callback {</p><p>	<font class="keyword">class </font>LunarThread </font><font class="keyword">extends </font>Thread {</p><p>		/*</p><p>		 <font class="Comments">* Difficulty setting constants</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>DIFFICULTY_EASY = 0;</p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>DIFFICULTY_HARD = 1;</p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>DIFFICULTY_MEDIUM = 2;</p><p>		/*</p><p>		 <font class="Comments">* Physics constants</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>PHYS_DOWN_ACCEL_SEC = 35;</p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>PHYS_FIRE_ACCEL_SEC = 80;</p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>PHYS_FUEL_INIT = 60;</p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>PHYS_FUEL_MAX = 100;</p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>PHYS_FUEL_SEC = 10;</p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>PHYS_SLEW_SEC = 120; <font class="Comments">// degrees/second rotate</font></p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>PHYS_SPEED_HYPERSPACE = 180;</p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>PHYS_SPEED_INIT = 30;</p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>PHYS_SPEED_MAX = 120;</p><p>		/*</p><p>		 <font class="Comments">* State-tracking constants</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>STATE_LOSE = 1;</p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>STATE_PAUSE = 2;</p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>STATE_READY = 3;</p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>STATE_RUNNING = 4;</p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>STATE_WIN = 5;</p><p>		/*</p><p>		 <font class="Comments">* Goal condition constants</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>TARGET_ANGLE = 18; <font class="Comments">// &gt; </font><font class="keyword">this</font> angle means crash</font></p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>TARGET_BOTTOM_PADDING = 17; <font class="Comments">// px below gear</font></p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>TARGET_PAD_HEIGHT = 8; <font class="Comments">// how high above ground</font></p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>TARGET_SPEED = 28; <font class="Comments">// &gt; </font><font class="keyword">this</font> speed means crash</font></p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">double </font>TARGET_WIDTH = 1.6; <font class="Comments">// width of target</font></p><p>		/*</p><p>		 <font class="Comments">* UI constants (i.e. the speed & fuel bars)</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>UI_BAR = 100; <font class="Comments">// width of the bar(s)</font></p><p>		<font class="keyword">public </font><font class="keyword">static </font><font class="keyword">final </font><font class="keyword">int </font>UI_BAR_HEIGHT = 10; <font class="Comments">// height of the bar(s)</font></p><p>		<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">final </font>String KEY_DIFFICULTY = <font class="Fields">"mDifficulty"</font>;</p><p>		<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">final </font>String KEY_DX = <font class="Fields">"mDX"</font>;</p><p>		<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">final </font>String KEY_DY = <font class="Fields">"mDY"</font>;</p><p>		<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">final </font>String KEY_FUEL = <font class="Fields">"mFuel"</font>;</p><p>		<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">final </font>String KEY_GOAL_ANGLE = <font class="Fields">"mGoalAngle"</font>;</p><p>		<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">final </font>String KEY_GOAL_SPEED = <font class="Fields">"mGoalSpeed"</font>;</p><p>		<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">final </font>String KEY_GOAL_WIDTH = <font class="Fields">"mGoalWidth"</font>;</p><p>		<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">final </font>String KEY_GOAL_X = <font class="Fields">"mGoalX"</font>;</p><p>		<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">final </font>String KEY_HEADING = <font class="Fields">"mHeading"</font>;</p><p>		<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">final </font>String KEY_LANDER_HEIGHT = <font class="Fields">"mLanderHeight"</font>;</p><p>		<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">final </font>String KEY_LANDER_WIDTH = <font class="Fields">"mLanderWidth"</font>;</p><p>		<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">final </font>String KEY_WINS = <font class="Fields">"mWinsInARow"</font>;</p><p>		<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">final </font>String KEY_X = <font class="Fields">"mX"</font>;</p><p>		<font class="keyword">private </font><font class="keyword">static </font><font class="keyword">final </font>String KEY_Y = <font class="Fields">"mY"</font>;</p><p>		/*</p><p>		 <font class="Comments">* Member (state) fields</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="Comments">/** The drawable to use as the background of the animation canvas */</font></p><p>		<font class="keyword">private </font>Bitmap mBackgroundImage;</p><p></p><p>		<font class="Comments">/**</font></p><p>		 <font class="Comments">* Current height of the surface/canvas.</font></p><p>		 <font class="Comments">* </font></p><p>		 <font class="Comments">* @see setSurfaceSize</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">private </font><font class="keyword">int </font>mCanvasHeight = 1;</p><p></p><p>		<font class="Comments">/**</font></p><p>		 <font class="Comments">* Current width of the surface/canvas.</font></p><p>		 <font class="Comments">* </font></p><p>		 <font class="Comments">* @see setSurfaceSize</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">private </font><font class="keyword">int </font>mCanvasWidth = 1;</p><p></p><p>		<font class="Comments">/** What to draw for the Lander when it has crashed */</font></p><p>		<font class="keyword">private </font>Drawable mCrashedImage;</p><p></p><p>		<font class="Comments">/**</font></p><p>		 <font class="Comments">* Current difficulty -- amount of fuel, allowed angle, etc. Default is</font></p><p>		 <font class="Comments">* MEDIUM.</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">private </font><font class="keyword">int </font>mDifficulty;</p><p></p><p>		<font class="Comments">/** Velocity dx. */</font></p><p>		<font class="keyword">private </font><font class="keyword">double </font>mDX;</p><p></p><p>		<font class="Comments">/** Velocity dy. */</font></p><p>		<font class="keyword">private </font><font class="keyword">double </font>mDY;</p><p></p><p>		<font class="Comments">/** Is the engine burning? */</font></p><p>		<font class="keyword">private </font><font class="keyword">boolean </font>mEngineFiring;</p><p></p><p>		<font class="Comments">/** What to draw for the Lander when the engine is firing */</font></p><p>		<font class="keyword">private </font>Drawable mFiringImage;</p><p></p><p>		<font class="Comments">/** Fuel remaining */</font></p><p>		<font class="keyword">private </font><font class="keyword">double </font>mFuel;</p><p></p><p>		<font class="Comments">/** Allowed angle. */</font></p><p>		<font class="keyword">private </font><font class="keyword">int </font>mGoalAngle;</p><p></p><p>		<font class="Comments">/** Allowed speed. */</font></p><p>		<font class="keyword">private </font><font class="keyword">int </font>mGoalSpeed;</p><p></p><p>		<font class="Comments">/** Width of the landing pad. */</font></p><p>		<font class="keyword">private </font><font class="keyword">int </font>mGoalWidth;</p><p></p><p>		<font class="Comments">/** X of the landing pad. */</font></p><p>		<font class="keyword">private </font><font class="keyword">int </font>mGoalX;</p><p></p><p>		<font class="Comments">/** Message handler used by thread to interact with TextView */</font></p><p>		<font class="keyword">private </font>Handler mHandler;</p><p></p><p>		<font class="Comments">/**</font></p><p>		 <font class="Comments">* Lander heading in degrees, with 0 up, 90 right. Kept in the range</font></p><p>		 <font class="Comments">* 0..360.</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">private </font><font class="keyword">double </font>mHeading;</p><p></p><p>		<font class="Comments">/** Pixel height of lander image. */</font></p><p>		<font class="keyword">private </font><font class="keyword">int </font>mLanderHeight;</p><p></p><p>		<font class="Comments">/** What to draw for the Lander in its normal state */</font></p><p>		<font class="keyword">private </font>Drawable mLanderImage;</p><p></p><p>		<font class="Comments">/** Pixel width of lander image. */</font></p><p>		<font class="keyword">private </font><font class="keyword">int </font>mLanderWidth;</p><p></p><p>		<font class="Comments">/** Used to figure out elapsed time between frames */</font></p><p>		<font class="keyword">private </font><font class="keyword">long </font>mLastTime;</p><p></p><p>		<font class="Comments">/** Paint to draw the lines on screen. */</font></p><p>		<font class="keyword">private </font>Pa</font><font class="keyword">int </font>mLinePaint;</p><p></p><p>		<font class="Comments">/** "Bad" speed-too-high variant of the line color. */</font></p><p>		<font class="keyword">private </font>Pa</font><font class="keyword">int </font>mLinePaintBad;</p><p></p><p>		<font class="Comments">/** The state of the game. One of READY, RUNNING, PAUSE, LOSE, or WIN */</font></p><p>		<font class="keyword">private </font><font class="keyword">int </font>mMode;</p><p></p><p>		<font class="Comments">/** Currently rotating, -1 left, 0 none, 1 right. */</font></p><p>		<font class="keyword">private </font><font class="keyword">int </font>mRotating;</p><p></p><p>		<font class="Comments">/** Indicate whether the surface has been created & is ready to draw */</font></p><p>		<font class="keyword">private </font><font class="keyword">boolean </font>mRun = </font><font class="keyword">false</font>;</p><p></p><p>		<font class="Comments">/** Scratch rect object. */</font></p><p>		<font class="keyword">private </font>RectF mScratchRect;</p><p></p><p>		<font class="Comments">/** Handle to the surface manager object we interact with */</font></p><p>		<font class="keyword">private </font>SurfaceHolder mSurfaceHolder;</p><p></p><p>		<font class="Comments">/** Number of wins in a row. */</font></p><p>		<font class="keyword">private </font><font class="keyword">int </font>mWinsInARow;</p><p></p><p>		<font class="Comments">/** X of lander center. */</font></p><p>		<font class="keyword">private </font><font class="keyword">double </font>mX;</p><p></p><p>		<font class="Comments">/** Y of lander center. */</font></p><p>		<font class="keyword">private </font><font class="keyword">double </font>mY;</p><p></p><p>		<font class="keyword">public </font>LunarThread(SurfaceHolder surfaceHolder, Context context,</p><p>				Handler handler) {</p><p>			<font class="Comments">// get handles to some important objects</font></p><p>			mSurfaceHolder = surfaceHolder;</p><p>			mHandler = handler;</p><p>			mContext = context;</p><p></p><p>			Resources res = context.getResources();</p><p>			<font class="Comments">// cache handles to our key sprites & other drawables</font></p><p>			mLanderImage = context.getResources().getDrawable(</p><p>					R.drawable.lander_plain);</p><p>			mFiringImage = context.getResources().getDrawable(</p><p>					R.drawable.lander_firing);</p><p>			mCrashedImage = context.getResources().getDrawable(</p><p>					R.drawable.lander_crashed);</p><p></p><p>			<font class="Comments">// load background image as a Bitmap instead of a Drawable b/c</font></p><p>			<font class="Comments">// we don't need to transform it and it's faster to draw this way</font></p><p>			mBackgroundImage = BitmapFactory.decodeResource(res,</p><p>					R.drawable.earthrise);</p><p></p><p>			<font class="Comments">// Use the regular lander image as the model size for all sprites</font></p><p>			mLanderWidth = mLanderImage.getIntrinsicWidth();</p><p>			mLanderHeight = mLanderImage.getIntrinsicHeight();</p><p></p><p>			<font class="Comments">// Initialize paints for speedometer</font></p><p>			</font>mLinePa<font class="keyword">int </font>= </font><font class="keyword">new </font>Paint();</p><p>			</font>mLinePaint.setAntiAlias(<font class="keyword">true</font>);</p><p>			mLinePaint.setARGB(255, 0, 255, 0);</p><p></p><p>			</font>mLinePaintBad = <font class="keyword">new </font>Paint();</p><p>			</font>mLinePaintBad.setAntiAlias(<font class="keyword">true</font>);</p><p>			mLinePaintBad.setARGB(255, 120, 180, 0);</p><p></p><p>			</font>mScratchRect = <font class="keyword">new </font>RectF(0, 0, 0, 0);</p><p></p><p>			mWinsInARow = 0;</p><p>			mDifficulty = DIFFICULTY_MEDIUM;</p><p></p><p>			<font class="Comments">// initial show-up of lander (not yet playing)</font></p><p>			mX = mLanderWidth;</p><p>			mY = mLanderHeight * 2;</p><p>			mFuel = PHYS_FUEL_INIT;</p><p>			mDX = 0;</p><p>			mDY = 0;</p><p>			mHeading = 0;</p><p>			</font>mEngineFiring = <font class="keyword">true</font>;</p><p>		}</p><p></p><p>		<font class="Comments">/**</font></p><p>		 <font class="Comments">* Starts the game, setting parameters for the current difficulty.</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">public </font><font class="keyword">void </font>doStart() {</p><p>			<font class="keyword">synchronized </font>(mSurfaceHolder) {</p><p>				<font class="Comments">// First set the game for Medium difficulty</font></p><p>				mFuel = PHYS_FUEL_INIT;</p><p>				</font>mEngineFiring = <font class="keyword">false</font>;</p><p>				</font>mGoalWidth = (<font class="keyword">int</font>) (mLanderWidth * TARGET_WIDTH);</p><p>				mGoalSpeed = TARGET_SPEED;</p><p>				mGoalAngle = TARGET_ANGLE;</p><p>				<font class="keyword">int </font>speedInit = PHYS_SPEED_INIT;</p><p></p><p>				<font class="Comments">// Adjust difficulty params for EASY/HARD</font></p><p>				<font class="keyword">if </font>(mDifficulty == DIFFICULTY_EASY) {</p><p>					mFuel = mFuel * 3 / 2;</p><p>					mGoalWidth = mGoalWidth * 4 / 3;</p><p>					mGoalSpeed = mGoalSpeed * 3 / 2;</p><p>					mGoalAngle = mGoalAngle * 4 / 3;</p><p>					speedInit = speedInit * 3 / 4;</p><p>				</font>} <font class="keyword">else </font><font class="keyword">if </font>(mDifficulty == DIFFICULTY_HARD) {</p><p>					mFuel = mFuel * 7 / 8;</p><p>					mGoalWidth = mGoalWidth * 3 / 4;</p><p>					mGoalSpeed = mGoalSpeed * 7 / 8;</p><p>					speedInit = speedInit * 4 / 3;</p><p>				}</p><p></p><p>				<font class="Comments">// pick a convenient initial location for the lander sprite</font></p><p>				mX = mCanvasWidth / 2;</p><p>				mY = mCanvasHeight - mLanderHeight / 2;</p><p></p><p>				<font class="Comments">// start with a little random motion</font></p><p>				mDY = Math.random() * -speedInit;</p><p>				mDX = Math.random() * 2 * speedInit - speedInit;</p><p>				mHeading = 0;</p><p></p><p>				<font class="Comments">// Figure initial spot for landing, not too near center</font></p><p>				<font class="keyword">while </font>(</font><font class="keyword">true</font>) {</p><p>					</font>mGoalX = (<font class="keyword">int</font>) (Math.random() * (mCanvasWidth - mGoalWidth));</p><p>					<font class="keyword">if </font>(Math.abs(mGoalX - (mX - mLanderWidth / 2)) &gt; mCanvasHeight / 6)</p><p>						<font class="keyword">break</font>;</p><p>				}</p><p></p><p>				mLastTime = System.currentTimeMillis() + 100;</p><p>				setState(STATE_RUNNING);</p><p>			}</p><p>		}</p><p></p><p>		<font class="Comments">/**</font></p><p>		 <font class="Comments">* Pauses the physics update & animation.</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">public </font><font class="keyword">void </font>pause() {</p><p>			<font class="keyword">synchronized </font>(mSurfaceHolder) {</p><p>				<font class="keyword">if </font>(mMode == STATE_RUNNING)</p><p>					setState(STATE_PAUSE);</p><p>			}</p><p>		}</p><p></p><p>		<font class="Comments">/**</font></p><p>		 <font class="Comments">* Restores game state from the indicated Bundle. Typically called when</font></p><p>		 <font class="Comments">* the Activity is being restored after having been previously</font></p><p>		 <font class="Comments">* destroyed.</font></p><p>		 <font class="Comments">* </font></p><p>		 <font class="Comments">* @param savedState</font></p><p>		 <font class="Comments">*            Bundle containing the game state</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">public </font><font class="keyword">synchronized </font><font class="keyword">void </font>restoreState(Bundle savedState) {</p><p>			<font class="keyword">synchronized </font>(mSurfaceHolder) {</p><p>				setState(STATE_PAUSE);</p><p>				mRotating = 0;</p><p>				</font>mEngineFiring = <font class="keyword">false</font>;</p><p></p><p>				mDifficulty = savedState.getInt(KEY_DIFFICULTY);</p><p>				mX = savedState.getDouble(KEY_X);</p><p>				mY = savedState.getDouble(KEY_Y);</p><p>				mDX = savedState.getDouble(KEY_DX);</p><p>				mDY = savedState.getDouble(KEY_DY);</p><p>				mHeading = savedState.getDouble(KEY_HEADING);</p><p></p><p>				mLanderWidth = savedState.getInt(KEY_LANDER_WIDTH);</p><p>				mLanderHeight = savedState.getInt(KEY_LANDER_HEIGHT);</p><p>				mGoalX = savedState.getInt(KEY_GOAL_X);</p><p>				mGoalSpeed = savedState.getInt(KEY_GOAL_SPEED);</p><p>				mGoalAngle = savedState.getInt(KEY_GOAL_ANGLE);</p><p>				mGoalWidth = savedState.getInt(KEY_GOAL_WIDTH);</p><p>				mWinsInARow = savedState.getInt(KEY_WINS);</p><p>				mFuel = savedState.getDouble(KEY_FUEL);</p><p>			}</p><p>		}</p><p></p><p>		@Override</p><p>		<font class="keyword">public </font><font class="keyword">void </font>run() {</p><p>			<font class="keyword">while </font>(mRun) {</p><p>				</font>Canvas c = <font class="keyword">null</font>;</p><p>				<font class="keyword">try </font>{</p><p>					</font>c = mSurfaceHolder.lockCanvas(<font class="keyword">null</font>);</p><p>					<font class="keyword">synchronized </font>(mSurfaceHolder) {</p><p>						<font class="keyword">if </font>(mMode == STATE_RUNNING)</p><p>							updatePhysics();</p><p>						doDraw(c);</p><p>					}</p><p>				} finally {</p><p>					<font class="Comments">// do this in a finally so that if an exception is thrown</font></p><p>					<font class="Comments">// during the above, we don't leave the Surface in an</font></p><p>					<font class="Comments">// inconsistent state</font></p><p>					<font class="keyword">if </font>(c != </font><font class="keyword">null</font>) {</p><p>						mSurfaceHolder.unlockCanvasAndPost(c);</p><p>					}</p><p>				}</p><p>			}</p><p>		}</p><p></p><p>		<font class="Comments">/**</font></p><p>		 <font class="Comments">* Dump game state to the provided Bundle. Typically called when the</font></p><p>		 <font class="Comments">* Activity is being suspended.</font></p><p>		 <font class="Comments">* </font></p><p>		 <font class="Comments">* @return Bundle with this view's state</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">public </font>Bundle saveState(Bundle map) {</p><p>			<font class="keyword">synchronized </font>(mSurfaceHolder) {</p><p>				<font class="keyword">if </font>(map != </font><font class="keyword">null</font>) {</p><p>					map.putInt(KEY_DIFFICULTY, Integer.valueOf(mDifficulty));</p><p>					map.putDouble(KEY_X, Double.valueOf(mX));</p><p>					map.putDouble(KEY_Y, Double.valueOf(mY));</p><p>					map.putDouble(KEY_DX, Double.valueOf(mDX));</p><p>					map.putDouble(KEY_DY, Double.valueOf(mDY));</p><p>					map.putDouble(KEY_HEADING, Double.valueOf(mHeading));</p><p>					map.putInt(KEY_LANDER_WIDTH, Integer.valueOf(mLanderWidth));</p><p>					map.putInt(KEY_LANDER_HEIGHT,</p><p>							Integer.valueOf(mLanderHeight));</p><p>					map.putInt(KEY_GOAL_X, Integer.valueOf(mGoalX));</p><p>					map.putInt(KEY_GOAL_SPEED, Integer.valueOf(mGoalSpeed));</p><p>					map.putInt(KEY_GOAL_ANGLE, Integer.valueOf(mGoalAngle));</p><p>					map.putInt(KEY_GOAL_WIDTH, Integer.valueOf(mGoalWidth));</p><p>					map.putInt(KEY_WINS, Integer.valueOf(mWinsInARow));</p><p>					map.putDouble(KEY_FUEL, Double.valueOf(mFuel));</p><p>				}</p><p>			}</p><p>			<font class="keyword">return </font>map;</p><p>		}</p><p></p><p>		<font class="Comments">/**</font></p><p>		 <font class="Comments">* Sets the current difficulty.</font></p><p>		 <font class="Comments">* </font></p><p>		 <font class="Comments">* @param difficulty</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">public </font><font class="keyword">void </font>setDifficulty(</font><font class="keyword">int </font>difficulty) {</p><p>			<font class="keyword">synchronized </font>(mSurfaceHolder) {</p><p>				mDifficulty = difficulty;</p><p>			}</p><p>		}</p><p></p><p>		<font class="Comments">/**</font></p><p>		 <font class="Comments">* Sets if the engine is currently firing.</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">public </font><font class="keyword">void </font>setFiring(</font><font class="keyword">boolean </font>firing) {</p><p>			<font class="keyword">synchronized </font>(mSurfaceHolder) {</p><p>				mEngineFiring = firing;</p><p>			}</p><p>		}</p><p></p><p>		<font class="Comments">/**</font></p><p>		 <font class="Comments">* Used to signal the thread whether it should be running or not.</font></p><p>		 <font class="Comments">* Passing true allows the thread to run; passing false will shut it</font></p><p>		 <font class="Comments">* down if it's already running. Calling start() after this was most</font></p><p>		 <font class="Comments">* recently called with false will result in an immediate shutdown.</font></p><p>		 <font class="Comments">* </font></p><p>		 <font class="Comments">* @param b</font></p><p>		 <font class="Comments">*            true to run, false to shut down</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">public </font><font class="keyword">void </font>setRunning(</font><font class="keyword">boolean </font>b) {</p><p>			mRun = b;</p><p>		}</p><p></p><p>		<font class="Comments">/**</font></p><p>		 <font class="Comments">* Sets the game mode. That is, whether we are running, paused, in the</font></p><p>		 <font class="Comments">* failure state, in the victory state, etc.</font></p><p>		 <font class="Comments">* </font></p><p>		 <font class="Comments">* @see setState(int, CharSequence)</font></p><p>		 <font class="Comments">* @param mode</font></p><p>		 <font class="Comments">*            one of the STATE_<font class="Comments">* constants</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">public </font><font class="keyword">void </font>setState(</font><font class="keyword">int </font>mode) {</p><p>			<font class="keyword">synchronized </font>(mSurfaceHolder) {</p><p>				</font>setState(mode, <font class="keyword">null</font>);</p><p>			}</p><p>		}</p><p></p><p>		<font class="Comments">/**</font></p><p>		 <font class="Comments">* Sets the game mode. That is, whether we are running, paused, in the</font></p><p>		 <font class="Comments">* failure state, in the victory state, etc.</font></p><p>		 <font class="Comments">* </font></p><p>		 <font class="Comments">* @param mode</font></p><p>		 <font class="Comments">*            one of the STATE_<font class="Comments">* constants</font></p><p>		 <font class="Comments">* @param message</font></p><p>		 <font class="Comments">*            string to add to screen or null</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">public </font><font class="keyword">void </font>setState(</font><font class="keyword">int </font>mode, CharSequence message) {</p><p>			/*</p><p>			 <font class="Comments">* This method optionally can cause a text message to be displayed</font></p><p>			 <font class="Comments">* to the user when the mode changes. Since the View that actually</font></p><p>			 <font class="Comments">* renders that text is part of the main View hierarchy and not</font></p><p>			 <font class="Comments">* owned by this thread, we can't touch the state of that View.</font></p><p>			 <font class="Comments">* Instead we use a Message + Handler to relay commands to the main</font></p><p>			 <font class="Comments">* thread, which updates the user-text View.</font></p><p>			 <font class="Comments">*/</font></p><p>			<font class="keyword">synchronized </font>(mSurfaceHolder) {</p><p>				mMode = mode;</p><p></p><p>				<font class="keyword">if </font>(mMode == STATE_RUNNING) {</p><p>					Message msg = mHandler.obtainMessage();</p><p>					</font>Bundle b = <font class="keyword">new </font>Bundle();</p><p>					</font>b.putString(<font class="Fields">"text"</font>, </font><font class="Fields">""</font>);</p><p>					</font>b.putInt(<font class="Fields">"viz"</font>, View.INVISIBLE);</p><p>					msg.setData(b);</p><p>					mHandler.sendMessage(msg);</p><p>				</font>} <font class="keyword">else </font>{</p><p>					mRotating = 0;</p><p>					</font>mEngineFiring = <font class="keyword">false</font>;</p><p>					Resources res = mContext.getResources();</p><p>					</font>CharSequence str = <font class="Fields">""</font>;</p><p>					<font class="keyword">if </font>(mMode == STATE_READY)</p><p>						str = res.getText(R.string.mode_ready);</p><p>					<font class="keyword">else </font><font class="keyword">if </font>(mMode == STATE_PAUSE)</p><p>						str = res.getText(R.string.mode_pause);</p><p>					<font class="keyword">else </font><font class="keyword">if </font>(mMode == STATE_LOSE)</p><p>						str = res.getText(R.string.mode_lose);</p><p>					<font class="keyword">else </font><font class="keyword">if </font>(mMode == STATE_WIN)</p><p>						str = res.getString(R.string.mode_win_prefix)</p><p>								</font>+ mWinsInARow + <font class="Fields">"</p><p>								+ res.getString(R.string.mode_win_suffix);</p><p></p><p>					<font class="keyword">if </font>(message != </font><font class="keyword">null</font>) {</p><p>						</font>str = message + <font class="Fields">"\n"</font> + str;</p><p>					}</p><p></p><p>					<font class="keyword">if </font>(mMode == STATE_LOSE)</p><p>						mWinsInARow = 0;</p><p></p><p>					Message msg = mHandler.obtainMessage();</p><p>					</font>Bundle b = <font class="keyword">new </font>Bundle();</p><p>					</font>b.putString(<font class="Fields">"text"</font>, str.toString());</p><p>					</font>b.putInt(<font class="Fields">"viz"</font>, View.VISIBLE);</p><p>					msg.setData(b);</p><p>					mHandler.sendMessage(msg);</p><p>				}</p><p>			}</p><p>		}</p><p></p><p>		/* Callback invoked when the surface dimensions change. */</p><p>		<font class="keyword">public </font><font class="keyword">void </font>setSurfaceSize(</font><font class="keyword">int </font>width, </font><font class="keyword">int </font>height) {</p><p>			<font class="Comments">// synchronized to make sure these all change atomically</font></p><p>			<font class="keyword">synchronized </font>(mSurfaceHolder) {</p><p>				mCanvasWidth = width;</p><p>				mCanvasHeight = height;</p><p></p><p>				<font class="Comments">// don't forget to resize the background image</font></p><p>				mBackgroundImage = mBackgroundImage.createScaledBitmap(</p><p>						</font>mBackgroundImage, width, height, <font class="keyword">true</font>);</p><p>			}</p><p>		}</p><p></p><p>		<font class="Comments">/**</font></p><p>		 <font class="Comments">* Resumes from a pause.</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">public </font><font class="keyword">void </font>unpause() {</p><p>			<font class="Comments">// Move the real time clock up to now</font></p><p>			<font class="keyword">synchronized </font>(mSurfaceHolder) {</p><p>				mLastTime = System.currentTimeMillis() + 100;</p><p>			}</p><p>			setState(STATE_RUNNING);</p><p>		}</p><p></p><p>		<font class="Comments">/**</font></p><p>		 <font class="Comments">* Handles a key-down event.</font></p><p>		 <font class="Comments">* </font></p><p>		 <font class="Comments">* @param keyCode</font></p><p>		 <font class="Comments">*            the key that was pressed</font></p><p>		 <font class="Comments">* @param msg</font></p><p>		 <font class="Comments">*            the original event object</font></p><p>		 <font class="Comments">* @return true</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">boolean </font>doKeyDown(</font><font class="keyword">int </font>keyCode, KeyEvent msg) {</p><p>			<font class="keyword">synchronized </font>(mSurfaceHolder) {</p><p>				<font class="keyword">boolean </font>okStart = </font><font class="keyword">false</font>;</p><p>				<font class="keyword">if </font>(keyCode == KeyEvent.KEYCODE_DPAD_UP)</p><p>					</font>okStart = <font class="keyword">true</font>;</p><p>				<font class="keyword">if </font>(keyCode == KeyEvent.KEYCODE_DPAD_DOWN)</p><p>					</font>okStart = <font class="keyword">true</font>;</p><p>				<font class="keyword">if </font>(keyCode == KeyEvent.KEYCODE_S)</p><p>					</font>okStart = <font class="keyword">true</font>;</p><p>				<font class="keyword">boolean </font>center = (keyCode == KeyEvent.KEYCODE_DPAD_UP);</p><p>				<font class="keyword">if </font>(okStart</p><p>						&& (mMode == STATE_READY || mMode == STATE_LOSE || mMode == STATE_WIN)) {</p><p>					<font class="Comments">// ready-to-start -&gt; start</font></p><p>					doStart();</p><p>					<font class="keyword">return </font><font class="keyword">true</font>;</p><p>				</font>} <font class="keyword">else </font><font class="keyword">if </font>(mMode == STATE_PAUSE && okStart) {</p><p>					<font class="Comments">// paused -&gt; running</font></p><p>					unpause();</p><p>					<font class="keyword">return </font><font class="keyword">true</font>;</p><p>				</font>} <font class="keyword">else </font><font class="keyword">if </font>(mMode == STATE_RUNNING) {</p><p>					<font class="Comments">// center/space -&gt; fire</font></p><p>					<font class="keyword">if </font>(keyCode == KeyEvent.KEYCODE_DPAD_CENTER</p><p>							|| keyCode == KeyEvent.KEYCODE_SPACE) {</p><p>						</font>setFiring(<font class="keyword">true</font>);</p><p>						<font class="keyword">return </font><font class="keyword">true</font>;</p><p>						<font class="Comments">// left/q -&gt; left</font></p><p>					</font>} <font class="keyword">else </font><font class="keyword">if </font>(keyCode == KeyEvent.KEYCODE_DPAD_LEFT</p><p>							|| keyCode == KeyEvent.KEYCODE_Q) {</p><p>						mRotating = -1;</p><p>						<font class="keyword">return </font><font class="keyword">true</font>;</p><p>						<font class="Comments">// right/w -&gt; right</font></p><p>					</font>} <font class="keyword">else </font><font class="keyword">if </font>(keyCode == KeyEvent.KEYCODE_DPAD_RIGHT</p><p>							|| keyCode == KeyEvent.KEYCODE_W) {</p><p>						mRotating = 1;</p><p>						<font class="keyword">return </font><font class="keyword">true</font>;</p><p>						<font class="Comments">// up -&gt; pause</font></p><p>					</font>} <font class="keyword">else </font><font class="keyword">if </font>(keyCode == KeyEvent.KEYCODE_DPAD_UP) {</p><p>						pause();</p><p>						<font class="keyword">return </font><font class="keyword">true</font>;</p><p>					}</p><p>				}</p><p>				<font class="keyword">return </font><font class="keyword">false</font>;</p><p>			}</p><p>		}</p><p></p><p>		<font class="Comments">/**</font></p><p>		 <font class="Comments">* Handles a key-up event.</font></p><p>		 <font class="Comments">* </font></p><p>		 <font class="Comments">* @param keyCode</font></p><p>		 <font class="Comments">*            the key that was pressed</font></p><p>		 <font class="Comments">* @param msg</font></p><p>		 <font class="Comments">*            the original event object</font></p><p>		 <font class="Comments">* @return true if the key was handled and consumed, or else false</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">boolean </font>doKeyUp(</font><font class="keyword">int </font>keyCode, KeyEvent msg) {</p><p>			<font class="keyword">boolean </font>handled = </font><font class="keyword">false</font>;</p><p>			<font class="keyword">synchronized </font>(mSurfaceHolder) {</p><p>				<font class="keyword">if </font>(mMode == STATE_RUNNING) {</p><p>					<font class="keyword">if </font>(keyCode == KeyEvent.KEYCODE_DPAD_CENTER</p><p>							|| keyCode == KeyEvent.KEYCODE_SPACE) {</p><p>						</font>setFiring(<font class="keyword">false</font>);</p><p>						</font>handled = <font class="keyword">true</font>;</p><p>					</font>} <font class="keyword">else </font><font class="keyword">if </font>(keyCode == KeyEvent.KEYCODE_DPAD_LEFT</p><p>							|| keyCode == KeyEvent.KEYCODE_Q</p><p>							|| keyCode == KeyEvent.KEYCODE_DPAD_RIGHT</p><p>							|| keyCode == KeyEvent.KEYCODE_W) {</p><p>						mRotating = 0;</p><p>						</font>handled = <font class="keyword">true</font>;</p><p>					}</p><p>				}</p><p>			}</p><p>			<font class="keyword">return </font>handled;</p><p>		}</p><p></p><p>		<font class="Comments">/**</font></p><p>		 <font class="Comments">* Draws the ship, fuel/speed bars, and background to the provided</font></p><p>		 <font class="Comments">* Canvas.</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">private </font><font class="keyword">void </font>doDraw(Canvas canvas) {</p><p>			<font class="Comments">// Draw the background image. Operations on the Canvas accumulate</font></p><p>			<font class="Comments">// so this is like clearing the screen.</font></p><p>			</font>canvas.drawBitmap(mBackgroundImage, 0, 0, <font class="keyword">null</font>);</p><p>			<font class="keyword">int </font>yTop = mCanvasHeight - ((</font><font class="keyword">int</font>) mY + mLanderHeight / 2);</p><p>			<font class="keyword">int </font>xLeft = (</font><font class="keyword">int</font>) mX - mLanderWidth / 2;</p><p>			<font class="Comments">// Draw the fuel gauge</font></p><p>			<font class="keyword">int </font>fuelWidth = (</font><font class="keyword">int</font>) (UI_BAR * mFuel / PHYS_FUEL_MAX);</p><p>			mScratchRect.set(4, 4, 4 + fuelWidth, 4 + UI_BAR_HEIGHT);</p><p>			</font>canvas.drawRect(mScratchRect, mLinePa<font class="keyword">int</font>);</p><p>			<font class="Comments">// Draw the speed gauge, with a two-tone effect</font></p><p>			<font class="keyword">double </font>speed = Math.sqrt(mDX * mDX + mDY * mDY);</p><p>			<font class="keyword">int </font>speedWidth = (</font><font class="keyword">int</font>) (UI_BAR * speed / PHYS_SPEED_MAX);</p><p>			<font class="keyword">if </font>(speed &lt;= mGoalSpeed) {</p><p>				mScratchRect.set(4 + UI_BAR + 4, 4,</p><p>						4 + UI_BAR + 4 + speedWidth, 4 + UI_BAR_HEIGHT);</p><p>				</font>canvas.drawRect(mScratchRect, mLinePa<font class="keyword">int</font>);</p><p>			</font>} <font class="keyword">else </font>{</p><p>				<font class="Comments">// Draw the bad color in back, with the good color in front of</font></p><p>				<font class="Comments">// it</font></p><p>				mScratchRect.set(4 + UI_BAR + 4, 4,</p><p>						4 + UI_BAR + 4 + speedWidth, 4 + UI_BAR_HEIGHT);</p><p>				canvas.drawRect(mScratchRect, mLinePaintBad);</p><p>				<font class="keyword">int </font>goalWidth = (UI_BAR * mGoalSpeed / PHYS_SPEED_MAX);</p><p>				mScratchRect.set(4 + UI_BAR + 4, 4, 4 + UI_BAR + 4 + goalWidth,</p><p>						4 + UI_BAR_HEIGHT);</p><p>				</font>canvas.drawRect(mScratchRect, mLinePa<font class="keyword">int</font>);</p><p>			}</p><p>			<font class="Comments">// Draw the landing pad</font></p><p>			canvas.drawLine(mGoalX, 1 + mCanvasHeight - TARGET_PAD_HEIGHT,</p><p>					mGoalX + mGoalWidth, 1 + mCanvasHeight - TARGET_PAD_HEIGHT,</p><p>					</font>mLinePa<font class="keyword">int</font>);</p><p>			<font class="Comments">// Draw the ship with its current rotation</font></p><p>			canvas.save();</p><p>			</font>canvas.rotate((<font class="keyword">float</font>) mHeading, (</font><font class="keyword">float</font>) mX, mCanvasHeight</p><p>					</font>- (<font class="keyword">float</font>) mY);</p><p>			<font class="keyword">if </font>(mMode == STATE_LOSE) {</p><p>				mCrashedImage.setBounds(xLeft, yTop, xLeft + mLanderWidth, yTop</p><p>						+ mLanderHeight);</p><p>				mCrashedImage.draw(canvas);</p><p>			</font>} <font class="keyword">else </font><font class="keyword">if </font>(mEngineFiring) {</p><p>				mFiringImage.setBounds(xLeft, yTop, xLeft + mLanderWidth, yTop</p><p>						+ mLanderHeight);</p><p>				mFiringImage.draw(canvas);</p><p>			</font>} <font class="keyword">else </font>{</p><p>				mLanderImage.setBounds(xLeft, yTop, xLeft + mLanderWidth, yTop</p><p>						+ mLanderHeight);</p><p>				mLanderImage.draw(canvas);</p><p>			}</p><p>			canvas.restore();</p><p>		}</p><p></p><p>		<font class="Comments">/**</font></p><p>		 <font class="Comments">* Figures the lander state (x, y, fuel, ...) based on the passage of</font></p><p>		 <font class="Comments">* realtime. Does not invalidate(). Called at the start of draw().</font></p><p>		 <font class="Comments">* Detects the end-of-game and sets the UI to the next state.</font></p><p>		 <font class="Comments">*/</font></p><p>		<font class="keyword">private </font><font class="keyword">void </font>updatePhysics() {</p><p>			<font class="keyword">long </font>now = System.currentTimeMillis();</p><p>			<font class="Comments">// Do nothing if mLastTime is in the future.</font></p><p>			<font class="Comments">// This allows the game-start to delay the start of the physics</font></p><p>			<font class="Comments">// by 100ms or whatever.</font></p><p>			<font class="keyword">if </font>(mLastTime &gt; now)</p><p>				<font class="keyword">return</font>;</font></p><p>			<font class="keyword">double </font>elapsed = (now - mLastTime) / 1000.0;</p><p>			<font class="Comments">// mRotating -- update heading</font></p><p>			<font class="keyword">if </font>(mRotating != 0) {</p><p>				mHeading += mRotating * (PHYS_SLEW_SEC * elapsed);</p><p>				<font class="Comments">// Bring things back into the range 0..360</font></p><p>				<font class="keyword">if </font>(mHeading &lt; 0)</p><p>					mHeading += 360;</p><p>				<font class="keyword">else </font><font class="keyword">if </font>(mHeading &gt;= 360)</p><p>					mHeading -= 360;</p><p>			}</p><p>			<font class="Comments">// Base accelerations -- 0 for x, gravity for y</font></p><p>			<font class="keyword">double </font>ddx = 0.0;</p><p>			<font class="keyword">double </font>ddy = -PHYS_DOWN_ACCEL_SEC * elapsed;</p><p>			<font class="keyword">if </font>(mEngineFiring) {</p><p>				<font class="Comments">// taking 0 as up, 90 as to the right</font></p><p>				<font class="Comments">// cos(deg) is ddy component, sin(deg) is ddx component</font></p><p>				<font class="keyword">double </font>elapsedFiring = elapsed;</p><p>				<font class="keyword">double </font>fuelUsed = elapsedFiring * PHYS_FUEL_SEC;</p><p>				<font class="Comments">// tricky case where we run out of fuel partway through the</font></p><p>				<font class="Comments">// elapsed</font></p><p>				<font class="keyword">if </font>(fuelUsed &gt; mFuel) {</p><p>					elapsedFiring = mFuel / fuelUsed * elapsed;</p><p>					fuelUsed = mFuel;</p><p>					<font class="Comments">// Oddball case where we adjust the "control" from here</font></p><p>					</font>mEngineFiring = <font class="keyword">false</font>;</p><p>				}</p><p>				mFuel -= fuelUsed;</p><p>				<font class="Comments">// have this much acceleration from the engine</font></p><p>				<font class="keyword">double </font>accel = PHYS_FIRE_ACCEL_SEC * elapsedFiring;</p><p>				<font class="keyword">double </font>radians = 2 * Math.PI * mHeading / 360;</p><p>				ddx = Math.sin(radians) * accel;</p><p>				ddy += Math.cos(radians) * accel;</p><p>			}</p><p>			<font class="keyword">double </font>dxOld = mDX;</p><p>			<font class="keyword">double </font>dyOld = mDY;</p><p>			<font class="Comments">// figure speeds for the end of the period</font></p><p>			mDX += ddx;</p><p>			mDY += ddy;</p><p>			<font class="Comments">// figure position based on average speed during the period</font></p><p>			mX += elapsed * (mDX + dxOld) / 2;</p><p>			mY += elapsed * (mDY + dyOld) / 2;</p><p>			mLastTime = now;</p><p>			<font class="Comments">// Evaluate if we have landed ... stop the game</font></p><p>			<font class="keyword">double </font>yLowerBound = TARGET_PAD_HEIGHT + mLanderHeight / 2</p><p>					- TARGET_BOTTOM_PADDING;</p><p>			<font class="keyword">if </font>(mY &lt;= yLowerBound) {</p><p>				mY = yLowerBound;</p><p>				<font class="keyword">int </font>result = STATE_LOSE;</p><p>				</font>CharSequence message = <font class="Fields">""</font>;</p><p>				Resources res = mContext.getResources();</p><p>				<font class="keyword">double </font>speed = Math.sqrt(mDX * mDX + mDY * mDY);</p><p>				<font class="keyword">boolean </font>onGoal = (mGoalX &lt;= mX - mLanderWidth / 2 && mX</p><p>						+ mLanderWidth / 2 &lt;= mGoalX + mGoalWidth);</p><p>				<font class="Comments">// "Hyperspace" win -- upside down, going fast,</font></p><p>				<font class="Comments">// puts you back at the top.</font></p><p>				<font class="keyword">if </font>(onGoal && Math.abs(mHeading - 180) &lt; mGoalAngle</p><p>						&& speed &gt; PHYS_SPEED_HYPERSPACE) {</p><p>					result = STATE_WIN;</p><p>					mWinsInARow++;</p><p>					doStart();</p><p>					<font class="keyword">return</font>;</font></p><p>					<font class="Comments">// Oddball case: this case does a return, all other cases</font></p><p>					<font class="Comments">// fall through to setMode() below.</font></p><p>				</font>} <font class="keyword">else </font><font class="keyword">if </font>(!onGoal) {</p><p>					message = res.getText(R.string.message_off_pad);</p><p>				</font>} <font class="keyword">else </font><font class="keyword">if </font>(!(mHeading &lt;= mGoalAngle || mHeading &gt;= 360 - mGoalAngle)) {</p><p>					message = res.getText(R.string.message_bad_angle);</p><p>				</font>} <font class="keyword">else </font><font class="keyword">if </font>(speed &gt; mGoalSpeed) {</p><p>					message = res.getText(R.string.message_too_fast);</p><p>				</font>} <font class="keyword">else </font>{</p><p>					result = STATE_WIN;</p><p>					mWinsInARow++;</p><p>				}</p><p>				setState(result, message);</p><p>			}</p><p>		}</p><p>	}</p><p></p><p>	<font class="Comments">/** Handle to the application context, used to e.g. fetch Drawables. */</font></p><p>	<font class="keyword">private </font>Context mContext;</p><p>	<font class="Comments">/** Pointer to the text view to display "Paused.." etc. */</font></p><p>	<font class="keyword">private </font>TextView mStatusText;</p><p>	<font class="Comments">/** The thread that actually draws the animation */</font></p><p>	<font class="keyword">private </font>LunarThread thread;</p><p></p><p>	<font class="keyword">public </font>LunarView(Context context, AttributeSet attrs) {</p><p>		<font class="keyword">super</font>(context, attrs);</p><p>		<font class="Comments">// register our interest in hearing about changes to our surface</font></p><p>		SurfaceHolder holder = getHolder();</p><p>		</font>holder.addCallback(<font class="keyword">this</font>);</p><p></p><p>		<font class="Comments">// create thread only; it's started in surfaceCreated()</font></p><p>		</font>thread = <font class="keyword">new </font>LunarThread(holder, context, </font><font class="keyword">new </font>Handler() {</p><p>			@Override</p><p>			<font class="keyword">public </font><font class="keyword">void </font>handleMessage(Message m) {</p><p>				</font>mStatusText.setVisibility(m.getData().getInt(<font class="Fields">"viz"</font>));</p><p>				</font>mStatusText.setText(m.getData().getString(<font class="Fields">"text"</font>));</p><p>			}</p><p>		});</p><p>		</font>setFocusable(<font class="keyword">true</font>); <font class="Comments">// make sure we get key events</font></p><p>	}</p><p></p><p>	<font class="Comments">/**</font></p><p>	 <font class="Comments">* Fetches the animation thread corresponding to this LunarView.</font></p><p>	 <font class="Comments">* </font></p><p>	 <font class="Comments">* @return the animation thread</font></p><p>	 <font class="Comments">*/</font></p><p>	<font class="keyword">public </font>LunarThread getThread() {</p><p>		<font class="keyword">return </font>thread;</p><p>	}</p><p></p><p>	<font class="Comments">/**</font></p><p>	 <font class="Comments">* Standard override to get key-press events.</font></p><p>	 <font class="Comments">*/</font></p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">boolean </font>onKeyDown(</font><font class="keyword">int </font>keyCode, KeyEvent msg) {</p><p>		<font class="keyword">return </font>thread.doKeyDown(keyCode, msg);</p><p>	}</p><p></p><p>	<font class="Comments">/**</font></p><p>	 <font class="Comments">* Standard override for key-up. We actually care about these, so we can</font></p><p>	 <font class="Comments">* turn off the engine or stop rotating.</font></p><p>	 <font class="Comments">*/</font></p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">boolean </font>onKeyUp(</font><font class="keyword">int </font>keyCode, KeyEvent msg) {</p><p>		<font class="keyword">return </font>thread.doKeyUp(keyCode, msg);</p><p>	}</p><p></p><p>	<font class="Comments">/**</font></p><p>	 <font class="Comments">* Standard window-focus override. Notice focus lost so we can pause on</font></p><p>	 <font class="Comments">* focus lost. e.g. user switches to take a call.</font></p><p>	 <font class="Comments">*/</font></p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">void </font>onWindowFocusChanged(</font><font class="keyword">boolean </font>hasWindowFocus) {</p><p>		<font class="keyword">if </font>(!hasWindowFocus)</p><p>			thread.pause();</p><p>	}</p><p></p><p>	<font class="Comments">/**</font></p><p>	 <font class="Comments">* Installs a pointer to the text view used for messages.</font></p><p>	 <font class="Comments">*/</font></p><p>	<font class="keyword">public </font><font class="keyword">void </font>setTextView(TextView textView) {</p><p>		mStatusText = textView;</p><p>	}</p><p></p><p>	/* Callback invoked when the surface dimensions change. */</p><p>	<font class="keyword">public </font><font class="keyword">void </font>surfaceChanged(SurfaceHolder holder, </font><font class="keyword">int </font>format, </font><font class="keyword">int </font>width,</p><p>			<font class="keyword">int </font>height) {</p><p>		thread.setSurfaceSize(width, height);</p><p>	}</p><p></p><p>	/*</p><p>	 <font class="Comments">* Callback invoked when the Surface has been created and is ready to be</font></p><p>	 <font class="Comments">* used.</font></p><p>	 <font class="Comments">*/</font></p><p>	<font class="keyword">public </font><font class="keyword">void </font>surfaceCreated(SurfaceHolder holder) {</p><p>		<font class="Comments">// start the thread here so that we don't busy-wait in run()</font></p><p>		<font class="Comments">// waiting for the surface to be created</font></p><p>		</font>thread.setRunning(<font class="keyword">true</font>);</p><p>		thread.start();</p><p>	}</p><p></p><p>	/*</p><p>	 <font class="Comments">* Callback invoked when the Surface has been destroyed and must no longer</font></p><p>	 <font class="Comments">* be touched. WARNING: after this method returns, the Surface/Canvas must</font></p><p>	 <font class="Comments">* never be touched again!</font></p><p>	 <font class="Comments">*/</font></p><p>	<font class="keyword">public </font><font class="keyword">void </font>surfaceDestroyed(SurfaceHolder holder) {</p><p>		<font class="Comments">// we have to tell thread to shut down & wait for it to finish, or else</font></p><p>		<font class="Comments">// it might touch the Surface after we return and explode</font></p><p>		<font class="keyword">boolean </font>re</font><font class="keyword">try </font>= </font><font class="keyword">true</font>;</p><p>		</font>thread.setRunning(<font class="keyword">false</font>);</p><p>		<font class="keyword">while </font>(retry) {</p><p>			<font class="keyword">try </font>{</p><p>				thread.join();</p><p>				</font>re<font class="keyword">try </font>= </font><font class="keyword">false</font>;</p><p>			</font>} <font class="keyword">catch </font>(InterruptedException e) {</p><p>			}</p><p>		}</p><p>	}</p><p>}</p><p></pre></p><p></p></div>

</DIV></DIV>

<DIV id=footer style="display:none">
<P align="center">  
 
 
 
    </P>
</DIV></BODY></HTML>

