
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>【Android2D游戏开发十六】详解Gesture 手势操作！实现切换图片_Android学习手册</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<META name=GENERATOR content="MSHTML 8.00.6001.18702">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">

</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li ><A href="../component/index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li ><A href="../device/index.html">设备功能</A> </li><li ><A href="../datastorage/index.html">数据存储</A> </li><li ><A href="../network/index.html">网络应用</A> </li><li class="navcurrentLink"><A href="index.html">游戏开发</A> </li><li ><A href="../multimedia/index.html">多媒体</A> </li><li ><A href="../source/index.html">源码开发</A> </li><li ><A href="../advance/index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">课 程 表</div>


  <h2><A title="游戏开发须知" href="index_187.html">游戏开发须知</A></h2>

  <h2><A title="游戏策划、设计分析" href="index_188.html">游戏策划、设计分析</A></h2>

  <h2><A title="Android OpenGL学习" href="index_190.html">Android OpenGL学习</A></h2>

  <h2><A title="Android游戏开发之旅" href="index_191.html">Android游戏开发之旅</A></h2>

  <h2><A title="Android2D游戏开发" href="index_192.html">Android2D游戏开发</A></h2>
<UL><li ><A title=【Android2D游戏开发之一】设置全屏以及绘画简单的图形 href="show_501_192.html">【Android2D游戏开发之一】设置全屏以及绘画简单的图形</A> </li><li ><A title=【Android2D游戏开发之二】剖析游戏开发用view还是sarfaceView？ href="show_502_192.html">【Android2D游戏开发之二】剖析游戏开发用view还是sarfaceView？</A> </li><li ><A title=【Android2D游戏开发之三】剖析 SurfaceView ！ Callback以及SurfaceHol href="show_503_192.html">【Android2D游戏开发之三】剖析 SurfaceView ！ Callback以及SurfaceHol</A> </li><li ><A title=【Android2D游戏开发之四】Android 游戏框架（游戏角色行走demo) href="show_504_192.html">【Android2D游戏开发之四】Android 游戏框架（游戏角色行走demo)</A> </li><li ><A title=【Android2D游戏开发之五】游戏注册界面,两个Activity切换交互 href="show_505_192.html">【Android2D游戏开发之五】游戏注册界面,两个Activity切换交互</A> </li><li ><A title=【Android2D游戏开发之六】在SurfaceView中添加组件！并交互数据 href="show_506_192.html">【Android2D游戏开发之六】在SurfaceView中添加组件！并交互数据</A> </li><li ><A title=【Android2D游戏开发之七】游戏开发样式!再剖析SurfaceView组件 href="show_507_192.html">【Android2D游戏开发之七】游戏开发样式!再剖析SurfaceView组件</A> </li><li ><A title=【Android2D游戏开发之八】游戏音频 href="show_508_192.html">【Android2D游戏开发之八】游戏音频</A> </li><li ><A title=【Android2D游戏开发之九】触屏Bug解决方案及禁止横竖屏切换! href="show_509_192.html">【Android2D游戏开发之九】触屏Bug解决方案及禁止横竖屏切换!</A> </li><li ><A title=【Android2D游戏开发之十】详细剖析Android Traceview效率检视工具 href="show_510_192.html">【Android2D游戏开发之十】详细剖析Android Traceview效率检视工具</A> </li><li ><A title=【Android2D游戏开发十一】手把手让你爱上Android “9妹” href="show_511_192.html">【Android2D游戏开发十一】手把手让你爱上Android “9妹”</A> </li><li ><A title=【Android2D游戏开发十二】详解SharedPreference,FIle将数据存到SD卡 href="show_512_192.html">【Android2D游戏开发十二】详解SharedPreference,FIle将数据存到SD卡</A> </li><li ><A title=【Android2D游戏开发十三】详解SQLite，并把数据库文件存SD卡中-2 href="show_513_192.html">【Android2D游戏开发十三】详解SQLite，并把数据库文件存SD卡中-2</A> </li><li ><A title=【Android2D游戏开发十四】在SurfaceView中照样使用Animation(下) href="show_514_192.html">【Android2D游戏开发十四】在SurfaceView中照样使用Animation(下)</A> </li><li ><A title=【Android2D游戏开发十五】游戏触屏事件的性能优化笔记！ href="show_515_192.html">【Android2D游戏开发十五】游戏触屏事件的性能优化笔记！</A> </li><li class="currentLink"><A title=【Android2D游戏开发十六】详解Gesture 手势操作！实现切换图片 href="show_516_192.html">【Android2D游戏开发十六】详解Gesture 手势操作！实现切换图片</A> </li><li ><A title=【Android2D游戏开发十七】输入法手势技术,自定义手势玩游戏 href="show_517_192.html">【Android2D游戏开发十七】输入法手势技术,自定义手势玩游戏</A> </li><li ><A title=【Android2D游戏开发十八】解放手指,利用传感器开发游戏！ href="show_518_192.html">【Android2D游戏开发十八】解放手指,利用传感器开发游戏！</A> </li><li ><A title=【Android2D游戏开发十九】(必看篇)剖析Back与Home键及异常处理 href="show_519_192.html">【Android2D游戏开发十九】(必看篇)剖析Back与Home键及异常处理</A> </li><li ><A title=【Android2D游戏开发二十】物理游戏之重力系统开发 href="show_520_192.html">【Android2D游戏开发二十】物理游戏之重力系统开发</A> </li><li ><A title=【Android2D游戏开发二十一】Android设备谎言分辨率的解决方案 href="show_521_192.html">【Android2D游戏开发二十一】Android设备谎言分辨率的解决方案</A> </li><li ><A title=【Android游戏开发二十二】详解游戏中如何灵活实现动画播放! href="show_522_192.html">【Android游戏开发二十二】详解游戏中如何灵活实现动画播放!</A> </li><li ><A title=【Android游戏开发二十三】自定义【通用】ListView适配器 href="show_523_192.html">【Android游戏开发二十三】自定义【通用】ListView适配器</A> </li><li ><A title=【Android游戏开发二十四】360°平滑游戏摇杆 href="show_524_192.html">【Android游戏开发二十四】360°平滑游戏摇杆</A> </li><li ><A title=【Android游戏开发二十五】Android平台使用《贝赛尔曲线》！ href="show_525_192.html">【Android游戏开发二十五】Android平台使用《贝赛尔曲线》！</A> </li><li ><A title=【Android游戏开发二十六】追加简述SurfaceView 与 GLSurfaceView效 href="show_526_192.html">【Android游戏开发二十六】追加简述SurfaceView 与 GLSurfaceView效</A> </li></UL>
  <h2><A title="Android经典实例教程解析" href="index_193.html">Android经典实例教程解析</A></h2>

  <h2><A title="Android游戏开发实例" href="index_194.html">Android游戏开发实例</A></h2>

  <h2><A title="Libgdx游戏引擎" href="index_195.html">Libgdx游戏引擎</A></h2>

</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1></H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>【Android2D游戏开发十六】详解Gesture 手势操作！实现切换图片</H2>
<div style="line-height:20px; font-size:14px;"><p>对于Android的手势不光在软件中会经常用到，比如浏览器中的翻页，滚动页面等等;当然其实在我们开发Android游戏的时候加上了Android手势操作更会让游戏增加一个亮点，比如一般的CAG,PUZ等类型的游戏选择关卡啦、简单背景的移动啦，都可以使用手势来操作即可，类似前段时间很火的《让人愤怒的小鸟！》咳咳、不好意思说错了，是《愤怒的小鸟》，因为总是听群里啊，朋友啊说小鸟出新版本啦，小鸟出PC硬盘版啦！ 唉~你说可让人愤怒，其实说实话，小鸟这个游戏确实不错，我所看到的唯一的亮点是这款游戏的创意！说实话，现在的游戏没有做不出来的只有想不出来的好创意、咳咳。回到话题来，那么下面我们来稍微了解下什么是Android 手势！</p><p>所谓手势操作，类似跳舞机、EZdancer~这些利用不同动作和音符让人手舞足蹈一样，那么Android这里的手势只是让我们在游戏和软件中的操作有了更多的花样和玩法，根据玩家接触屏幕时间的长短，在屏幕上滑动的距离，按下抬起的时间等进行了包装，其实就是Android 对触屏处理做了包装和处理。</p><p>那么在Android中其实有两种手势识别技术。一种是触摸屏手势识别，另一种是输入法手势识别；两者比较起来第二种比较灵活，可以自定义手势，比较high！那么这一节我们先来介绍第一种手势识别：触摸屏手势识别;在下篇博文中我会给童鞋们讲解输入法手势识别！</p><p>先把两张截图放上来吧</p><p><img src="../img/games_2d/16_2dgames.jpg"></p><p><img src="../img/games_2d/16_2dgames2.jpg"></p><p>OK，老方式，先上代码：MySurfaceView.java</p><p><pre><font class="keyword">import </font>java.util.Vector;</p><p><font class="keyword">import </font>android.content.Context;</p><p><font class="keyword">import </font>android.graphics.Bitmap;</p><p><font class="keyword">import </font>android.graphics.BitmapFactory;</p><p><font class="keyword">import </font>android.graphics.Canvas;</p><p><font class="keyword">import </font>android.graphics.Color;</p><p><font class="keyword">import </font>android.graphics.Paint;</p><p><font class="keyword">import </font>android.util.Log;</p><p><font class="keyword">import </font>android.view.GestureDetector;</p><p><font class="keyword">import </font>android.view.MotionEvent;</p><p><font class="keyword">import </font>android.view.SurfaceHolder;</p><p><font class="keyword">import </font>android.view.SurfaceView;</p><p><font class="keyword">import </font>android.view.View;</p><p><font class="keyword">import </font>android.view.GestureDetector.OnGestureListener;</p><p><font class="keyword">import </font>android.view.SurfaceHolder.Callback;</p><p><font class="keyword">import </font>android.view.View.OnTouchListener;</p><p><font class="Comments">/**</font></p><p> <font class="Comments">* @ Gesture （上文）触摸屏手势识别</font></p><p> <font class="Comments">*/</font></p><p><font class="keyword">public </font><font class="keyword">class </font>MySurfaceViewAnimation </font><font class="keyword">extends </font>SurfaceView </font><font class="keyword">implements </font>Callback,</p><p>		Runnable, OnGestureListener, OnTouchListener {</p><p>	<font class="keyword">private </font>Thread th = </font><font class="keyword">new </font>Thread(</font><font class="keyword">this</font>);</p><p>	<font class="keyword">private </font>SurfaceHolder sfh;</p><p>	<font class="keyword">private </font>Canvas canvas;</p><p>	<font class="keyword">private </font>Pa</font><font class="keyword">int </font>paint;</p><p>	<font class="keyword">private </font>Bitmap bmp;</p><p>	<font class="keyword">private </font>GestureDetector gd;</p><p>	<font class="keyword">private </font><font class="keyword">int </font>bmp_x, bmp_y;</p><p>	<font class="keyword">private </font><font class="keyword">boolean </font>isChagePage;</p><p>	<font class="keyword">private </font>Vector&lt;String&gt; v_str;<font class="Comments">// 备注1</font></p><p>	<font class="keyword">public </font>MySurfaceViewAnimation(Context context) {</p><p>		<font class="keyword">super</font>(context);</p><p>		</font>v_str = <font class="keyword">new </font>Vector&lt;String&gt;();</p><p>		<font class="keyword">this</font>.setKeepScreenOn(</font><font class="keyword">true</font>);</p><p>		bmp = BitmapFactory.decodeResource(getResources(),</p><p>				R.drawable.android_dream);</p><p>		</font>sfh = <font class="keyword">this</font>.getHolder();</p><p>		</font>sfh.addCallback(<font class="keyword">this</font>);</p><p>		</font>pa<font class="keyword">int </font>= </font><font class="keyword">new </font>Paint();</p><p>		</font>paint.setAntiAlias(<font class="keyword">true</font>);</p><p>		<font class="keyword">this</font>.setLongClickable(</font><font class="keyword">true</font>);</p><p>		<font class="Comments">// setLongClickable( true )是必须的，因为 只有这样，</font></p><p>		<font class="Comments">// 我们当前的SurfaceView(view)才能够处理不同于触屏形式;</font></p><p>		<font class="Comments">// 例如：ACTION_MOVE，或者多个ACTION_DOWN</font></p><p>		<font class="keyword">this</font>.setOnTouchListener(</font><font class="keyword">this</font>);<font class="Comments">// 将本类绑定触屏监听器</font></p><p>		</font>gd = <font class="keyword">new </font>GestureDetector(</font><font class="keyword">this</font>);</p><p>		</font>gd.setIsLongpressEnabled(<font class="keyword">true</font>);</p><p>	}</p><p>	<font class="keyword">public </font><font class="keyword">void </font>surfaceCreated(SurfaceHolder holder) {</p><p>		<font class="Comments">// 当系统调用了此方法才创建了view所以在这里才能取到view的宽高！！有些童鞋总是把东西都放在初始化函数里！</font></p><p>		<font class="Comments">// 线程最好放在这里来启动，因为放在初始化里的画，那view还没有呢,到了提交画布unlockCanvasAndPost的时候就异常啦！</font></p><p>		bmp_x = (getWidth() - bmp.getWidth()) &gt;&gt; 2;</p><p>		bmp_y = (getHeight() - bmp.getHeight()) &gt;&gt; 2;</p><p>		th.start();</p><p>	}</p><p>	<font class="keyword">public </font><font class="keyword">void </font>draw() {</p><p>		<font class="keyword">try </font>{</p><p>			canvas = sfh.lockCanvas();</p><p>			<font class="keyword">if </font>(canvas != </font><font class="keyword">null</font>) {</p><p>				canvas.drawColor(Color.WHITE);<font class="Comments">// 画布刷屏</font></p><p>				</font>canvas.drawBitmap(bmp, bmp_x, bmp_y, pa<font class="keyword">int</font>);</p><p>				paint.setTextSize(20);<font class="Comments">// 设置文字大小</font></p><p>				paint.setColor(Color.WHITE);</p><p>				<font class="Comments">// 这里画出一个矩形方便童鞋们看到手势操作调用的函数都是哪些</font></p><p>				</font>canvas.drawRect(50, 30, 175, 120, pa<font class="keyword">int</font>);</p><p>				paint.setColor(Color.RED);<font class="Comments">// 设置文字颜色</font></p><p>				<font class="keyword">if </font>(v_str != </font><font class="keyword">null</font>) {</p><p>					<font class="keyword">for </font>(</font><font class="keyword">int </font>i = 0; i &lt; v_str.size(); i++) {</p><p>						canvas.drawText(v_str.elementAt(i), 50, 50 + i * 30,</p><p>								</font>pa<font class="keyword">int</font>);</p><p>					}</p><p>				}</p><p>			}</p><p>		</font>} <font class="keyword">catch </font>(Exception e) {</p><p>			</font>Log.v(<font class="Fields">"android"</font>, </font><font class="Fields">"draw is Error!"</font>);</p><p>		} finally {</p><p>			sfh.unlockCanvasAndPost(canvas);</p><p>		}</p><p>	}</p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">void </font>run() {</p><p>		<font class="keyword">while </font>(</font><font class="keyword">true</font>) {</p><p>			draw();</p><p>			<font class="keyword">try </font>{</p><p>				Thread.sleep(100);</p><p>			</font>} <font class="keyword">catch </font>(Exception ex) {</p><p>			}</p><p>		}</p><p>	}</p><p>	<font class="keyword">public </font><font class="keyword">void </font>surfaceChanged(SurfaceHolder holder, </font><font class="keyword">int </font>format, </font><font class="keyword">int </font>width,</p><p>			<font class="keyword">int </font>height) {</p><p>	}</p><p>	<font class="keyword">public </font><font class="keyword">void </font>surfaceDestroyed(SurfaceHolder holder) {</p><p>	}</p><p>	<font class="Comments">// @Override</font></p><p>	<font class="Comments">// public boolean onTouchEvent(MotionEvent event) {<font class="Comments">// 备注2</font></p><p>	<font class="Comments">// return true;</font></p><p>	<font class="Comments">// }</font></p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">boolean </font>onTouch(View v, MotionEvent event) {<font class="Comments">// 备注3</font></p><p>		<font class="keyword">if </font>(v_str != </font><font class="keyword">null</font>)</p><p>			v_str.removeAllElements();</p><p>		<font class="keyword">return </font>gd.onTouchEvent(event);<font class="Comments">// 备注4</font></p><p>	}</p><p>	<font class="Comments">// --------------以下是使用OnGestureListener手势监听的时候重写的函数---------</font></p><p>	<font class="Comments">/**</font></p><p>	 <font class="Comments">* @以下方法中的参数解释：</font></p><p>	 <font class="Comments">* @e1：第1个是 ACTION_DOWN MotionEvent 按下的动作</font></p><p>	 <font class="Comments">* @e2：后一个是ACTION_UP MotionEvent 抬起的动作(这里要看下备注5的解释)</font></p><p>	 <font class="Comments">* @velocityX：X轴上的移动速度，像素/秒</font></p><p>	 <font class="Comments">* @velocityY：Y轴上的移动速度，像素/秒</font></p><p>	 <font class="Comments">*/</font></p><p>	@Override</p><p>	<font class="keyword">public </font><font class="keyword">boolean </font>onDown(MotionEvent e) {</p><p>		<font class="Comments">// ACTION_DOWN</font></p><p>		</font>v_str.add(<font class="Fields">"onDown"</font>);</p><p>		<font class="keyword">return </font><font class="keyword">false</font>;</p><p>	}</p><p>	@Override</p><p>	<font class="Comments">// ACTION_DOWN 、短按不移动</font></p><p>	<font class="keyword">public </font><font class="keyword">void </font>onShowPress(MotionEvent e) {</p><p>		</font>v_str.add(<font class="Fields">"onShowPress"</font>);</p><p>	}</p><p>	@Override</p><p>	<font class="Comments">// ACTION_DOWN 、长按不滑动</font></p><p>	<font class="keyword">public </font><font class="keyword">void </font>onLongPress(MotionEvent e) {</p><p>		</font>v_str.add(<font class="Fields">"onLongPress"</font>);</p><p>	}</p><p>	@Override</p><p>	<font class="Comments">// ACTION_DOWN 、慢滑动</font></p><p>	<font class="keyword">public </font><font class="keyword">boolean </font>onScroll(MotionEvent e1, MotionEvent e2, </font><font class="keyword">float </font>distanceX,</p><p>			<font class="keyword">float </font>distanceY) {</p><p>		</font>v_str.add(<font class="Fields">"onScroll"</font>);</p><p>		<font class="keyword">return </font><font class="keyword">false</font>;</p><p>	}</p><p>	@Override</p><p>	<font class="Comments">// ACTION_DOWN 、快滑动、 ACTION_UP</font></p><p>	<font class="keyword">public </font><font class="keyword">boolean </font>onFling(MotionEvent e1, MotionEvent e2, </font><font class="keyword">float </font>velocityX,</p><p>			<font class="keyword">float </font>velocityY) {</p><p>		</font>v_str.add(<font class="Fields">"onFling"</font>);</p><p>		<font class="Comments">// -------备注5----------</font></p><p>		<font class="Comments">// if(e1.getAction()==MotionEvent.ACTION_MOVE){</font></p><p>		<font class="Comments">// v_str.add("onFling");</font></p><p>		<font class="Comments">// }else if(e1.getAction()==MotionEvent.ACTION_DOWN){</font></p><p>		<font class="Comments">// v_str.add("onFling");</font></p><p>		<font class="Comments">// }else if(e1.getAction()==MotionEvent.ACTION_UP){</font></p><p>		<font class="Comments">// v_str.add("onFling");</font></p><p>		<font class="Comments">// }</font></p><p>		<font class="Comments">// if(e2.getAction()==MotionEvent.ACTION_MOVE){</font></p><p>		<font class="Comments">// v_str.add("onFling");</font></p><p>		<font class="Comments">// }else if(e2.getAction()==MotionEvent.ACTION_DOWN){</font></p><p>		<font class="Comments">// v_str.add("onFling");</font></p><p>		<font class="Comments">// }else if(e2.getAction()==MotionEvent.ACTION_UP){</font></p><p>		<font class="Comments">// v_str.add("onFling");</font></p><p>		<font class="Comments">// }</font></p><p>		<font class="keyword">if </font>(isChagePage)</p><p>			bmp = BitmapFactory.decodeResource(getResources(),</p><p>					R.drawable.android_dream);</p><p>		else</p><p>			bmp = BitmapFactory.decodeResource(getResources(),</p><p>					R.drawable.android_warm);</p><p>		isChagePage = !isChagePage;</p><p>		<font class="keyword">return </font><font class="keyword">false</font>;</p><p>	}</p><p>	@Override</p><p>	<font class="Comments">// 短按ACTION_DOWN、ACTION_UP</font></p><p>	<font class="keyword">public </font><font class="keyword">boolean </font>onSingleTapUp(MotionEvent e) {</p><p>		</font>v_str.add(<font class="Fields">"onSingleTapUp"</font>);</p><p>		<font class="keyword">return </font><font class="keyword">false</font>;</p><p>	}</p><p>}</p><p></pre></p><p>补充一下：代码初始化手势的时候有这么一句:gd.setIsLongpressEnabled(true);这个函数标识，如果你设置true的话就是开启了长按键，当你长时间触屏不动就能得到 onLongPress 手势，如果设置false 那么你长时间触屏不移动也得不到这个手势的支持~此函数不设置也默认设置为true</p><p>备注1:</p><p>这里我只是给一些不太熟悉这种定义Vector方式的童鞋简单介绍一下：我们一般定义容器的时候都是直接 Vector vc =new Vector();嗯，没错，但是这种Vector&lt;String&gt;的定义是种泛型定义，那么简单的说下区别，如果Vector vc =new Vector();这种方式装入Object的以后，取的时候是不是要把取出的进行强转一下类型？！ 呵呵，而Vector&lt;String&gt;这种定义的时候就表明了这个容器我只装String类型的元素，so~取出的时候也不用再去强转了。</p><p>备注2 :</p><p>通过测试发现，这里仍然响应触屏时间，即使你把触屏焦点设置成setFocusableInTouchMode(false)也会调用！！！原因是因为我们本类的view绑定了触屏事件监听器，那么肯定会先响应备注3，然后我们备注4这里没有 return true而是直接返给了手势监听器去监听，让监听器找合适的函数来处理用户的手势,也就是说没有标志处理完成，所以我们的重写的onTouchEvent()也会继续去处理!</p><p>备注5：这里注释的代码我是在测试两个动作到底是哪两个，因为网上介绍Android手势帖子都疯传说: 第一个是MotionEvent.ACTION_DOWN 第二个是MotionEvent.ACTION_MOVE!那么第一个动作是按下好理解是玩家刚触屏的动作，第二个是move！难道是移动的点都记录下来了？？ 其实测试结果发现： 第一个是MotionEvent.ACTION_DOWN 第二个是MotionEvent.ACTION_UP! 唉~现在网上的帖子真是各种抄袭~就不能测试下？？郁闷！ 既然这两个动作一个是按下一个是抬起那就很明确其意义了，我们可以根据 这两个动作知道用户到底滑动的距离等等了，其距离e2.getX()-e1.getX();</p><p>总结：</p><p>1.触屏后、一直触屏不动、演变顺序：onDown-&gt;onShowPress-&gt;onLongPress；</p><p>2.触屏后、一直触屏慢移动是onScroll/快移动是onFling 、手指离开屏幕；</p><p>注意 ：触屏后、一直触屏移动，如果手指不离开屏幕一直都是onScroll,不管你移动的速度多快,永远不会是onFling！</p><p></p></div>

</DIV></DIV>

<DIV id=footer style="display:none">
<P align="center">  
 
 
 
    </P>
</DIV></BODY></HTML>

