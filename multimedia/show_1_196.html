
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>Android Media架构_Android学习手册</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<META name=GENERATOR content="MSHTML 8.00.6001.18702">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">

</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li ><A href="../component/index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li ><A href="../device/index.html">设备功能</A> </li><li ><A href="../datastorage/index.html">数据存储</A> </li><li ><A href="../network/index.html">网络应用</A> </li><li ><A href="../game/index.html">游戏开发</A> </li><li class="navcurrentLink"><A href="index.html">多媒体</A> </li><li ><A href="../source/index.html">源码开发</A> </li><li ><A href="../advance/index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">课 程 表</div>


  <h2><A title="Android多媒体功能" href="index_196.html">Android多媒体功能</A></h2>
<UL><li class="currentLink"><A title=Android Media架构 href="show_1_196.html">Android Media架构</A> </li><li ><A title=Android 媒体库（一） href="show_2_196.html">Android 媒体库（一）</A> </li><li ><A title=Android 媒体库（二） href="show_3_196.html">Android 媒体库（二）</A> </li><li ><A title=Android 媒体库（三） href="show_4_196.html">Android 媒体库（三）</A> </li><li ><A title=Android 媒体库（四） href="show_5_196.html">Android 媒体库（四）</A> </li><li ><A title=Android 媒体库（五） href="show_6_196.html">Android 媒体库（五）</A> </li><li ><A title=Android 媒体库（六） href="show_7_196.html">Android 媒体库（六）</A> </li><li ><A title=Android 媒体库（七） href="show_8_196.html">Android 媒体库（七）</A> </li><li ><A title=Android 媒体库（八） href="show_9_196.html">Android 媒体库（八）</A> </li><li ><A title=Android OpenMax多媒体引擎（一） href="show_10_196.html">Android OpenMax多媒体引擎（一）</A> </li><li ><A title=Android OpenMax多媒体引擎（二） href="show_11_196.html">Android OpenMax多媒体引擎（二）</A> </li><li ><A title=Android OpenMax多媒体引擎（三） href="show_12_196.html">Android OpenMax多媒体引擎（三）</A> </li><li ><A title=Android 多媒体框架源码全面解析 href="show_13_196.html">Android 多媒体框架源码全面解析</A> </li><li ><A title=Android多媒体模块代码分析 href="show_14_196.html">Android多媒体模块代码分析</A> </li><li ><A title=Android多媒体功能之AudioRecorder音频录制实现，Rexsee源码分享 href="show_15_196.html">Android多媒体功能之AudioRecorder音频录制实现，Rexsee源码分享</A> </li><li ><A title=Android2.X新的多媒体框架Stagefright讨论 href="show_16_196.html">Android2.X新的多媒体框架Stagefright讨论</A> </li><li ><A title=Android Framework下StageFright框架流程解读 href="show_17_196.html">Android Framework下StageFright框架流程解读</A> </li><li ><A title=基于stagefright 的 OMXCodec与OMX事件处理流程 href="show_18_196.html">基于stagefright 的 OMXCodec与OMX事件处理流程</A> </li><li ><A title=Android如何获取多媒体文件信息 href="show_19_196.html">Android如何获取多媒体文件信息</A> </li><li ><A title=通过路径获取媒体文件信息 href="show_20_196.html">通过路径获取媒体文件信息</A> </li></UL>
  <h2><A title="Android多媒体之2D" href="index_197.html">Android多媒体之2D</A></h2>

  <h2><A title="Android多媒体之3D" href="index_198.html">Android多媒体之3D</A></h2>

  <h2><A title="Android多媒体之Bitmap" href="index_199.html">Android多媒体之Bitmap</A></h2>

  <h2><A title="Android多媒体之Canvas" href="index_200.html">Android多媒体之Canvas</A></h2>

  <h2><A title="Android多媒体之Drawable" href="index_201.html">Android多媒体之Drawable</A></h2>

  <h2><A title="Android多媒体之gif" href="index_202.html">Android多媒体之gif</A></h2>

  <h2><A title="Android多媒体之MediaStore" href="index_203.html">Android多媒体之MediaStore</A></h2>

  <h2><A title="Android多媒体之动画" href="index_204.html">Android多媒体之动画</A></h2>

  <h2><A title="Android多媒体之分辨率" href="index_205.html">Android多媒体之分辨率</A></h2>

  <h2><A title="Android多媒体之分屏幕" href="index_206.html">Android多媒体之分屏幕</A></h2>

</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1></H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>Android Media架构</H2>
<div style="line-height:20px; font-size:14px;"><p>整体框架图
<img src="../img/media_media/01_media.jpg">
整个MediaPlayer在运行的时候，可以大致上分成Client和Server两个部分，它们分别在两个进程中运行，它们之间使用Binder机制实现IPC通讯。从框架结构上来看，IMediaPlayerService.h、IMediaPlayerClient.h和MediaPlayer.h三个类定义了MeidaPlayer的接口和架构，MediaPlayerService.cpp和mediaplayer.coo两个文件用于MeidaPlayer架构的实现，MeidaPlayer的具体功能在PVPlayer（库libopencoreplayer.so）中的实现。
IMediaPlayerClient.h用于描述一个MediaPlayer客户端的接口，描述如下所示：
<pre>
<font class="keyword">class </font>IMediaPlayerClient: </font><font class="keyword">public </font>IInterface
{
	</font>public:
	</font>DECLARE_META_INTERFACE(MediaPlayerClient);
	</font>virtual </font><font class="keyword">void </font>notify(</font><font class="keyword">int </font>msg, </font><font class="keyword">int </font>ext1, </font><font class="keyword">int </font>ext2)= 0;

</font>};
</font><font class="keyword">class </font>BnMediaPlayerClient: publicBnInterface&lt;IMediaPlayerClient&gt;
{
	</font>public:
	</font>virtualstatus_t onTransact( uint32_t code,
	</font>const Parcel& data,
	</font>Parcel* reply,
	</font>uint32_t flags = 0);
</font>};
</pre>
在定义中，IMediaPlayerClient类继承IInterface，并定义了一个MediaPlayer客户端的接口，BnMediaPlayerClient继承了BnInterface&lt;IMediaPlayerClient&gt;，这是为基于Android的基础类Binder机制实现在进程通讯而构建的。事实上，根据BnInterface类模版的定义BnInterface&lt;IMediaPlayerClient&gt;类相当于双继承了BnInterface和ImediaPlayerClient。这是Android一种常用的定义方式。
mediaplayer.h是对外的接口类，它最主要是定义了一个MediaPlayer类：
<pre>
</font><font class="keyword">class </font>MediaPlayer : </font><font class="keyword">public </font>BnMediaPlayerClient
{
	</font>public:
	</font>MediaPlayer();
	</font>~MediaPlayer();
	</font><font class="keyword">void </font>onFirstRef();
	</font><font class="keyword">void </font>disconnect();
	</font>status_t setDataSource(const char*url);
	</font>status_t setDataSource(</font><font class="keyword">int </font>fd,int64_t offset, int64_t length);
	</font>status_t setVideoSurface(constsp&lt;Surface&gt;& surface);
	</font>status_t setListener(constsp&lt;MediaPlayerListener&gt;& listener);
	</font>status_t prepare();
	</font>status_t prepareAsync();
	</font>status_t start();
	</font>status_t stop();
	</font>status_t pause();
	</font>bool isPlaying();
	</font>status_t getVideoWidth(</font><font class="keyword">int </font>*w);
	</font>status_t getVideoHeight(</font><font class="keyword">int </font>*h);
	</font>status_t seekTo(</font><font class="keyword">int </font>msec);
	</font>status_t getCurrentPosition(</font><font class="keyword">int </font>*msec);
	</font>status_t getDuration(</font><font class="keyword">int </font>*msec);
	</font>status_t reset();
	</font>status_t setAudioStreamType(inttype);
	</font>status_t setLooping(</font><font class="keyword">int </font>loop);
	</font>status_t setVolume(floatleftVolume, </font><font class="keyword">float </font>rightVolume);
	</font><font class="keyword">void </font>notify(</font><font class="keyword">int </font>msg, </font><font class="keyword">int </font>ext1, intext2);
	</font><font class="keyword">static </font>sp&lt;IMemory&gt; decode(const char* url, uint32_t *pSampleRate, int* pNumChannels);
	</font><font class="keyword">static </font>sp&lt;IMemory&gt; decode(</font><font class="keyword">int </font>fd, int64_t offset, int64_t length, uint32_t *pSampleRate,int* pNumChannels);
</font>}
</pre>
在instantiate函数中，调用IServiceManager的一个函数addService，向其中增加了一个名为"media.player"的服务。
这个名为"media.player"的服务和mediaplayer.cpp中调用getService中得到的使用一样名称。因此，在这里调用addService增加服务在mediaplayer.cpp中可以按照名称"media.player"来使用。这就是使用Binder实现进程间通讯的（IPC）的作用，事实上这个MediaPlayerService类是在服务中运行的，而mediaplayer.cpp调用的功能在应用中运行，二者并不是一个进程。但是在mediaplayer.cpp却像一个进程的调用一样调用MediaPlayerService的功能。
<pre>
</font><font class="keyword">static </font>sp&lt;MediaPlayerBase&gt; createPlayer(player_typeplayerType, void* cookie, notify_callback_f notifyFunc)
{
	</font>sp&lt;MediaPlayerBase&gt; p;
	</font><font class="keyword">switch </font>(playerType) {
		</font><font class="keyword">case </font>PV_PLAYER:
			</font>LOGV(<font class="Fields">" create PVPlayer"</font>);
			</font>p = newPVPlayer();
			</font><font class="keyword">break</font>;
		</font><font class="keyword">case </font>SONIVOX_PLAYER:
			</font>LOGV(</font><font class="Fields">" create MidiFile"</font>);
			</font>p = newMidiFile();
			</font><font class="keyword">break</font>;
		</font><font class="keyword">case </font>VORBIS_PLAYER:
			</font>LOGV(</font><font class="Fields">" create VorbisPlayer"</font>);
			</font>p = newVorbisPlayer();
			</font><font class="keyword">break</font>;
	</font>}
	</font><font class="keyword">return </font>p;
</font>}
</pre>
在这里根据playerType的类型建立不同的播放器：对于大多数情况，类型将是PV_PLAYER，这时会调用了new PVPlayer()建立一个PVPlayer，然后将其指针转换成MediaPlayerBase来使用；对于Mini文件的情况，类型为SONIVOX_PLAYER，将会建立一个MidiFile； 对于Ogg Vorbis格 式的情况，将会建立一个VorbisPlayer。</p><p></p></div>

</DIV></DIV>

<DIV id=footer style="display:none">
<P align="center">  
 
 
 
    </P>
</DIV></BODY></HTML>

