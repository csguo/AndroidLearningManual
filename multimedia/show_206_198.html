
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>Android3D旋转_Android学习手册</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<META name=GENERATOR content="MSHTML 8.00.6001.18702">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">

</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li ><A href="../component/index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li ><A href="../device/index.html">设备功能</A> </li><li ><A href="../datastorage/index.html">数据存储</A> </li><li ><A href="../network/index.html">网络应用</A> </li><li ><A href="../game/index.html">游戏开发</A> </li><li class="navcurrentLink"><A href="index.html">多媒体</A> </li><li ><A href="../source/index.html">源码开发</A> </li><li ><A href="../advance/index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">课 程 表</div>


  <h2><A title="Android多媒体功能" href="index_196.html">Android多媒体功能</A></h2>

  <h2><A title="Android多媒体之2D" href="index_197.html">Android多媒体之2D</A></h2>

  <h2><A title="Android多媒体之3D" href="index_198.html">Android多媒体之3D</A></h2>
<UL><li ><A title=Android 3D绘图基本概念（一） href="show_201_198.html">Android 3D绘图基本概念（一）</A> </li><li ><A title=Android 3D绘图基本概念（二） href="show_202_198.html">Android 3D绘图基本概念（二）</A> </li><li ><A title=Android 3D坐标（一） href="show_203_198.html">Android 3D坐标（一）</A> </li><li ><A title=Android 3D坐标（二） href="show_204_198.html">Android 3D坐标（二）</A> </li><li ><A title=Android中3D效果 href="show_205_198.html">Android中3D效果</A> </li><li class="currentLink"><A title=Android3D旋转 href="show_206_198.html">Android3D旋转</A> </li><li ><A title=Android 3d页面跳转（一） href="show_207_198.html">Android 3d页面跳转（一）</A> </li><li ><A title=Android 3d页面跳转（二） href="show_208_198.html">Android 3d页面跳转（二）</A> </li><li ><A title=Android 3d页面跳转（三） href="show_209_198.html">Android 3d页面跳转（三）</A> </li><li ><A title=ApiDemo上面的一个图片3D旋转效果 href="show_210_198.html">ApiDemo上面的一个图片3D旋转效果</A> </li><li ><A title=浅谈Android 3D旋转 href="show_211_198.html">浅谈Android 3D旋转</A> </li><li ><A title=简单实现3d旋转动画 href="show_212_198.html">简单实现3d旋转动画</A> </li><li ><A title=Android 3D相册 href="show_213_198.html">Android 3D相册</A> </li></UL>
  <h2><A title="Android多媒体之Bitmap" href="index_199.html">Android多媒体之Bitmap</A></h2>

  <h2><A title="Android多媒体之Canvas" href="index_200.html">Android多媒体之Canvas</A></h2>

  <h2><A title="Android多媒体之Drawable" href="index_201.html">Android多媒体之Drawable</A></h2>

  <h2><A title="Android多媒体之gif" href="index_202.html">Android多媒体之gif</A></h2>

  <h2><A title="Android多媒体之MediaStore" href="index_203.html">Android多媒体之MediaStore</A></h2>

  <h2><A title="Android多媒体之动画" href="index_204.html">Android多媒体之动画</A></h2>

  <h2><A title="Android多媒体之分辨率" href="index_205.html">Android多媒体之分辨率</A></h2>

  <h2><A title="Android多媒体之分屏幕" href="index_206.html">Android多媒体之分屏幕</A></h2>

</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1></H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>Android3D旋转</H2>
<div style="line-height:20px; font-size:14px;"><p>此示例展示了一个立方体的具体实现过程，与之前的纯Opengl es实现相比，它采用了JPCT-AE来实现，因为个人认为这个框架很方便，于是从今天开始通过其网站上的Wiki来介绍JPCT-AE的实现。</p><p><pre><font class="keyword">import </font>java.lang.reflect.Field;</p><p><font class="keyword">import </font>javax.microedition.khronos.egl.EGL10;</p><p><font class="keyword">import </font>javax.microedition.khronos.egl.EGLConfig;</p><p><font class="keyword">import </font>javax.microedition.khronos.egl.EGLDisplay;</p><p><font class="keyword">import </font>javax.microedition.khronos.opengles.GL10;</p><p><font class="keyword">import </font>android.app.Activity;</p><p><font class="keyword">import </font>android.opengl.GLSurfaceView;</p><p><font class="keyword">import </font>android.os.Bundle;</p><p><font class="keyword">import </font>android.view.MotionEvent;</p><p><font class="keyword">import </font>com.threed.jpct.Camera;</p><p><font class="keyword">import </font>com.threed.jpct.FrameBuffer;</p><p><font class="keyword">import </font>com.threed.jpct.Light;</p><p><font class="keyword">import </font>com.threed.jpct.Logger;</p><p><font class="keyword">import </font>com.threed.jpct.Object3D;</p><p><font class="keyword">import </font>com.threed.jpct.Primitives;</p><p><font class="keyword">import </font>com.threed.jpct.RGBColor;</p><p><font class="keyword">import </font>com.threed.jpct.SimpleVector;</p><p><font class="keyword">import </font>com.threed.jpct.Texture;</p><p><font class="keyword">import </font>com.threed.jpct.TextureManager;</p><p><font class="keyword">import </font>com.threed.jpct.World;</p><p><font class="keyword">import </font>com.threed.jpct.util.BitmapHelper;</p><p><font class="keyword">import </font>com.threed.jpct.util.MemoryHelper;</p><p></p><p><font class="Comments">/**</font></p><p> <font class="Comments">* 一个简单的例子。比起展示如何写一个正确的android应用它更着重于展示如何使用JPCT-AE这个3D游戏框架。</font></p><p> <font class="Comments">* 它包含了Activity类去处理pause和resume等方法</font></p><p> <font class="Comments">*/</font></p><p></p><p><font class="keyword">public </font><font class="keyword">class </font>HelloWorld </font><font class="keyword">extends </font>Activity {</p><p>	<font class="Comments">// HelloWorld对象用来处理Activity的onPause和onResume方法</font></p><p>	<font class="keyword">private </font><font class="keyword">static </font>HelloWorld master = </font><font class="keyword">null</font>;</p><p>	<font class="Comments">// GLSurfaceView对象</font></p><p>	<font class="keyword">private </font>GLSurfaceView mGLView;</p><p>	<font class="Comments">// 类MyRenderer对象</font></p><p>	<font class="keyword">private </font>MyRenderer renderer = </font><font class="keyword">null</font>;</p><p>	<font class="Comments">// 当JPCT渲染背景时FrameBuffer类提供了一个缓冲,它的结果本质上是一个能显示或者修改甚至能进行更多后处理的图片。</font></p><p>	<font class="keyword">private </font>FrameBuffer fb = </font><font class="keyword">null</font>;</p><p>	<font class="Comments">// World类是JPCT时最重要的一个类，它好像胶水一样把事物"粘"起来。它包含的对象和光线定义了JPCT的场景</font></p><p>	<font class="keyword">private </font>World world = </font><font class="keyword">null</font>;</p><p>	<font class="Comments">// 类似java.awt.*中的Color类</font></p><p>	<font class="keyword">private </font>RGBColor back = </font><font class="keyword">new </font>RGBColor(50, 50, 100);</p><p>	<font class="keyword">private </font><font class="keyword">float </font>touchTurn = 0;</p><p>	<font class="keyword">private </font><font class="keyword">float </font>touchTurnUp = 0;</p><p>	<font class="keyword">private </font><font class="keyword">float </font>xpos = -1;</p><p>	<font class="keyword">private </font><font class="keyword">float </font>ypos = -1;</p><p>	<font class="Comments">// Object3D类是一个三维对象,千万不要傻呼呼的认为它与java.lang.Object类似。</font></p><p>	<font class="Comments">// 一个Object3D对象作为一个实例被添加到在渲染的World对象中。Object3D在World</font></p><p>	<font class="Comments">// 中一次添加一个实例 ，他们可能被联系起作为孩子/父母来在他们中建立一个制度.</font></p><p>	<font class="Comments">// 人体模型当然也能应用在以上的规则中。他们常常不加到一个World实例中，而是</font></p><p>	<font class="Comments">// 绑定到其它对象中(人体模型或非人体模型)。有些方法 在这个类中需要一个实例</font></p><p>	<font class="Comments">// 添加到一个World实例中(用World.addObject()方法可以实现)。</font></p><p>	<font class="keyword">private </font>Object3D cube = </font><font class="keyword">null</font>;</p><p>	<font class="Comments">// 每秒帧数</font></p><p>	<font class="keyword">private </font><font class="keyword">int </font>fps = 0;</p><p>	<font class="Comments">// 光照类</font></p><p>	<font class="keyword">private </font>Light sun = </font><font class="keyword">null</font>;</p><p>	<font class="keyword">protected </font><font class="keyword">void </font>onCreate(Bundle savedInstanceState) {</p><p>		<font class="Comments">// Logger类中 jPCT中一个普通的用于打印和存储消息，错误和警告的日志类。</font></p><p>		<font class="Comments">// 每一个JPCT生成的消息将被加入到这个类的队列中</font></p><p>		</font>Logger.log(<font class="Fields">"onCreate"</font>);</p><p>		<font class="Comments">// 如果本类对象不为NULL,将从Object中所有属性装入该类</font></p><p>		<font class="keyword">if </font>(master != </font><font class="keyword">null</font>) {</p><p>			copy(master);</p><p>		}</p><p>		<font class="keyword">super</font>.onCreate(savedInstanceState);</p><p>		<font class="Comments">// 实例化GLSurfaceView</font></p><p>		</font>mGLView = <font class="keyword">new </font>GLSurfaceView(</font><font class="keyword">this</font>);</p><p>		<font class="Comments">// 使用自己实现的 EGLConfigChooser,该实现必须在setRenderer(renderer)之前</font></p><p>		<font class="Comments">// 如果没有setEGLConfigChooser方法被调用，则默认情况下，视图将选择一个与当前android.view.Surface兼容至少16位深度缓冲深度EGLConfig。</font></p><p>		</font>mGLView.setEGLConfigChooser(<font class="keyword">new </font>GLSurfaceView.EGLConfigChooser() {</p><p>			<font class="keyword">public </font>EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {</p><p>				<font class="Comments">// Ensure that we get a 16bit framebuffer. Otherwise, we'll fall</font></p><p>				<font class="Comments">// back to Pixelflinger on some device (read: Samsung I7500)</font></p><p>				<font class="keyword">int</font>[] attributes = </font><font class="keyword">new </font><font class="keyword">int</font>[] { EGL10.EGL_DEPTH_SIZE, 16,</p><p>				EGL10.EGL_NONE };</p><p>				</font>EGLConfig[] configs = <font class="keyword">new </font>EGLConfig[1];</p><p>				<font class="keyword">int</font>[] result = </font><font class="keyword">new </font><font class="keyword">int</font>[1];</p><p>				egl.eglChooseConfig(display, attributes, configs, 1, result);</p><p>				<font class="keyword">return </font>configs[0];</p><p>			}</p><p>		});</p><p>		<font class="Comments">// 实例化MyRenderer</font></p><p>		</font>renderer = <font class="keyword">new </font>MyRenderer();</p><p>		<font class="Comments">// 设置View的渲染器，同时启动线程调用渲染，以至启动渲染</font></p><p>		mGLView.setRenderer(renderer);</p><p>		<font class="Comments">// 设置一个明确的视图</font></p><p>		setContentView(mGLView);</p><p>	}</p><p>	<font class="Comments">// 重写onPause()</font></p><p>	@Override</p><p>	<font class="keyword">protected </font><font class="keyword">void </font>onPause() {</p><p>		<font class="keyword">super</font>.onPause();</p><p>		mGLView.onPause();</p><p>	}</p><p>	<font class="Comments">// 重写onResume()</font></p><p>	@Override</p><p>	<font class="keyword">protected </font><font class="keyword">void </font>onResume() {</p><p>		<font class="keyword">super</font>.onResume();</p><p>		mGLView.onResume();</p><p>	}</p><p>	<font class="Comments">// 重写onStop()</font></p><p>	@Override</p><p>	<font class="keyword">protected </font><font class="keyword">void </font>onStop() {</p><p>		<font class="keyword">super</font>.onStop();</p><p>	}</p><p>	<font class="keyword">private </font><font class="keyword">void </font>copy(Object src) {</p><p>		<font class="keyword">try </font>{</p><p>			<font class="Comments">// 打印日志</font></p><p>			</font>Logger.log(<font class="Fields">"Copying data from master Activity!"</font>);</p><p>			<font class="Comments">// 返回一个数组，其中包含目前这个类的的所有字段的Filed对象</font></p><p>			Field[] fs = src.getClass().getDeclaredFields();</p><p>			<font class="Comments">// 遍历fs数组</font></p><p>			<font class="keyword">for </font>(Field f : fs) {</p><p>				<font class="Comments">// 尝试设置无障碍标志的值。标志设置为false将使访问检查，设置为true，将其禁用。</font></p><p>				</font>f.setAccessible(<font class="keyword">true</font>);</p><p>				<font class="Comments">// 将取到的值全部装入当前类中</font></p><p>				</font>f.set(<font class="keyword">this</font>, f.get(src));</p><p>			}</p><p>		</font>} <font class="keyword">catch </font>(Exception e) {</p><p>			<font class="Comments">// 抛出运行时异常</font></p><p>			<font class="keyword">throw </font><font class="keyword">new </font>RuntimeException(e);</p><p>		}</p><p>	}</p><p>	<font class="keyword">public </font><font class="keyword">boolean </font>onTouchEvent(MotionEvent me) {</p><p>		<font class="Comments">// 按键开始</font></p><p>		<font class="keyword">if </font>(me.getAction() == MotionEvent.ACTION_DOWN) {</p><p>			<font class="Comments">// 保存按下的初始x,y位置于xpos,ypos中</font></p><p>			xpos = me.getX();</p><p>			ypos = me.getY();</p><p>			<font class="keyword">return </font><font class="keyword">true</font>;</p><p>		}</p><p>		<font class="Comments">// 按键结束</font></p><p>		<font class="keyword">if </font>(me.getAction() == MotionEvent.ACTION_UP) {</p><p>			<font class="Comments">// 设置x,y及旋转角度为初始值</font></p><p>			xpos = -1;</p><p>			ypos = -1;</p><p>			touchTurn = 0;</p><p>			touchTurnUp = 0;</p><p>			<font class="keyword">return </font><font class="keyword">true</font>;</p><p>		}</p><p>		<font class="keyword">if </font>(me.getAction() == MotionEvent.ACTION_MOVE) {</p><p>			<font class="Comments">// 计算x,y偏移位置及x,y轴上的旋转角度</font></p><p>			<font class="keyword">float </font>xd = me.getX() - xpos;</p><p>			<font class="keyword">float </font>yd = me.getY() - ypos;</p><p>			<font class="Comments">// Logger.log("me.getX() - xpos-----------&gt;&gt;"</font></p><p>			<font class="Comments">// + (me.getX() - xpos));</font></p><p>			xpos = me.getX();</p><p>			ypos = me.getY();</p><p>			</font>Logger.log(<font class="Fields">"xpos------------&gt;&gt;"</font> + xpos);</p><p>			<font class="Comments">// Logger.log("ypos------------&gt;&gt;" + ypos);</font></p><p>			<font class="Comments">// 以x轴为例，鼠标从左向右拉为正，从右向左拉为负</font></p><p>			touchTurn = xd / -100f;</p><p>			touchTurnUp = yd / -100f;</p><p>			</font>Logger.log(<font class="Fields">"touchTurn------------&gt;&gt;"</font> + touchTurn);</p><p>			<font class="Comments">// Logger.log("touchTurnUp------------&gt;&gt;" + touchTurnUp);</font></p><p>			<font class="keyword">return </font><font class="keyword">true</font>;</p><p>		}</p><p>		<font class="Comments">// 每Move一下休眠毫秒</font></p><p>		<font class="keyword">try </font>{</p><p>			Thread.sleep(15);</p><p>		</font>} <font class="keyword">catch </font>(Exception e) {</p><p>			<font class="Comments">// No need for this...</font></p><p>		}</p><p>		<font class="keyword">return </font><font class="keyword">super</font>.onTouchEvent(me);</p><p>	}</p><p>	<font class="Comments">// MyRenderer类实现GLSurfaceView.Renderer接口</font></p><p>	<font class="keyword">class </font>MyRenderer </font><font class="keyword">implements </font>GLSurfaceView.Renderer {</p><p>		<font class="Comments">// 当前系统的毫秒数</font></p><p>		<font class="keyword">private </font><font class="keyword">long </font>time = System.currentTimeMillis();</p><p>		<font class="Comments">// 是否停止</font></p><p>		<font class="keyword">private </font><font class="keyword">boolean </font>stop = </font><font class="keyword">false</font>;</p><p>		<font class="Comments">// 停止</font></p><p>		<font class="keyword">public </font><font class="keyword">void </font>stop() {</p><p>			</font>stop = <font class="keyword">true</font>;</p><p>		}</p><p>		<font class="Comments">// 当屏幕改变时</font></p><p>		<font class="keyword">public </font><font class="keyword">void </font>onSurfaceChanged(GL10 gl, </font><font class="keyword">int </font>w, </font><font class="keyword">int </font>h) {</p><p>			<font class="Comments">// 如果FrameBuffer不为NULL,释放fb所占资源</font></p><p>			<font class="keyword">if </font>(fb != </font><font class="keyword">null</font>) {</p><p>				fb.dispose();</p><p>			}</p><p>			<font class="Comments">// 创建一个宽度为w,高为h的FrameBuffer</font></p><p>			</font>fb = <font class="keyword">new </font>FrameBuffer(gl, w, h);</p><p>			</font>Logger.log(master + <font class="Fields">""</font>);</p><p>			<font class="Comments">// 如果master为空</font></p><p>			<font class="keyword">if </font>(master == </font><font class="keyword">null</font>) {</p><p>				<font class="Comments">// 实例化World对象</font></p><p>				</font>world = <font class="keyword">new </font>World();</p><p>				<font class="Comments">// 设置了环境光源强度。设置此值是负的整个场景会变暗，而为正将照亮了一切。</font></p><p>				world.setAmbientLight(20, 20, 20);</p><p>				<font class="Comments">// 在World中创建一个新的光源</font></p><p>				</font>sun = <font class="keyword">new </font>Light(world);</p><p>				<font class="Comments">// 设置光照强度</font></p><p>				sun.setIntensity(250, 250, 250);</p><p>				<font class="Comments">// 创建一个纹理</font></p><p>				<font class="Comments">// 构造方法Texture(Bitmap image)</font></p><p>				<font class="Comments">// static Bitmap rescale(Bitmap bitmap, int width, int height)</font></p><p>				<font class="Comments">// static Bitmap convert(Drawable drawable)</font></p><p>				</font>Texture texture = <font class="keyword">new </font>Texture(BitmapHelper.rescale(</p><p>				BitmapHelper.convert(getResources().getDrawable(</p><p>				R.drawable.glass)), 64, 64));</p><p>				<font class="Comments">// TextureManager.getInstance()取得一个Texturemanager对象</font></p><p>				<font class="Comments">// addTexture("texture",texture)添加一个纹理</font></p><p>				</font>TextureManager.getInstance().addTexture(<font class="Fields">"texture"</font>, texture);</p><p>				<font class="Comments">// Object3D对象开始了:-)</font></p><p>				<font class="Comments">// Primitives提供了一些基本的三维物体，假如你为了测试而生成一些对象或为</font></p><p>				<font class="Comments">// 其它目的使用这些类将很明智，因为它即快速又简单，不需要载入和编辑。</font></p><p>				<font class="Comments">// 调用public static Object3D getCube(float scale) scale:角度</font></p><p>				<font class="Comments">// 返回一个立方体</font></p><p>				cube = Primitives.getCube(10);</p><p>				<font class="Comments">// 以纹理的方式给对象所有面"包装"上纹理</font></p><p>				cube.calcTextureWrapSpherical();</p><p>				<font class="Comments">// 给对象设置纹理</font></p><p>				</font>cube.setTexture(<font class="Fields">"texture"</font>);</p><p>				<font class="Comments">// 除非你想在事后再用PolygonManager修改,否则释放那些不再需要数据的内存</font></p><p>				cube.strip();</p><p>				<font class="Comments">// 初始化一些基本的对象是几乎所有进一步处理所需的过程。</font></p><p>				<font class="Comments">// 如果对象是"准备渲染"(装载，纹理分配，安置，渲染模式设置，</font></p><p>				<font class="Comments">// 动画和顶点控制器分配),那么build()必须被调用，</font></p><p>				cube.build();</p><p>				<font class="Comments">// 将Object3D对象添加到world集合</font></p><p>				world.addObject(cube);</p><p>				<font class="Comments">// 该Camera代表了Camera/viewer在当前场景的位置和方向，它也包含了当前视野的有关信息</font></p><p>				<font class="Comments">// 你应该记住Camera的旋转矩阵实际上是应用在World中的对象的一个旋转矩阵。</font></p><p>				<font class="Comments">// 这一点很重要，当选择了Camera的旋转角度，一个Camera(虚拟)围绕w旋转和通过围绕World围绕w旋转、</font></p><p>				<font class="Comments">// 将起到相同的效果，因此，考虑到旋转角度，World围绕camera时，camera的视角是静态的。假如你不喜欢</font></p><p>				<font class="Comments">// 这种习惯，你可以使用rotateCamera()方法</font></p><p>				Camera cam = world.getCamera();</p><p>				<font class="Comments">// 以50有速度向后移动Camera（相对于目前的方向）</font></p><p>				cam.moveCamera(Camera.CAMERA_MOVEOUT, 50);</p><p>				<font class="Comments">// cub.getTransformedCenter()返回对象的中心</font></p><p>				<font class="Comments">// cam.lookAt(SimpleVector lookAt))</font></p><p>				<font class="Comments">// 旋转这样camera以至于它看起来是在给定的world-space 的位置</font></p><p>				cam.lookAt(cube.getTransformedCenter());</p><p>				<font class="Comments">// SimpleVector是一个代表三维矢量的基础类，几乎每一个矢量都</font></p><p>				<font class="Comments">// 是用SimpleVector或者至少是一个SimpleVector变体构成的(有时由于</font></p><p>				<font class="Comments">// 某些原因比如性能可能会用(float x,float y,float z)之类)。</font></p><p>				</font>SimpleVector sv = <font class="keyword">new </font>SimpleVector();</p><p>				<font class="Comments">// 将当前SimpleVector的x,y,z值设为给定的SimpleVector(cube.getTransformedCenter())的值</font></p><p>				sv.set(cube.getTransformedCenter());</p><p>				<font class="Comments">// Y方向上减去100</font></p><p>				sv.y -= 100;</p><p>				<font class="Comments">// Z方向上减去100</font></p><p>				sv.z -= 100;</p><p>				<font class="Comments">// 设置光源位置</font></p><p>				sun.setPosition(sv);</p><p>				<font class="Comments">// 强制GC和finalization工作来试图去释放一些内存，同时将当时的内存写入日志，</font></p><p>				<font class="Comments">// 这样可以避免动画不连贯的情况，然而，它仅仅是减少这种情况发生的机率</font></p><p>				MemoryHelper.compact();</p><p>				<font class="Comments">// 如果master为空,使用日志记录且设master为HelloWorld本身</font></p><p>				<font class="keyword">if </font>(master == </font><font class="keyword">null</font>) {</p><p>					</font>Logger.log(<font class="Fields">"Saving master Activity!"</font>);</p><p>					</font>master = HelloWorld.<font class="keyword">this</font>;</p><p>				}</p><p>			}</p><p>		}</p><p>		<font class="Comments">// 需实现的onSurfaceCreated(GL10 gl, EGLConfig config)</font></p><p>		<font class="keyword">public </font><font class="keyword">void </font>onSurfaceCreated(GL10 gl, EGLConfig config) {</p><p>		}</p><p>		<font class="Comments">// 绘制到当前屏幕哦:-D</font></p><p>		<font class="keyword">public </font><font class="keyword">void </font>onDrawFrame(GL10 gl) {</p><p>			<font class="keyword">try </font>{</p><p>				<font class="Comments">// 如果stop为true</font></p><p>				<font class="keyword">if </font>(!stop) {</p><p>					<font class="Comments">// 如果touchTurn不为0,向Y轴旋转touchTure角度</font></p><p>					<font class="keyword">if </font>(touchTurn != 0) {</p><p>						<font class="Comments">// 旋转物体的旋转绕Y由给定矩阵W轴角（弧度顺时针方向为正值）,应用到对象下一次渲染时。</font></p><p>						cube.rotateY(touchTurn);</p><p>						<font class="Comments">// 将touchTurn置0</font></p><p>						touchTurn = 0;</p><p>					}</p><p>					<font class="keyword">if </font>(touchTurnUp != 0) {</p><p>						<font class="Comments">// 旋转物体的旋转围绕x由给定角度宽（弧度，逆时针为正值）轴矩阵,应用到对象下一次渲染时。</font></p><p>						cube.rotateX(touchTurnUp);</p><p>						<font class="Comments">// 将touchTureUp置0</font></p><p>						touchTurnUp = 0;</p><p>					}</p><p>					<font class="Comments">// 用给定的颜色(back)清除FrameBuffer</font></p><p>					fb.clear(back);</p><p>					<font class="Comments">// 变换和灯光所有多边形</font></p><p>					world.renderScene(fb);</p><p>					<font class="Comments">// 绘制</font></p><p>					world.draw(fb);</p><p>					<font class="Comments">// 渲染图像显示</font></p><p>					fb.display();</p><p>					<font class="Comments">// 记录FPS</font></p><p>					<font class="keyword">if </font>(System.currentTimeMillis() - time &gt;= 1000) {</p><p>						<font class="Comments">// Logger.log(fps + "fps");</font></p><p>						fps = 0;</p><p>						time = System.currentTimeMillis();</p><p>					}</p><p>					fps++;</p><p>					<font class="Comments">// 如果stop为false,释放FrameBuffer</font></p><p>				</font>} <font class="keyword">else </font>{</p><p>					<font class="keyword">if </font>(fb != </font><font class="keyword">null</font>) {</p><p>						fb.dispose();</p><p>						</font>fb = <font class="keyword">null</font>;</p><p>					}</p><p>				}</p><p>				<font class="Comments">// 当出现异常，打印异常信息</font></p><p>			</font>} <font class="keyword">catch </font>(Exception e) {</p><p>				Logger.log(e, Logger.MESSAGE);</p><p>			}</p><p>		}</p><p>	}</p><p>}</p><p></pre></p><p></p></div>

</DIV></DIV>

<DIV id=footer style="display:none">
<P align="center">  
 
 
 
    </P>
</DIV></BODY></HTML>

