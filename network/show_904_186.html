
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>Android webservice通信之ksoap_Android学习手册</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<META name=GENERATOR content="MSHTML 8.00.6001.18702">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">

</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li ><A href="../component/index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li ><A href="../device/index.html">设备功能</A> </li><li ><A href="../datastorage/index.html">数据存储</A> </li><li class="navcurrentLink"><A href="index.html">网络应用</A> </li><li ><A href="../game/index.html">游戏开发</A> </li><li ><A href="../multimedia/index.html">多媒体</A> </li><li ><A href="../source/index.html">源码开发</A> </li><li ><A href="../advance/index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">课 程 表</div>


  <h2><A title="3G" href="index_177.html">3G</A></h2>

  <h2><A title="WIFI" href="index_178.html">WIFI</A></h2>

  <h2><A title="蓝牙" href="index_179.html">蓝牙</A></h2>

  <h2><A title="HTTP协议" href="index_180.html">HTTP协议</A></h2>

  <h2><A title="Socket" href="index_181.html">Socket</A></h2>

  <h2><A title="HTML与HTML5" href="index_182.html">HTML与HTML5</A></h2>

  <h2><A title="JavaScript" href="index_183.html">JavaScript</A></h2>

  <h2><A title="Email" href="index_184.html">Email</A></h2>

  <h2><A title="NFC" href="index_185.html">NFC</A></h2>

  <h2><A title="Web Service" href="index_186.html">Web Service</A></h2>
<UL><li ><A title=Android说说WebService href="show_901_186.html">Android说说WebService</A> </li><li ><A title=Android webservice 理论 href="show_902_186.html">Android webservice 理论</A> </li><li ><A title=Android中调用webservice href="show_903_186.html">Android中调用webservice</A> </li><li class="currentLink"><A title=Android webservice通信之ksoap href="show_904_186.html">Android webservice通信之ksoap</A> </li><li ><A title=Android+webservice的连接 href="show_905_186.html">Android+webservice的连接</A> </li><li ><A title=调用webservice查询手机号归属地信息 href="show_906_186.html">调用webservice查询手机号归属地信息</A> </li><li ><A title=自己真实开发的中调用webservice方法总结（带请求头SoapHeader） href="show_907_186.html">自己真实开发的中调用webservice方法总结（带请求头SoapHeader）</A> </li></UL>
</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1></H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>Android webservice通信之ksoap</H2>
<div style="line-height:20px; font-size:14px;"><p>kSOAP的运用 文档版见附件</p><p style="color:#3333FF;">1．概述</p><p>对于Android访问远端的web Service，除了官方标准JSR 172，我们还有两种选择： </p><p><pre>kSOAP </p><p>Wingfoot </p><p></pre></p><p>Wingfoot是由Wingfoot Software(www.wingfoot.com)出品的一款J2ME(CLDC/CDC) SOAP1.1的轻量级实现方案。 </p><p>kSOAP是Enhydra.org的一个开源作品，是EnhydraME项目的一部分。基于Enhydra.org出品的开源通用XML解析器kXML，kSOAP完成了J2ME/MIDP平台上的SOAP解析和调用工作。 </p><p>Stefan Haustein领导的kSOAP开发小组于2001年5月17日推出了Alhpa版本。之后又经过了一年的开发，2002年6月6日推出的kSOAP 1.2支持了SOAP1.2规范。2003年8月25日推出的kSOAP2，对SOAP序列化规范支持得更好了。 </p><p>大多数人选择kSOAP的原因是，kSOAP虽然在2003年8月之后就不再维护了，但它是Open Source的，很容易加入增强特性，比如说默认情况下kSOAP2仅仅支持cmnet接入点，可以修改kSOAP2的HttpTransport.Java代码增加对cmwap接入点的支持。 </p><p>下载提示： </p><p>kSOAP当前有两个版本：1.2和2.0。 </p><p>官方网站：http://ksoap.objectweb.org/ </p><p>kSOAP2.0还有一个优点是，改进了对Microsoft dotNET的兼容。以前有很多人抱怨kSOAP调用dotNET编写的Web Service时遇到了不少的困扰。 </p><p>本章节我们将使用kSOAP 2.0的例子来讲解。 </p><p>为了使用kSOAP 2.0，必须还要下载工具包kXML2。 </p><p>下载提示： </p><p>kXML当前有两个版本：1.21和2.0。 </p><p>官方网站：http://kxml.objectweb.org/ </p><p>kXML2比kXML更小更快。 </p><p style="color:#3333FF;">2．kSOAP2接口</p><p>让我们先熟悉一下即将用到的kSOAP2的常用接口。 </p><p>接口 </p><p><pre>org.ksoap2.SoapEnvelope </p><p>org.ksoap2.SoapSerializationEnvelope </p><p>org.ksoap2.SoapObject </p><p>org.ksoap2.transport.HttpTransport </p><p></pre></p><p>SoapEnvelope对应于SOAP规范中的SOAP Envelope，封装了head和body对象。 </p><p>SoapSerializationEnvelope 是kSOAP2新增加的类，是对SoapEnvelope的扩展，对SOAP序列化(Serialization)格式规范提供了支持，能够对简单对象自 动进行序列化(simple object serialization)。而kSOAP1.x则是通过org.ksoap.ClassMap来做序列化的，不太好操作，也不利于扩展。 </p><p>SoapObject让你自如地构造SOAP调用； </p><p>HttpTransport为你屏蔽了Internet访问/请求和获取服务器SOAP的细节。 </p><p>下面我们通过一个最简单的webservice调用，来看看kSOAP是如何做到SOAP解析的： </p><p style="color:#3333FF;">2.1．kSOAP和Web Service之间传递String</p><p>webservice传递String给MIDP是一件很简单的事情。首先在服务器端，不管你是用Microsft ASP.NET创建webservice，还是由tomcat+AXIS1.2支撑的webservice，都可以这么编写主服务类： </p><p>服务器端 </p><p><pre><font class="keyword">public </font><font class="keyword">class </font>SimpleKSoapWS {</p><p>	<font class="keyword">public </font>SimpleKSoapWS() {</p><p>	}</p><p></p><p>	<font class="keyword">public </font>String foo(String username, String password) {</p><p>		<font class="keyword">return </font><font class="Fields">"fooResult"</font>;</p><p>	}</p><p>}</p><p></pre></p><p>kSOAP是如何调用这个webservice的呢？ </p><p>首先要使用SoapObject，这是一个高度抽象化的类，完成SOAP调用。可以调用它的addProperty方法填写要调用的webservice方法的参数。如下面代码所示： </p><p><pre>SoapObject request  = <font class="keyword">new </font>SoapObject(serviceNamespace, methodName); </p><p></pre></p><p>SoapObject构造函数的两个参数含义为： </p><p>serviceNamespace C 你的webservice的命名空间，既可以是 </p><p>http://localhost:8088/flickrBuddy/services/Buddycast这样的，也可以是 </p><p>urn:PI/DevCentral/SoapService这样的； </p><p>methodName C 你要调用方法的名字。 </p><p>然后，按照webservice方法参数的顺序，依次调用 </p><p><pre>request.addProperty( <font class="Fields">"username"</font>, </font><font class="Fields">"user"</font> ); </p><p>request.addProperty( <font class="Fields">"password"</font>, </font><font class="Fields">"pass"</font> ); </p><p></pre></p><p>来填充webservice参数。 </p><p>注意： </p><p>建议webservice的方法传递的参数尽量用string类型。即使是int类型，kSOAP2与Java编写的webservice也有可能交互发生异常。 </p><p>对于webservice方法返回String类型的情况，还用不着开发者做序列化(Serialization)定制工作。 </p><p>要点： </p><p>kSOAP 1.X/2.0可以自动把四种SOAP类型映射为Java类型 </p><p><pre>SOAP type Java type </p><p>xsd:<font class="keyword">int </font>java.lang.Integer </p><p>xsd:<font class="keyword">long </font>java.lang.Long </p><p>xsd:string java.lang.String </p><p>xsd:<font class="keyword">boolean </font>java.lang.Boolean </p><p></pre></p><p>除此之外，都需要开发者自己做类型映射。 </p><p>然后要告诉SoapSerializationEnvelope把构造好的SoapObject封装进去： </p><p><pre>SoapSerializationEnvelope envelope = <font class="keyword">new </font>SoapSerializationEnvelope(SoapEnvelope.VER11); </p><p>envelope.bodyOut = request; </p><p></pre></p><p>要点： </p><p>你可以通过SoapSerializationEnvelope或者SoapEnvelope的构造函数来指明你要用SOAP的哪一个规范，可以是以下几种之一： </p><p><pre>常量SoapEnvelope.VER10：对应于SOAP 1.0规范 </p><p>常量SoapEnvelope.VER11：对应于SOAP 1.1规范 </p><p>常量SoapEnvelope.VER12：对应于SOAP 1.2规范 </p><p></pre></p><p>这样，无论要调用的webservice采用了哪一个SOAP规范，你都可以轻松应对。 </p><p>接下来就要声明 </p><p><pre>HttpTransport tx = <font class="keyword">new </font>HttpTransport(serviceURL); </p><p>ht.debug = <font class="keyword">true</font>; </p><p></pre></p><p>HttpTransport构造函数的参数含义为： </p><p>serviceURL C 要投递SOAP数据的目标地址，譬如说 </p><p>http://soap.amazon.com/onca/soap3 。 </p><p>HttpTransport是一个强大的辅助类，来完成Http-call transport process，它封装了网络请求的一切，你完全不用考虑序列化消息。我们通过设置它的debug属性为true来打开调试信息。 </p><p>方法HttpTransport.call()自己就能够发送请求给服务器、接收服务器响应并序列化SOAP消息，如下所示： </p><p><pre>ht.call(null, envelope); </p><p></pre></p><p>HttpTransport的call方法的两个参数含义为： </p><p>soapAction C SOAP 规范定义了一个名为 SOAPAction 的新 HTTP 标头，所有 SOAP HTTP 请求（即使是空的）都必须包含该标头。 SOAPAction 标头旨在表明该消息的意图。通常可以置此参数为null，这样HttpTransport就会设置HTTP标头SOAPAction为空字符串。 </p><p>Envelope C 就是前面我们构造好的SoapSerializationEnvelope或SoapEnvelope对象。 </p><p>注意： </p><p>对于HttpTransport的处理上，kSOAP2和kSOAP1.2的写法不一样。 </p><p>对于kSOAP 1.2，HttpTransport的构造函数是HttpTransport (String url, String soapAction)，第二个参数soapAction可以是要调用的webservice方法名。 </p><p>而kSOAP 2，构造函数是 HttpTransport(String url)。kSOAP2相当于把webservice方法名分离出去，完全交给SoapObject去封装，而HttpTransport仅仅负责把 SoapEnvelope发送出去并接收响应，这样更合理一些。 </p><p>调用call方法是一个同步过程，需要等待它返回。 </p><p>返回之后，就可以调用SoapSerializationEnvelope的getResult方法来获取结果了：</p><p><pre> </p><p>Object Response = envelope.getResult(); </p><p></pre></p><p>如果HttpTransport的debug属性为true，那么此时就可以通过 </p><p>System.out.println("Response dump&gt;&gt;" + tx.responseDump); </p><p>打印出HttpTransport的调试信息。尤其当前面call方法和getResult方法发生异常时，这个调试信息是非常有用的。 </p><p>前面我们的webservice方法由于是返回string，所以得到这个string值就非常简单了： </p><p><pre>String sResponse = (String)Response; </p><p></pre></p><p>注意： </p><p>由于HttpTransport类实际上是调用了HttpConnection作网络连接，所以必须另起一个线程来专门做kSOAP工作，否则会堵塞操作。 </p><p>综上所述，J2ME客户端的MIDlet按键事件函数这么写即可： </p><p>MIDlet codes </p><p><pre><font class="keyword">import </font>org.ksoap2.serialization.SoapObject;</p><p><font class="keyword">import </font>org.ksoap2.serialization.SoapSerializationEnvelope;</p><p><font class="keyword">import </font>org.ksoap2.transport.HttpTransport;</p><p><font class="keyword">public </font><font class="keyword">class </font>Snippet {</p><p>	<font class="keyword">public </font><font class="keyword">void </font>commandAction(Command c, Displayable s) {</p><p>		<font class="keyword">if </font>(c == exitCommand) {</p><p>			</font>destroyApp(<font class="keyword">false</font>);</p><p>			notifyDestroyed();</p><p>		}</p><p>		<font class="keyword">if </font>(c == connectCommand) {</p><p>			<font class="Comments">// 匿名内部Thread，调用kSOAP2访问远程服务。</font></p><p>			</font>Thread webserviceThread = <font class="keyword">new </font>Thread() {</p><p>				<font class="keyword">public </font><font class="keyword">void </font>run() {</p><p>					<font class="keyword">try </font>{</p><p>						</font>String serviceNamespace = <font class="Fields">"http:<font class="Comments">//localhost:8080/SimpleWS/services/SimpleKSoapWS"</font>;</font></p><p>						</font>String methodName = <font class="Fields">"foo"</font>;</p><p>						</font>String serviceURL = <font class="Fields">"http:<font class="Comments">//localhost:8080/SimpleWS/services/SimpleKSoapWS"</font>;</font></p><p>						</font>SoapObject request = <font class="keyword">new </font>SoapObject(serviceNamespace,</p><p>								methodName);</p><p>						</font>request.addProperty(<font class="Fields">"username"</font>, </font><font class="Fields">"user"</font>);</p><p>						</font>request.addProperty(<font class="Fields">"password"</font>, </font><font class="Fields">"pass"</font>);</p><p>						</font>SoapSerializationEnvelope envelope = <font class="keyword">new </font>SoapSerializationEnvelope(</p><p>								SoapEnvelope.VER11);</p><p>						envelope.bodyOut = request;</p><p>						</font>HttpTransport tx = <font class="keyword">new </font>HttpTransport(serviceURL);</p><p>						</font>ht.debug = <font class="keyword">true</font>;</p><p>						</font>ht.call(<font class="keyword">null</font>, envelope);</p><p>						Object Response = envelope.getResult();</p><p>						/*</p><p>						 <font class="Comments">* 必要时打印出tx.responseDump来观察soap是否正确工作</font></p><p>						 <font class="Comments">*/</font></p><p>						</font>System.<font class="Fields">out</font>.println(</font><font class="Fields">"dump&gt;&gt;"</font> + tx.responseDump);</p><p>						String sResponse = (String) Response;</p><p>					</font>} <font class="keyword">catch </font>(Exception e) {</p><p>						e.printStackTrace();</p><p>					}</p><p>				}</p><p>			};</p><p>			webserviceThread.start();</p><p>		}</p><p>	}</p><p>}</p><p></pre></p><p style="color:#3333FF;">2.2．webservice返回复杂描述的情况</p><p>kSOAP2处理webservice简单的string类型返回值是很容易的。那么如何处理像亚马逊网上书店这种webservice返回的复杂描述呢？ </p><p>kSOAP2自带了一个例子来说明，下面我们就讲解一下。 </p><p>关于亚马逊的查询书目的webservice，你可以通过http://soap.amazon.com/schemas3/AmazonWebServices.wsdl来获知定义。 </p><p>我们要关注的是它的关键词查询请求的方法，它的定义是： </p><p><pre>&lt;operation name=<font class="Fields">"KeywordSearchRequest"</font>&gt; </p><p>	</font>&lt;soap:operation soapAction=<font class="Fields">"http:<font class="Comments">//soap.amazon.com"</font> /&gt;</font></p><p>	&lt;input&gt;</p><p>		</font>&lt;soap:body use=<font class="Fields">"encoded"</font></p><p>		</font>encodingStyle=http:<font class="Comments">//schemas.xmlsoap.org/soap/encoding/ namespace=<font class="Fields">"http:<font class="Comments">//soap.amazon.com"</font> /&gt;</font></p><p>	&lt;/input&gt;</p><p>	&lt;output&gt;</p><p>		</font>&lt;soap:body use=<font class="Fields">"encoded"</font></p><p>		</font>encodingStyle=http:<font class="Comments">//schemas.xmlsoap.org/soap/encoding/ namespace=<font class="Fields">"http:<font class="Comments">//soap.amazon.com"</font> /&gt;</font></p><p>	&lt;/output&gt;</p><p>&lt;/operation&gt; </p><p></pre></p><p>我们提交对包含指定关键词的书目查询，如果查询成功，将会返回一系列书名节点，每一本书都提供了作者、出版社、出版日期、价格等等信息。这些书名节点都在一个“Details”节点下。查询结果的总数放在TotalResults节点。每页10个结果，可以通过查看TotalPages节点来确定需要多少页。 </p><p>那么，kSOAP2可以很简单地通过SoapObject的getProperty方法来得到书详细信息的节点，存储入一个Vector对象中，如下所示： </p><p><pre>HttpTransport ht = <font class="keyword">new </font>HttpTransport(<font class="Fields">"http:<font class="Comments">//soap.amazon.com/onca/soap3"</font>); </font></p><p>ht.call(<font class="keyword">null</font>, envelope); </p><p>SoapObject result = (SoapObject) envelope.getResult(); </p><p>Vector resultVector = (Vector) result.getProperty(<font class="Fields">"Details"</font>); </p><p></pre></p><p>Vector对象中实际上还是存储了一组SoapObject对象，这里的每一个SoapObject对象对应于一本书的DOM对象。 </p><p>那么如何得到每一本书的书名、价格呢？ </p><p><pre>for(<font class="keyword">int </font>i = 0; i &lt; resultVector.size(); i++){ </p><p>	SoapObject detail = (SoapObject) resultVector.elementAt(i);</p><p>	</font>System.<font class="Fields">out</font>.println(</font><font class="Fields">"书名&gt;&gt;"</font>+(String) detail.getProperty(</font><font class="Fields">"ProductName"</font>)); </p><p>	</font>System.<font class="Fields">out</font>.println(</font><font class="Fields">"日期&gt;&gt;"</font>+(String) detail.getProperty(</font><font class="Fields">"ReleaseDate"</font>)); </p><p>	</font>System.<font class="Fields">out</font>.println(</font><font class="Fields">"价格&gt;&gt;"</font>+(String) detail.getProperty(</font><font class="Fields">"ListPrice"</font>)); </p><p>} </p><p></pre></p><p>这样就可以了。 </p><p>需要注意的是，要测试这个工程，必须到亚马逊的http://www.amazon.com/webservice 注册获取Access Key ID，也就是webservice方法中的“devtag”参数所需要的Developer-Tag。 </p><p style="color:#3333FF;">2.3．webservice传递自定义复杂对象</p><p>下面我们讲述如何在MIDP设备和webservice之间传递自定义类，比如这个类中不但有String类型成员变量，还有Vector之类的复杂类型。 </p><p>大致思路就是，在服务器端将类实例按照一定规格（一个一个的成员变量写）序列化为byte[]，将这个byte[]数组返回给kSOAP2。kSOAP2收到之后，再反序列化，将byte[]一段一段地读入类实例。 </p><p style="color:#3333FF;">2.3.1．webservice服务器端的做法</p><p>我们先来定义要传递的wsTeam类： </p><p>类定义</p><p><pre><font class="keyword">public </font><font class="keyword">class </font>wsTeam{ </p><p>	<font class="keyword">private </font>String wsReturnCode; </p><p>	<font class="keyword">private </font>String wsPersonCount; </p><p>	<font class="keyword">public </font>StringVector wsvPersonName; </p><p>	<font class="keyword">public </font>byte[] serialize(); </p><p>	<font class="keyword">public </font><font class="keyword">static </font>wsTeam deserialize(byte[] data); </p><p>}</p><p></pre></p><p>其中，StringVector类是另外一个自定义类，就是简单地把String[]封装了一下，便于操作。StringVector类定义在示范代码中可以找到。 </p><p>服务器端主要是序列化，所以我们来讲讲wsTeam的serialize()函数。 </p><p>wsTeam的序列化函数</p><p><pre><font class="keyword">public </font>byte[] serialize() {</p><p>	</font>ByteArrayOutputStream baos = <font class="keyword">new </font>ByteArrayOutputStream();</p><p>	</font>DataOutputStream dos = <font class="keyword">new </font>DataOutputStream(baos);</p><p>	<font class="keyword">try </font>{</p><p>		dos.writeUTF(wsReturnCode);</p><p>		dos.writeUTF(wsPersonCount);</p><p>		wsvPersonName.writeObject(dos);</p><p>		baos.close();</p><p>		dos.close();</p><p>	</font>} <font class="keyword">catch </font>(Exception exc) {</p><p>		exc.printStackTrace();</p><p>	}</p><p>	<font class="keyword">return </font>baos.toByteArray();</p><p>}</p><p></pre></p><p>这样，类实例就可以把自己序列化为byte[]数组。 </p><p>那么，webservice可以这么提供： </p><p>服务器端 </p><p><pre><font class="keyword">public </font><font class="keyword">class </font>SimpleKSoapWS { </p><p>	<font class="keyword">public </font>SimpleKSoapWS () { </p><p>	} </p><p>	<font class="keyword">public </font>byte[] foo2(String username, String password) { </p><p>		</font>wsTeam obj= <font class="keyword">new </font>wsTeam ();</p><p>		<font class="keyword">return </font>obj.serialize(); </p><p>	} </p><p>} </p><p></pre></p><p>到了MIDP设备上，要能够从byte[]恢复出wsTeam类实例才行。 </p><p>StringVector的序列化方法writeObject也很简单，先写入字符串数组的大小，然后再将每一个元素写入，如下所示： </p><p>StringVector的序列化 </p><p><pre><font class="keyword">public </font><font class="keyword">class </font>StringVector {</p><p>	<font class="keyword">public </font><font class="keyword">synchronized </font><font class="keyword">void </font>writeObject(java.io.DataOutputStream s)</p><p>			<font class="keyword">throws </font>java.io.IOException {</p><p>		<font class="Comments">// Write out array length</font></p><p>		s.writeInt(count);</p><p>		<font class="Comments">// Write out all elements in the proper order.</font></p><p>		<font class="keyword">for </font>(</font><font class="keyword">int </font>i = 0; i &lt; count; i++) {</p><p>			s.writeUTF(data);</p><p>		}</p><p>	}</p><p>}</p><p></pre></p><p style="color:#3333FF;">2.3.2．MIDP设备的做法</p><p>和前面的MIDlet代码差不多，只不过要kSOAP2的MarshalBase64出场了。 </p><p>在kSOAP中，我们用Base64把二进制流编码为ASCII字符串，这样就可以通过XML/SOAP传输二进制数据了。 </p><p>org.ksoap2.serialization.MarshalBase64的目的就是，把SOAP XML中的xsd:based64Binary元素序列化为Java字节数组(byete array)类型。类似的，kSOAP2还提供了MarshalDate、MarshalHashtable类来把相应的元素序列化为Java的Date、Hashtable类型。 </p><p>使用MarshalBase64 </p><p><pre><font class="keyword">import </font>org.ksoap2.serialization.MarshalBase64; </p><p>SoapObject request = <font class="keyword">new </font>SoapObject(serviceNamespace, methodName); </p><p>SoapSerializationEnvelope envelope = </p><p><font class="keyword">new </font>SoapSerializationEnvelope(SoapEnvelope.VER11); </p><p>envelope.bodyOut = request; </p><p><font class="keyword">new </font>MarshalBase64().register(envelope); </p><p>HttpTransport tx = <font class="keyword">new </font>HttpTransport(serviceNamespace); </p><p>tx.debug = <font class="keyword">true</font>; </p><p>tx.call(<font class="keyword">null</font>, envelope); </p><p>Object Response = envelope.getResult(); </p><p></pre></p><p>将接收到的SoapObject强制转换为byte[]。 </p><p>转换</p><p><pre>byte[] by = (byte[])Response; </p><p></font>System.<font class="Fields">out</font>.println(</font><font class="Fields">"succ convert!"</font>); </p><p></pre></p><p>然后，再调用反序列化 </p><p><pre>wsTeam wc = wsTeam.deserialize(by); </p><p></pre></p><p>这样，在无线设备上就得到了wsTeam类实例了。 </p><p>wsTeam的deserialize函数是这么定义的： </p><p>wsTeam的反序列化函数 </p><p><pre><font class="keyword">public </font><font class="keyword">class </font>StringVector {</p><p>	<font class="keyword">public </font><font class="keyword">static </font>wsTeam deserialize(byte[] data) {</p><p>		</font>ByteArrayInputStream bais = <font class="keyword">new </font>ByteArrayInputStream(data);</p><p>		</font>DataInputStream dis = <font class="keyword">new </font>DataInputStream(bais);</p><p>		</font>wsTeam wc = <font class="keyword">new </font>wsTeam();</p><p>		<font class="keyword">try </font>{</p><p>			wc.wsReturnCode = dis.readUTF();</p><p>			wc.wsPersonCount = dis.readUTF();</p><p>			wc.wsvPersonName.readObject(dis);</p><p>			bais.close();</p><p>			dis.close();</p><p>		</font>} <font class="keyword">catch </font>(Exception exc) {</p><p>			exc.printStackTrace();</p><p>		}</p><p>		<font class="keyword">return </font>wc;</p><p>	}</p><p>}</p><p></pre></p><p>StringVector的反序列化方法readObject也很简单，先读入字符串数组的大小，就自行新建一个同样大小的字符串数组，然后再将每一个元素写入这个数组，如下所示： </p><p>StringVector的反序列化 </p><p><pre><font class="keyword">public </font><font class="keyword">class </font>StringVector {</p><p>	<font class="keyword">public </font><font class="keyword">synchronized </font><font class="keyword">void </font>readObject(java.io.DataInputStream s)</p><p>			<font class="keyword">throws </font>java.io.IOException, ClassNotFoundException {</p><p>		<font class="Comments">// Read in array length and allocate array</font></p><p>		<font class="keyword">int </font>arrayLength = s.readInt();</p><p>		</font>data = <font class="keyword">new </font>String[arrayLength];</p><p>		<font class="Comments">// 同步data的大小</font></p><p>		count = arrayLength;</p><p>		<font class="Comments">// Read in all elements in the proper order.</font></p><p>		<font class="keyword">for </font>(</font><font class="keyword">int </font>i = 0; i &lt; arrayLength; i++) {</p><p>			data = s.readUTF();</p><p>		}</p><p>	}</p><p>}</p><p></pre></p><p>通过上面的反序列化，我们就可以通过</p><p><pre><font class="keyword">for </font>(</font><font class="keyword">int </font>i=0; i &lt; wc.wsvPersonName.size(); i++) { </p><p>	</font>System.<font class="Fields">out</font>.println(</font><font class="Fields">"第"</font> + i +</font><font class="Fields">"个人："</font> + </p><p>	wc.wsvPersonName.getStringAt(i));</p><p>}</p><p></pre></p><p>来打印MIDlet上收到的类对象中的StringVector成员变量了。 </p><p style="color:#3333FF;">3．小结</p><p>利用kSOAP2提供的框架，你可以在无线设备和Internet webservice之间，既可以传递简单的数值，也可以传递各种各样的类对象。</p><p></p></div>

</DIV></DIV>

<DIV id=footer style="display:none">
<P align="center">  
 
 
 
    </P>
</DIV></BODY></HTML>

