
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>Android学习手册_源码开发</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type><LINK  rel=stylesheet type=text/css href="../css/c5.css">
<meta name="Description" content=Android基础 Android组件 Android用户界面 Android设备功能 Android数据存储 Android网络应用 Android游戏开发 Android多媒体 Android源码开发 Android高级进阶 Android面试题/>
<meta name="Keywords" content="android 学习手册">
</HEAD>
<BODY id=homesecond class=serverscripting>
<DIV id=wrapper>
<DIV id=header><h1><a href="../index.html">Android学习手册</a></h1> 
</DIV>

<DIV id=navfirst>
<div id="indexGuide"><UL><li ><A href="../basic/index.html">Android基础</A> </li><li ><A href="../component/index.html">Android组件</A> </li><li ><A href="../userinterface/index.html">用户界面</A> </li><li ><A href="../device/index.html">设备功能</A> </li><li ><A href="../datastorage/index.html">数据存储</A> </li><li ><A href="../network/index.html">网络应用</A> </li><li ><A href="../game/index.html">游戏开发</A> </li><li ><A href="../multimedia/index.html">多媒体</A> </li><li class="navcurrentLink"><A href="index.html">源码开发</A> </li><li ><A href="../advance/index.html">高级进阶</A> </li><li ><A href="../interview/index.html">Android面试题</A> </li></UL></div>
</DIV>
<DIV id=navsecond>
<DIV id=course>
<div id="kcTitle">源码开发</div>

  <h2 ><A title="Launcher" href="index_207.html">Launcher</A></h2>

  <h2 ><A title="电话系统RIL" href="index_208.html">电话系统RIL</A></h2>

  <h2 class="currentLink"><A title="进程间通信" href="index_209.html">进程间通信</A></h2>
<UL><li class="currentLink"><A title=Android Framework研究之IPC（一） href="show_201_209.html">Android Framework研究之IPC（一）</A> </li><li ><A title=Android Framework研究之IPC（二） href="show_202_209.html">Android Framework研究之IPC（二）</A> </li><li ><A title=Android Binder与进程间通信（一） href="show_203_209.html">Android Binder与进程间通信（一）</A> </li><li ><A title=Android Binder与进程间通信（二） href="show_204_209.html">Android Binder与进程间通信（二）</A> </li><li ><A title=Android 创建AIDL href="show_205_209.html">Android 创建AIDL</A> </li><li ><A title=来学习Android的IPC href="show_206_209.html">来学习Android的IPC</A> </li><li ><A title=在linux下谈谈Android的IPC href="show_207_209.html">在linux下谈谈Android的IPC</A> </li><li ><A title=Android的binder机制研究（C++部分）（一） href="show_208_209.html">Android的binder机制研究（C++部分）（一）</A> </li><li class="currentLink"><A title=Android的binder机制研究（C++部分）（二） href="show_209_209.html">Android的binder机制研究（C++部分）（二）</A> </li><li ><A title=Android的binder机制研究（C++部分）（三） href="show_210_209.html">Android的binder机制研究（C++部分）（三）</A> </li><li ><A title=Android的binder机制研究（C++部分）（四） href="show_211_209.html">Android的binder机制研究（C++部分）（四）</A> </li><li ><A title=Android的binder机制研究（C++部分）（五） href="show_212_209.html">Android的binder机制研究（C++部分）（五）</A> </li></UL>
  <h2 ><A title="内部sensor系统" href="index_210.html">内部sensor系统</A></h2>

  <h2 ><A title="内部surface系统" href="index_211.html">内部surface系统</A></h2>

  <h2 ><A title="启动流程" href="index_212.html">启动流程</A></h2>

  <h2 ><A title="源码编译" href="index_213.html">源码编译</A></h2>

  <h2 ><A title="状态栏" href="index_214.html">状态栏</A></h2>

</DIV></DIV>
<DIV id=maincontent>
<DIV id=w3school>
<H1>进程间通信</H1>
<P><STRONG></STRONG></P></DIV>

<DIV>
<H2>Android Framework研究之IPC（一）</H2>
<P>　　说到Android的IPC(Inter-Process Conmmunication)首先想到的就是Handler和Looper，Handler用于多进程之间的通信和数据交换，将各进程之间通信的数据Message放置到Message Queue里，而Looper用于创建各进程自身的mess</P>
<P><A title="Android Framework研究之IPC（一）" href="show_201_209.html">进入 Android Framework研究之IPC（一）</A> </P></DIV>

<DIV>
<H2>Android Framework研究之IPC（二）</H2>
<P>　　对于Android的IPC来说，除了Handler和Looper之外，还有另外一种简便的方法来实现多线程的通信，那就是AsyncTask。 AsyncTask是一个异步的方法，它允许背景运算并把结果更新到前台的UI线程之上。要实现一个AsyncTask</P>
<P><A title="Android Framework研究之IPC（二）" href="show_202_209.html">进入 Android Framework研究之IPC（二）</A> </P></DIV>

<DIV>
<H2>Android Binder与进程间通信（一）</H2>
<P>　　Binder机制是android中实现的进程间通信的架构，它采用的是c/s架构，client通过代理完成对server的调用。ServiceManager既然这里提到了server，那么我们有必要先了解下在android中是怎么来管理server的。先来看一个</P>
<P><A title="Android Binder与进程间通信（一）" href="show_203_209.html">进入 Android Binder与进程间通信（一）</A> </P></DIV>

<DIV>
<H2>Android Binder与进程间通信（二）</H2>
<P>　　[color=blue]真正的Binder我们在上面所提到的这些Binder实际上只是JVM中的Binder，主要作用是提供了访问C++中的代理Binder，叫做BpBinder(BproxyBinder)。真正的Binder是Linux上的一个驱动设备，专门用来做android的</P>
<P><A title="Android Binder与进程间通信（二）" href="show_204_209.html">进入 Android Binder与进程间通信（二）</A> </P></DIV>

<DIV>
<H2>Android 创建AIDL</H2>
<P>　　[color=blue]远程过程调用      Android拥有轻量级的远程调用机制(RPC)—方法在本地调用，在远程执行(在其它进程中)，结果返回给调用者。这意味着将方法调用及其附带的数据分解为操作系统可以理解的形式，将其由本地</P>
<P><A title="Android 创建AIDL" href="show_205_209.html">进入 Android 创建AIDL</A> </P></DIV>

<DIV>
<H2>来学习Android的IPC</H2>
<P>　　在代码分析中，我发现Android中只是把Binder理解成进程间通讯的实现，有点狭隘，而是应该站在公共对象请求代理这个高度来理解Binder，Service的概念，这样我们就会看到不一样的格局，从这个高度来理解设计意图，我们</P>
<P><A title="来学习Android的IPC" href="show_206_209.html">进入 来学习Android的IPC</A> </P></DIV>

<DIV>
<H2>在linux下谈谈Android的IPC</H2>
<P>　　我们理解了Service Manager的工作就是登记功能，现在再回到IPC上，客服端如何建立连接的？我们首先回到通讯的本质：IPC。从一般的概念来讲，Android设计者在Linux内核中设计了一个叫做Binder的设备文件，专门用来进</P>
<P><A title="在linux下谈谈Android的IPC" href="show_207_209.html">进入 在linux下谈谈Android的IPC</A> </P></DIV>

<DIV>
<H2>Android的binder机制研究（C++部分）（一）</H2>
<P>　　[color=blue]概述    android的binder机制提供一种进程间通信的方法，使一个进程可以以类似远程过程调用的形式调用另一个进程所提供的功能。binder机制在Java环境和C/C++环境都有提供。android的代码中，与C/C++的bi</P>
<P><A title="Android的binder机制研究（C++部分）（一）" href="show_208_209.html">进入 Android的binder机制研究（C++部分）（一）</A> </P></DIV>

<DIV>
<H2>Android的binder机制研究（C++部分）（二）</H2>
<P>　　[color=blue](2)定义和实现binder类binder类包括两个，一个是接口实现类，一个接口代理类。接口代理类继承自BpInterface，接口实现类继承自BnInterface。这两个基类都是模板类，封装了binder的进程间通信机制，这样</P>
<P><A title="Android的binder机制研究（C++部分）（二）" href="show_209_209.html">进入 Android的binder机制研究（C++部分）（二）</A> </P></DIV>

<DIV>
<H2>Android的binder机制研究（C++部分）（三）</H2>
<P>　　这个接口函数的参数指定了一个URL，函数将为这个URL创建一个播放器实例用于播放该URL。函数首先定义了两个局部变量data和reply，变量的类型都是Parcel。Parcel是一个专为binder通信的数据传送而定义的类，该类提供了</P>
<P><A title="Android的binder机制研究（C++部分）（三）" href="show_210_209.html">进入 Android的binder机制研究（C++部分）（三）</A> </P></DIV>

<DIV>
<H2>Android的binder机制研究（C++部分）（四）</H2>
<P>　　Android的服务管理器是一个单独的进程，也向外提供接口。这段代码的含义，是通过Android的服务管理器的接口代理，请求调用服务管理器的checkService()接口函数，查找指定的服务(上面就是查找media.player服务)，查找</P>
<P><A title="Android的binder机制研究（C++部分）（四）" href="show_211_209.html">进入 Android的binder机制研究（C++部分）（四）</A> </P></DIV>

<DIV>
<H2>Android的binder机制研究（C++部分）（五）</H2>
<P>　　首先是一个宏定义CHECK_INTERFACE()，这个宏定义的作用是检查接口的描述字符串，这个前面也提到过，不需细说。然后就是onTrasact()函数的实现。这个函数的结构也很简单，就是根据参数code的值分别执行不同的功能调用</P>
<P><A title="Android的binder机制研究（C++部分）（五）" href="show_212_209.html">进入 Android的binder机制研究（C++部分）（五）</A> </P></DIV>

</DIV>

<DIV id=footer style="display:none">
<P align="center"> 
 
 
 
  </P>
</DIV></DIV></BODY></HTML>

